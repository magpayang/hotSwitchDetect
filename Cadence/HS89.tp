--------------------------------------------------------------------------------
-- Filename: MAX92755.tp
--
-- Purpose:
--     Device tests and application specific routines.
--
-- Procedures and functions included in this file
--     Global_Init
--     TestFixture_init
--     OnInit_Connect
--     OnPowerdown_Disconnect
--     ExportDataSingle
--     Set_Voltage_Levels
--     TestFixture_Checker
-- History:
--     mm/dd/yyyy   username            -- Initial Version
--     02/20/2010   pla                 -- Added Set_Voltage_Levels
--     05/27/2011   pla                 -- Added several "use module" statements for Rev B template
--                                      -- Removed use module statements for spi_dc_tests.mod and lib_OSpins.tmod
--     03/22/2012   pla                 -- Added use_module statement for ppmu_ctrl.mod
--
--     03/04/2020   zin                 -- Modified the program for program rev h release (see below)
--                                      -- Removed wait time in SetVoltage function
                                        -- Replaced CFGLevel test with new CFG_VIN_3PINS procedure Vmin only
                                        -- Removed Mipi_Vth Vmax test case
                                        -- Added two new scan patterns to the program
                                        -- Implemented OTP enhancement check in OTP routine
                                        
--     
--      
--
--
--
--     
--
-- Operator variables:
--     none
--
-- Globals:
--     none
--
--------------------------------------------------------------------------------

-- Import optional module to store global variables
use module "./user_globals.mod"
use module "./user_digital.mod"
use module "./user_cbit_ctrl.mod"
use module "./tester_cbits.mod"

-----User module insert
use module "./SERDES_Pins.mod"
use module "./general_calls.mod"
use module "./reg_access.mod"
use module "./functional.mod"
use module "./HDCP.mod"
use module "./I2CTIMING_TEST.mod"
use module "./FPGA.mod"
use module "./gen_calls2.mod"
use module "./Audio.mod"
use module "./gpio.mod"
use module "./oLDI.mod"
use module "./rlms.mod"	-- needed for link sensitivity & OSN tests
-------

-- Import Maxim yield monitor
use module "/testeng/testprog/loc/cardcat/ltx_mx/libraries/maxim_yield_monitor/Maxim_Yield_Monitor.tmod"

-- Import standard operator interface
use module "/testeng/testprog/loc/cardcat/ltx_mx/libraries/lib_operator_prompt/lib_operator_prompt.mod"

-- Import Galaxy-DPAT support module
use module "/testeng/testprog/loc/cardcat/ltx_mx/libraries/mxl_dpat_galaxy_support/mxl_dpat_galaxy_support.mod"

-- Import control routines for the SMA100, SMIQ and SMATE RF generators (SSIP and OCS configurations)
use module "/testeng/testprog/loc/cardcat/ltx_mx/libraries/mxl_gtofrontendctrl/mxl_gtoFrontEndConsts.mod"
use module "/testeng/testprog/loc/cardcat/ltx_mx/libraries/mxl_gtofrontendctrl/mxl_gtoFrontEndCtrl.mod"
use module "/testeng/testprog/loc/cardcat/ltx_mx/libraries/mxl_clkctrl/mxl_clkCtrl.mod"


-- Import library routines for the OCS configuration
use module "./lib_ocs/lib_Dist.mod"
use module "./lib_ocs/lib_GTO_AWGHSB.mod"
use module "./lib_ocs/lib_SamplerDighs.mod"

-- Import routines for the HP3485A meter (SSIP and SPC configurations)
use module "./lib/lib_HP3458A_gpib.mod"

-- Print_alarms routine
--use module "/ltx/apps_modules/print_alarms"

-- FlowControl
use module "./FlowControl.mod"

-- General library routines
use module "./lib/lib_common.mod"
use module "./lib/lib_instrument_common.mod"
use module "./lib/lib_array_fileio.mod"
use module "./lib/lib_Glitch_Detect.mod"
use module "./lib/ppmu_ctrl.mod"  -- in R15.7 OS this module will be found in /opt/ltx/ltx_os/apps_modules folder

-- Import HW Checker routines
use module "hw_check.mod"

-- Import DVM routines
use module "DVM_tests.mod"


--------------------------------------------------------------------------

procedure Global_Init
-- -------------------------------------------------------------------------------
--      Initialization procedure found in onload flow
-- -------------------------------------------------------------------------------
                                                                                                                               
body
                                                                                                                               
    println(stdout,"Initializing Applications Hardware and Software")
                                                                                                                               
    -- set global vars
--    first_run   = true  JC - remove
    eng_debug   = false
    global_setup = false                                                                                                                              
    active_sites = get_active_sites                                                                                                                               
    AllSitesStored = false
        
--  Stores the value read in Operator Prompt Testblock into global Stored_HardwareBarcode
    Get_LB_Barcode()

--  Sets FlowEnable Operator Variables to known condition until checker is run
    Set_FlowEnable_False()        
    
--  Sets HWChecker & FocusCalibration flags to initial state    
    set_expr("OpVar_Force_HW_Check", TRUE)
    set_expr("OpVar_FCal_Failed", FALSE)

--  Sets STDF parameters used in datalog
    Set_STDF_Parameters()
    
--  Create Cadence versions of enVision OpVars from Operator Prompt inputs for use throughout test code.    
    Set_Cadence_OpVar_variables()

--  Create Cadence versions of enVision Global constants 
    Set_Cadence_enVision_Constants()    
                                                                                                                           
     ------   Stores the value read in TestProgData.OptoolMode into global OptoolModeCheckStatic Jay-Ar Celedio Stuck detect improvement hcu 03/26/2020 ----
    get_expr("TestProgData.OptoolMode", OptoolModeCheckStatic)
    
    if OptoolModeCheckStatic == 0 then
        set_expr("OpVar_StuckDetect", True)
    else
        set_expr("OpVar_StuckDetect", False)
    endif
    
end_body

procedure TestFixture_init
--------------------------------------------------------------------------------
-- Put relays into a known state and any other settings that are global.
--------------------------------------------------------------------------------

local

end_local

body

    debug_text("Initializing Test Fixture...@n")

--  These statements ensure usercbit circuitry is in known state  - uncomment if you use usercbit circuitry

--    --***Added next statement as workaround to BUG in usercbit_reset_all
--     usercbits_open([1..64])      --***Set consisting of all CBITS
--   
--     usercbit_reset_all  --******BUG:  Next statement does not reset the actual hardware - only shadow register
--     usercbits_set([])

-- End usercbit initialization code

    last_vdd = 0.0V     

    debug_text("Initialize Test Fixture complete.@n")

end_body


procedure OnInit_Connect(FX1_plist)
--------------------------------------------------------------------------------
in pin list[MAX_DP_PINS] : FX1_plist  -- Optional parameter.  If used, these digital pins will be connected
                                      -- to DUT via the call to Dig_pin_connect procedure.

--------------------------------------------------------------------------------
-- Description:
--  This routine connects pins and sets relays and tester instrumentation in a known state.  This routine 
--  gets run before the OnStart flow or any time an individual test is executed from the TestTool or
--   the TEST button is pressed in the FlowTool.
--     
-- History:
--  03/19/2010  PLA      -- Initial Version 
--  07/12/2011  PLA      -- Added call to Dig_pin_connect (used to connect FX1 pins)
--
-- Operator variables:
--     None
--
-- Globals:
--      last_vdd
--      hp_measure_mode

--------------------------------------------------------------------------------
-- Description:
-- This routine connects pins and sets relays and tester instrumentation in a known state.  This routine gets run before
-- the OnStart flow or any time an individual test is executed from the TestTool or the TEST button
-- is pressed in the FlowTool.
--
--  An instance of this procedure is called in OnInit_Connect procedure in OnInit Flow
--

local

end_local

body

    -- ***** Begin variable initialization: set certain variables to known state for each DUT run

    last_vdd = 0.0V    -- Initialize variable used in "Set_Voltage_Levels" microflow
    hp_measure_mode = 0   -- init hp meter measure mode for test time savings 


    -- ***** Logic to counter handler's activation/deactivation of sites and its impact on "first_run" variable.  
-- JC - remove    Multisite_first_run_Control_Start()  --  Determine status for first_run de-assert        


    -- ***** Begin AWGHR initialization: If using awghr then uncomment this section to properly initialize for each DUT run

--     if first_run or global_setup then
--         initialize awghr hardware and memory
--     else
--         initialize awghr hardware
--     end_if

    -- End AWGHR initialization    

    -- ***** Begin usercbit initialization code  Uncomment these statements if using usercbits circuitry on loadboard
    
--    --***Added next statement as workaround to BUG in usercbit_reset_all
--     usercbits_open([1..64])      --***Set consisting of all CBITS
--   
--     usercbit_reset_all  --BUG:  Next statement does not reset the actual hardware - only shadow register
--     usercbits_set([])

    -- End usercbit initialization code


    -- *****  Connect all pins to resources.
    if dp_ptc(FX1_plist) <> <::> then
        Dig_pin_connect(FX1_plist)   -- procedure for connecting FX1 resources to DUT
    end_if

    -- *****  Set_up any other hardware to known state
    Clear_sync_bus()

-----Man add code here 

   set digital pin ALL_PATTERN_PINS levels to vil 0V vih 0.1V vol 0V voh 0V iol 0mA ioh 0mA vref 0V
   wait(1ms)
   connect digital pin ALL_PATTERN_PINS to dcl  
   wait(1ms)
   disconnect digital ppmu ALL_PATTERN_PINS from fv 0V vmax 2V measure i max 2mA
   --set digital pin ALL_PATTERN_PINS modes to driver pattern     -- Do not delete !!!
   wait(1ms)       
  -- DUT supplies
   set hcovi SER_VDD +SER_VDDIO + SER_VDD18  to fv 0V vmax 4V measure i max 1A clamp imax 600mA imin -600mA   

 --need to set SER_RSVD here to 0V using HVVI
   set hvvi chan SER_RSVD irange to r50ma iclamps percent to imax 100.0 imin 100.0
   set hvvi chan SER_RSVD to fv 0V max r5v
   
   
   -- external supplies         
   set ovi chan DNUT_VDD to fv 0V measure i max 200mA clamp imax 200mA imin -200mA   
   set hcovi  DNUT_VTERM to fv 0V measure i max 200mA clamp imax 200mA imin -200mA   
   set qfvi LT_SUPPLY to fv 0V max r5v voltage supply mode
   set vi16 chan DC_SE_VI  to fv 0V  measure i max 100mA clamp imax 100mA imin -100mA

   gate hcovi SER_VDD +SER_VDDIO + SER_VDD18 +  DNUT_VTERM  on
   gate qfvi LT_SUPPLY  on
   gate ovi chan DNUT_VDD on
   gate vi16 chan DC_SE_VI on   
   gate hvvi chan SER_XRES + SER_RSVD on
   connect  hcovi SER_VDD +SER_VDDIO + SER_VDD18 +  DNUT_VTERM  remote
   connect  qfvi LT_SUPPLY  remote
 ----ABUS VI
    
   set vi16 chan  SER_ABUS2 + SER_ABUS1 + SER_ABUS0 + SER_ABUS3 to fi 0.1ua  measure V max 1v clamp vmax 2v vmin -0.1v  
   gate vi16 chan SER_ABUS2 + SER_ABUS1 + SER_ABUS0 + SER_ABUS3 on
   close cbit XRES_RELAY -- zin revb LB
   open cbit  DNUT_OSC_RELAY + MFP_LT_K12_RELAY   ----- Connect onboard osc( dnut)
   
  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
   vdd_global[1] = 0V   --SER_VDDIO
   vdd_global[2] = 0V   --SER_VDD  
   vdd_global[3] = 0V   --SER_VDDA(VDD18)
  
   end_body



procedure OnPowerdown_Disconnect

--------------------------------------------------------------------------------
-- Called at the end of every DUT test flow

local
 word LIST[MAX_SITES]    : local_active_sites
    word                    : Nsites, idx, thissite
    boolean                 : StuckDetect, InvInput = TRUE
    string[MAX_STRING]      : TextInput
    multisite integer       : bin_rslt
end_local

body

  -- Some digital pins held in high states can drive IC power supplies through the ESD diodes
  -- Set all digital pins low and open all relays

  -- Set power_pins to 0.0V 

  -- Gate off and disconnect all analog resources 
 
  -- Gate off and open relays to power_pins
       fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)     

  set digital pin ALL_PATTERN_PINS + SER_X1_AUXSCL + SER_X2_AUXSDA levels to vil 0V vih 0.1V vol 0V voh 0V iol 0mA ioh 0mA vref 0V
  disconnect digital pin ALL_PATTERN_PINS  + SER_X1_AUXSCL + SER_X2_AUXSDA from dcl  
  disconnect digital ppmu ALL_PATTERN_PINS + SER_X1_AUXSCL + SER_X2_AUXSDA from fv 0V vmax 2V measure i max 2mA

  wait(1ms)

   -- DUT supplies
   set hcovi SER_VDD+SER_VDD18+ SER_VDDIO to fv 0V vmax 4V clamp imax 600mA imin -600mA   

   set hvvi chan SER_RSVD + SER_XRES to fv 0V max r5v

   -- external supplies 
   set ps LT_SUPPLY+DNUT_VTERM +DNUT_VDD to fv 0V measure i max 200mA clamp imax 200mA imin -200mA 


   disconnect hcovi SER_VDD+SER_VDDIO+SER_VDD18
   disconnect hvvi chan SER_RSVD+ SER_XRES    -- need to float RSVD, important!!    
   disconnect ps LT_SUPPLY+DNUT_VTERM +DNUT_VDD

---Reset all relays

  open cbit ALL_HCOVI_RELAYS   --HCOVI_RELAYS 
  open cbit ALL_OVI_RELAYS     --OVI_RELAYS 
  open digital cbit ALL_FX_RELAYS     --OVI_RELAYS
  open digital cbit MFP_LT_RELAY + DNUT_RXTX_RELAY  + MFP_LT_K12_RELAY------for now
   open  cbit CB2_SLDC                     --OVI_RELAYS
    open cbit COAXB_M_RELAY                --OVI_RELAYS
 open  cbit  I2C1_LT_CB + I2C2_FT2_LT_CB  + I2C_LT_CB
 
  debug_text("OnPowerDown procedure complete.")

--============== Start of Code: Error if three consecutive Bin 143 (Stuck_Device) was observed -- JFR 07/02/2019 ===============-

  local_active_sites = get_active_sites()
  Nsites = word(len(local_active_sites))
  bin_rslt = get_swbins()
  for idx = 1 to Nsites do
  thissite = local_active_sites[idx]
  
  get_expr("OpVar_StuckDetect", StuckDetect)
    -- if (StuckDetect AND (bin_rslt[thissite] == 1)) then
--         PrevDevCode[thissite] = CurDevCode[thissite]
--     end_if               -- hcu 01/13/2020 for removed. must store value even NOT BIN 1 as per Jay Ar routine.
    
    if (StuckCounter[thissite] > 0) AND StuckDetect then
      println(stdout, "")
      println(stdout, "")
      println(stdout, " ************************************************************ ************************************************************")
      println(stdout, " ************************************************************ ************************************************************")
      println(stdout, " ************************************************************ ************************************************************")
      println(stdout, " *********************                                                                               *********************")
      println(stdout, " *********************       STUCK UNIT DETECTED ON SITE ",thissite,"!! CALL TPE/HMG TO VERIFY THE ISSUE       *********************")
      println(stdout, " *********************                                                                               *********************")
      println(stdout, " ************************************************************ ************************************************************")
      println(stdout, " ************************************************************ ************************************************************")
      println(stdout, "")
      println(stdout, "")

--         InvInput = TRUE
--         while (InvInput) do
--             print(stdout, "@n@tTYPE DONE IF SETUP WAS ALREADY CHECKED BY HMG/TPE. NEED TO REMOVE STUCK DEVICE ")
--             input(stdin, TextInput!L)
--             
--             if (pos("DONE", TextInput) = 0) then
--                 print(stdout, "@nINCORRECT INPUT ")
--                 print(stdout, "@n@tTYPE DONE IF SETUP WAS ALREADY CHECKED BY HMG/TPE. NEED TO REMOVE STUCK DEVICE ")
--             else
--                 InvInput = FALSE
                StuckCounter[thissite] = 0
--             end_if
--         end_while
   end_if
 end_for
 
   if (LoopCntr > 35) OR ChDevIns then
       set_expr("OpVar_StuckDetect", TRUE)
       println(stdout, "DEVICE EITHER CHANGED OR LOOPTEST EXCEED 35 LOOPS.")
       println(stdout, "AUTOMATICALLY ENABLE STUCK DETECT")
       LoopCntr = 1
       ChDevIns = FALSE
   end_if           

end_body


procedure ExportDataSingle(EnableOutput, Data, FileName, Comment)
--------------------------------------------------------------------------------
--  Store a single column of data to a file that can be imported into Excel
in boolean: EnableOutput
in double: Data[?]
in string[255]: FileName
in string[255]: Comment

local
  integer: NumSamp -- Length of input array
  integer: i,j  -- loop counters
  integer : FileHandle
  integer: hour, minute, second, month, day, year
end_local

body
  if (EnableOutput) then
    -- Determine size of input array in bits
    NumSamp = dimsize(Data, 1)
    
    -- Save data to a file
    open(FileHandle, program_load_path + "../" + FileName, "w")
    println(FileHandle, "# " + FileName)
    date(month, day, year)
    println(FileHandle, "# " + sprint(year) + "/" + sprint(month) + "/" + sprint(day))
    time(hour, minute, second)
    println(FileHandle, "# " + sprint(hour) + ":" + sprint(minute) + ":" + sprint(second))
    println(FileHandle, "# Tester Name: " + tester_name())
    if (tester_simulated) then
      println(FileHandle, "# This tester is simulated!")
    end_if
    println(FileHandle, "# Tester Type: " + tester_type())
    println(FileHandle, "# Test Head Type: " + test_head_type())
    println(FileHandle, "# Program Name: " + program_name())
    println(FileHandle, "# Program Load Path: " + program_load_path())
    println(FileHandle, "# " + Comment)
    for i = 1 to NumSamp do
      println(FileHandle, Data[i]:1:10)
    end_for
    close(FileHandle)
  end_if
end_body


procedure Set_Voltage_Levels
--------------------------------------------------------------------------------
--  
--------------------------------------------------------------------------------
-- Description:
--     Procedure to set digital power supply and levels.  Stores power supply level
--     into global last_vdd.  Next time procedure is called, value of last_vdd
--     is compared with new level setting to determine whether to set digital levels 
--     before or after moving the power supply level.  
--
--     Two levels blocks are called by this Cadence code in order to control 
--     execution order of power supply change and digital levels change:
--     "Levels_VDD_up" and "Levels_VDD_down".
--
--     User should modify the "Levels_VDD_up" and "Levels_VDD_down" levels blocks for
--     DUT requirements:
--          1) Add Power Supply pin to Pingroup row of DVDD_PIN column
--          2) Add digital pingroup to Pingroup row of Digital_pin_levels column
--          3) Add more columns to Levels blocks if needed.
--
--      All supply and pin levels variables are defined in the DC_Spec object.  User can
--      add categories to the Spec as needed in order to accommodate device requirements.
--
-- History:
--     02/20/2010  PLA            -- Initial Version
--     07/12/2011  PLA            -- Added Description    
--
-- Operator variables:
--     none
--
-- Globals:
--     DVDD enVision variable
--     last_vdd - declared in user_globals.mod
--------------------------------------------------------------------------------

local

    float       :   newValue
    
end_local

body

get_expr("DVDD", newValue)  -- "DVDD" is enVision Spec variable found in DC_Spec table

if last_vdd = 0.0V then
    execute levels "Levels_VDD_up"
else_if last_vdd < newValue then
    execute levels "Levels_VDD_up"
else_if last_vdd > newValue then
    execute levels "Levels_VDD_down"
else_if last_vdd = newValue then
    -- do nothing
else
    println(stdout, "***********************************************************")
    println(stdout, "Global parameter DVDD not correctly defined in this block")
    println(stdout, "***********************************************************")

end_if    

last_vdd = newValue

end_body


procedure TestFixture_Checker(Checker_Vcc_limits) 
--------------------------------------------------------------------------------
--  

in_out array of float_test : Checker_Vcc_limits

--------------------------------------------------------------------------------
-- Description:
--     Main function for the hardware fixture checker.
--     
-- History:
--     03/15/2010  Pamela Abela            -- Remove all CEX datalogger statements
--
-- Operator variables:
--     OpVar_CheckerSite_Fail
--
-- Globals:
--     None
--------------------------------------------------------------------------------


local
    multisite float : meas
    boolean : failFlag
end_local

body
    
--*****************************************************************************
--  The Empty_Socket_Check should be run before entering this code.  
--*****************************************************************************

-- Set global site checker fail flag to FALSE
     set_expr("OpVar_CheckerSite_Fail", FALSE)


--*****************************************************************************
--******************  TestFixture_Checker coding process  *********************

--***********************  Example Checker code  ******************************
    meas = 3.3V
    test_value meas with Checker_Vcc_limits

    test_value meas with Checker_Vcc_limits


--*****************************************************************************


--*****************************************************************************
-- Beginning of your checker code
--*****************************************************************************

-- Check for shorted pins.  Shorts to power/ground/other pins
-- Check for leakage
-- Check that dut supplies are at the right voltage and current
-- Check bulk supplies 
-- Check onboard regulators
-- Check relay connections
 
--*****************************************************************************        
-- End of your checker code
--***************************************************************************** 
 
  
end_body

procedure Contact_Test(force_i, odd_pins_ft, even_pins_ft, rcont_ft, vcc_cont,RSVD_CONT,XRES_CONT,GND_R_GPIO9,GND_R_PWDN,GPIO9_0p1,GPIO9_80,PWDN_0p1,PWDN_80)
--------------------------------------------------------------------------------
--  
in float                   : force_i
in_out array of float_test : odd_pins_ft
in_out array of float_test : even_pins_ft
in_out array of float_test : rcont_ft
in_out float_test          : vcc_cont,RSVD_CONT,XRES_CONT,GND_R_GPIO9,GND_R_PWDN,GPIO9_0p1,GPIO9_80,PWDN_0p1,PWDN_80

local

multisite float     :  vcont1[25], vcont2[24]
multisite float     :  icont1[14], icont2[12]
multisite float     :  vdda[1], vddd[1], vddio[1]
multisite float     :  vcc_pins[3]
multisite float     :  rcont[2]
multisite float     :  v_measp, v_measm

word list[16]       : active_sites
word                : sites, idx, site
multisite float     : supply_cont1[3],supply_cont2[3],rsvd_cont[1],xres_cont[1]
multisite float     : gpio9_100u[1],gpio9_80m[1],Gndcontact_gpio9[1],pwdn_100u[1],pwdn_80m[1],Gndcontact_pwdn[1]
end_local

body

  active_sites = get_active_sites
  sites = word(len(active_sites))

--   open cbit FX_RELAYS   
--   open hcovi HCOVI_RELAYS cbits 
--   open cbit OVI_RELAYS

   connect hvvi chan SER_RSVD + SER_XRES remote
   open cbit XRES_RELAY -- zin revb LB
  --wait(20ms)   -- in case handler index is too fast.
  
  ----Close relay to connect XRES, X1 and X2 to DPs
  close cbit XRES1_RELAY + X1X2_OSC_DP   --HCOVI_RELAYS 

  -- reset levels since FPGA_PINS levels were set during load and init routines
  set digital pin ALL_PATTERN_PINS  + AUX_PINS levels to vil 0V vih 0.2V vol 0V voh 0V iol 0mA ioh 0mA vref 0V
  set digital pin ALL_PATTERN_PINS + AUX_PINS modes to driver pattern     -- Do not delete !!!

  set hvvi chan SER_RSVD + SER_XRES to fi 0.1uA  max r500ua
  set hvvi chan SER_RSVD + SER_XRES irange to r500ua  iclamps percent to imax 80.0 imin 0.0
  set hvvi chan  SER_RSVD + SER_XRES vrange to r100v vclamps percent to vmax 5v vmin -2v 

  wait(1ms)
  
  execute digital pattern "PowerUp" at label "ALL_ZERO" wait   -- Do not delete in order to reset all pins to vil level !!!
  wait(1ms) 

---Connect dp to OUT+/out- by close COAX_P/M rlay and disconnect VIs connect to them
-- disconnect VI16s for OUT+/OUT- resistance measurement
   disconnect vi16 chan DC_SE_VI

-- --Connect Serial Link to dp

   close cbit COAXB_P_RELAY + COAXB_M_RELAY   --OVI_RELAYS

--   wait(3ms)

------------- Contact to VDDA(VDD18) and VDDD supply pins ---------------------------------------
  set hcovi SER_VDD +SER_VDDIO + SER_VDD18 to fv 0V vmax 4V measure i max 300mA clamp imax 100mA imin -100mA
  wait(1ms)
  set hcovi SER_VDD to fi -1.2mA imax -5mA measure v max 2V clamp vmax 2V vmin -2V
  wait(10ms)
  measure hcovi v on SER_VDD for 10 samples every 10us averaged into vdda
  set hcovi SER_VDD to fi 0mA measure v max 0V clamp vmax 0V vmin -1V
  set hcovi SER_VDD to fv 0V vmax 4V measure i max 300mA clamp imax 100mA imin -100mA
  
  set hcovi SER_VDDIO to fi -0.2mA imax -0.5mA measure v max 2V clamp vmax 2V vmin -2V
  wait(3ms)
  measure hcovi v on SER_VDDIO for 10 samples every 10us averaged into vddio
  set hcovi SER_VDDIO to fi 0mA measure v max 0V clamp vmax 0V vmin -1V
  set hcovi SER_VDDIO to fv 0V vmax 4V measure i max 300mA clamp imax 100mA imin -100mA  

  set hcovi SER_VDD18 to fi -200uA imax -0.5mA measure v max 2V clamp vmax 2V vmin -2V
  wait(1ms)
--    wait(7000us)     -- need this due to 47UF, will reduce when remove this cap for revB device ***
   measure  hcovi v on SER_VDD18  for 10 samples every 10us averaged into vddd
  set hcovi SER_VDDIO to fi 0mA measure v max 0V clamp vmax 0V vmin -1V
  set hcovi SER_VDDIO to fv 0V vmax 4V measure i max 300mA clamp imax 100mA imin -100mA  
      
  for idx = 1 to sites do
        site = active_sites[idx]    
        vcc_pins[site,1] = vdda[site,1]
        vcc_pins[site,2] = vddd[site,1]
        vcc_pins[site,3] = vddio[site,1]        
  end_for
--   set hcovi SER_VDDIO  + SER_VDD18 to fi force_i *2.0 imax 5ma measure v max 2v clamp vmax 2v vmin -1V
--   set hcovi  SER_VDD to fi -1.2ma imax 5ma measure v max 2v clamp vmax 2v vmin -1V
--   wait(20ms)   ---- big cap at vdd pin
--   measure hcovi v on SER_VDDIO + SER_VDD + SER_VDD18 for 50 samples every 10us averaged into supply_cont1
--   wait(2ms)
--   set hcovi SER_VDDIO + SER_VDD + SER_VDD18 to fv 0v vmax 4V measure i max 300mA clamp imax 100mA imin -100mA  
  -------- Force even pins to 0V, check contact to all odd pins by forcing current ----  
  disconnect digital pin SER_EVEN_PINS+SER_CAPVDD + SER_ODD_PINS from dcl
  enable digital ppmu SER_EVEN_PINS+SER_CAPVDD fv 0V vmax 2V measure i max 2mA
  --enable digital ppmu SER_EVEN_PINS fv 0V vmax 2V measure i max 2mA  
  enable digital ppmu SER_ODD_PINS fi 0mA  imax 2mA measure v max 2V  --imax 2mA clamps to vmin -1.8V vmax 2V -- enable before connecting to prevent glitch
  
  connect digital ppmu SER_EVEN_PINS+SER_CAPVDD to fv 0V vmax 2V measure i max 2mA
  --connect digital ppmu SER_EVEN_PINS to fv 0V vmax 2V measure i max 2mA  
  connect digital ppmu SER_ODD_PINS to fi 0mA imax 2mA measure v max 2V
  wait(1000us)

  set digital ppmu SER_EVEN_PINS to fv 0V vmax 2V measure i max 2mA
  set digital ppmu SER_ODD_PINS to fi force_i imax 2mA measure v max 2V
  set digital ppmu SER_SIOBP +  SER_SIOAP to fi 10na imax 10ua measure v max 2V
  
  set hvvi chan SER_XRES to fv 0.0v  max r5v -- set Xres odd pin
  set hvvi chan  SER_RSVD to fi force_i  max r500ua -- set rsvd even pin
  set hvvi chan  SER_RSVD to measure v max 2v
  wait(1.5ms)
  measure digital ppmu SER_ODD_PINS voltage average 20 delay 10us into vcont1
  measure hvvi on chan SER_RSVD for 20 samples every 10us averaged into rsvd_cont

  --measure digital ppmu SER_EVEN_PINS current imax 2mA average 20 delay 10us into icont1

  set digital ppmu SER_ODD_PINS to fi 0.1uA imax 2mA  measure v max 2V

---setup Xres and Rsvd pins
  set hvvi chan  SER_RSVD to fi 0.1ua  max r500ua -- set rsvd even pin
  set hvvi chan SER_RSVD to fv 0.0v  max r5v -- set RSVD even pin  

  set hvvi chan  SER_XRES to measure v max 2v
 
-------- Force odd pins to 0V, check contact to all even pins by forcing current ----  
--  disable digital ppmu SER_ODD_PINS fi 0uA   -- causes glitch
--  disable digital ppmu SER_EVEN_PINS fv 0V
  disconnect digital ppmu SER_ODD_PINS from fi 0mA
  disconnect digital ppmu SER_EVEN_PINS from fv 0V
  
  
  enable digital ppmu SER_ODD_PINS fv 0V vmax 2V measure i max 2mA
  enable digital ppmu SER_EVEN_PINS fi 0mA imax 2mA measure v max 2V  -- enable before connecting to prevent glitch

  connect digital ppmu SER_ODD_PINS to fv 0V vmax 2V measure i max 2mA
  connect digital ppmu SER_EVEN_PINS to fi 0mA imax 2mA measure v max 2V
  wait(1ms)
  
  set digital ppmu SER_ODD_PINS to fv 0V vmax 2V measure i max 2mA
  set digital ppmu SER_SIOBN  + SER_SIOAN to fi 0.1uA imax 2mA  measure v max 2V
  set digital ppmu SER_EVEN_PINS to fi force_i imax 2mA measure v max 2V
  set hvvi chan  SER_XRES to fi force_i  max r500ua -- set rsvd even pin
  wait(1.5ms)
  measure digital ppmu SER_EVEN_PINS voltage average 20 into vcont2
  measure hvvi on chan SER_XRES for 20 samples every 10us averaged into xres_cont


  --measure digital ppmu SER_ODD_PINS current imax 2mA average 20 into icont2
  set digital ppmu SER_EVEN_PINS to fi 0uA imax 2mA
   set hvvi chan  SER_XRES to fi 0.1ua  max r500ua -- set rsvd even pin 
  
------- Force all pins to 0V ------
  --disable digital ppmu SER_EVEN_PINS fi 0uA
  disconnect digital ppmu SER_EVEN_PINS from fi 0mA
  
  enable digital ppmu SER_EVEN_PINS fv 0V vmax 2V measure i max 2mA
  connect digital ppmu SER_EVEN_PINS to fv 0V vmax 2V measure i max 2mA
  set digital ppmu SER_ODD_PINS to fv 0V vmax 2V measure i max 2mA
  set hvvi chan  SER_XRES +SER_RSVD to fv 0.0v  max r5v -- set rsvd even pin 
  wait(500us)


-----Added for gnd resistance test 5/2019
---See big settling time for vdiode measure(about 500ms. Big jump in the first 15ms)
-- ---Check pin GPIO9
    set digital ppmu SER_GPIO9_SD to fi force_i imax 2mA measure v max 2V
    wait(15ms)
---- setup 8 pins with 10mA
    set digital ppmu SER_CKAN  + SER_CKAP + SER_DA0N +SER_DA0P + SER_DA3N + SER_DA3P+ SER_DA2N +SER_DA2P to fi -10mA imax 2mA measure v max 2V
    wait(2ms)
    measure digital ppmu SER_GPIO9_SD voltage average 20 into gpio9_80m
    set digital ppmu SER_CKAN  + SER_CKAP + SER_DA0N +SER_DA0P + SER_DA3N + SER_DA3P+ SER_DA2N +SER_DA2P to fv 0V vmax 2V measure i max 2mA
    wait(1ms)
    measure digital ppmu  SER_GPIO9_SD  voltage average 20 into gpio9_100u

    Gndcontact_gpio9  = (gpio9_100u - gpio9_80m )/80ma
     set digital ppmu SER_GPIO9_SD to fi 0.0 imax 2mA measure v max 2V

---Check pin PWDNB
    set digital ppmu SER_PWDNB to fi force_i imax 2mA measure v max 2V
    wait(10ms)
---- setup 8 pins with 10mA
    set digital ppmu SER_CKAN  + SER_CKAP + SER_DA0N +SER_DA0P + SER_DA3N + SER_DA3P+ SER_DA2N +SER_DA2P to fi -10mA imax 2mA measure v max 2V
    wait(2ms)
    measure digital ppmu SER_PWDNB voltage average 20 into pwdn_80m
    set digital ppmu SER_CKAN  + SER_CKAP + SER_DA0N +SER_DA0P + SER_DA3N + SER_DA3P+ SER_DA2N +SER_DA2P to fv 0V vmax 2V measure i max 2mA
    wait(1ms)
    measure digital ppmu  SER_PWDNB  voltage average 20 into pwdn_100u

    Gndcontact_pwdn  = (  pwdn_100u - pwdn_80m)/80ma
     set digital ppmu  SER_PWDNB to fi 0.0 imax 2mA measure v max 2V
 wait(500us)

 ------- Power Down ---------
  
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 0.2V vol 0V voh 0V iol 0mA ioh 0mA vref 0V
  wait(500us)
  
  set hcovi SER_VDD+SER_VDDIO + SER_VDD18 to fv 0V vmax 4V measure i max 600mA clamp imax 600mA imin -600mA 
  
  wait(500us)       -- might need to increase to 5ms or more because of 47uF on SER_VDD ***

  disconnect digital ppmu SER_ODD_PINS + SER_EVEN_PINS from fv 0V vmax 2V measure i max 2mA

  open cbit COAXB_P_RELAY + COAXB_M_RELAY     --   OVI_RELAYS 
  open cbit XRES1_RELAY  + X1X2_OSC_DP        --HOVI_RELAYS   

  connect digital pin SER_ODD_PINS + SER_EVEN_PINS to dcl
  disconnect digital pin SER_CAPVDD from dcl                 -- need to float CAP_VDD pin
  --need to float RSVD pin here using HVVI, important!!!
  --gate hvvi chan SER_RSVD off   
  disconnect hvvi chan SER_RSVD  + SER_XRES   -- need to float RSVD, important!!  

   close cbit XRES_RELAY -- zin revb LB
  wait(3ms)
  
  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)
      
------- Datalog -------------
  test_value vcont1   with odd_pins_ft
  test_value vcont2   with even_pins_ft
--  test_value rcont    with rcont_ft
  test_value vcc_pins with vcc_cont
  test_value rsvd_cont with RSVD_CONT
  test_value xres_cont with XRES_CONT

  test_value Gndcontact_gpio9 with GND_R_GPIO9
  test_value Gndcontact_pwdn  with GND_R_PWDN
  test_value gpio9_100u with GPIO9_0p1
  test_value gpio9_80m with GPIO9_80
  test_value pwdn_100u with PWDN_0p1
  test_value pwdn_80m with PWDN_80


end_body

procedure Sleep_Power_Down(vcore, vio, v18, pinList, devid_it, sleep_icc, sm1, pd_icc, pd1, vadd_I, viodd_I, vddd_I, POWERUP,POWERDOWN, vadd_I2,CmuCapTest,CmuCapSleepTest,IpowerUpAgain)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--  

in float                   : vio, vcore, v18
in pin list[4]             : pinList
in_out array of float_test : sleep_icc, pd_icc,IpowerUpAgain
in_out float_test          : sm1, pd1
in_out integer_test        : devid_it
in_out float_test          : vadd_I2, CmuCapTest,CmuCapSleepTest
in_out array of float_test : vadd_I, vddd_I, viodd_I
in boolean                 : POWERUP,POWERDOWN
local

multisite float   : smicc1[3], pdicc1[3], amicc1[3], smicc1fordlog[3]
multisite float   : t_sm1,     t_pd1
multisite float   : pdidd1[1], smidd1[1], amidd1[1]
multisite word    : reg --,data
word list[16]     : active_sites
word              : sites, idx, site
multisite integer : reg_val, reg_val0, reg_val1
integer           : idxs
float             : Vconf0, Vconf1
multisite lword   : lowword, upperword, data

multisite float   : i_vadd[1], i_vddd[1], i_viodd[1],CapVdd_Active[1], CapVdd_Sleep[1],i_vadd2[1],tempsleepIovdd[1],sleepIovdd[1],tempIsleep[2],I_PowerUpAgain[2]

   boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount,count


end_local

body

   loopcont  = true
   SiteCheck  = false 
    
    get_expr("TestProgData.Device", DEVICE)  
    
    connect digital ppmu SER_CAPVDD to fi 10na  imax 100uA  measure v max 2V 
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    -- can take out later but keep for now to make sure all MFP pins connected to DPs

    --make sure RSVD pin float (HVVI disconnect)
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
    close cbit COAXB_P_RELAY + COAXB_M_RELAY  ---Connecto DC circuit  MT 11/2018 
    
    set digital pin SER_CSI_PINS driver low
    DutPowerUp(vio, v18, vcore, "UART", "TP_GMSL2",POWERUP)   
    RegRead(SER_ID, 16#00, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device, to comply with check list
    wait(200us)
           
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      reg_val[site]  = integer(lowword[site])        
    end_for 
    
    if vcore > 1.14 then   ---- need to turn on LDO
        RegWrite(SER_ID, SR_CTRL0, 1, 0,16#15, "SER_UART_Write")----Reg_enable = 1
        RegWrite(SER_ID,SR_CTRL2, 1, 0,16#14, "SER_UART_Write")  -----LDO =1
        wait(1ms)
    end_if       
    
-- --------------- temp active supply current tests for samples ------------    
   set hcovi SER_VDDIO  to fv vio vmax 4V measure i max 600uA  clamp imax 600uA  imin -600uA

--   wait(1ms)
  measure hcovi i on SER_VDD for 30 samples every 10us averaged into i_vadd
  measure hcovi i on SER_VDDIO for 30 samples every 10us averaged into i_viodd 
  measure hcovi i on SER_VDD18 for 20 samples every 20us averaged into i_vddd  
-------------------------------------------------------------------------
  -----Measure CapVdd voltage  on 7/2018. Keep Similar to HS94 jiyoon Park. Mt.
    set digital ppmu SER_CAPVDD to fi 0.1ua imax 2ua measure v max 2.0v
    wait(3ms)----needed for cold  change to 3ms per MPOC request MT 3/1/2019


    measure digital ppmu SER_CAPVDD  voltage  average 10 delay 10us into CapVdd_Active
    

---Add another measurement for IVdd at different supplies to cover spec.
   if vcore =1.26V then 
        set hcovi SER_VDD  to fv 1.14V vmax 4V measure i max 600mA  clamp imax 600mA  imin -600mA
        wait(1ms)

        measure hcovi i on SER_VDD for 30 samples every 10us averaged into i_vadd2
    else
        set hcovi SER_VDD  to fv 1.0 vmax 4V measure i max 600mA  clamp imax 600mA  imin -600mA        
         wait(1ms)
        set hcovi SER_VDD  to fv 0.95 vmax 4V measure i max 600mA  clamp imax 600mA  imin -600mA
        measure hcovi i on SER_VDD for 30 samples every 10us averaged into i_vadd2
    end_if
    wait(2ms) -- CKT:032719: To address invalid sleep_pwdn failures
    set hcovi SER_VDD  to fv vcore vmax 4V measure i max 600mA  clamp imax 600mA  imin -600mA
    wait(3ms) -- CKT: 032819: Split original 5ms delay
   
--  ------ without 2 lines below can not put part in sleep mode. not happen on revA board need to debug later. MT 11-2018
     fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)     
      lowword  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read     
-- wait(2ms)
    ---------------- 
     --------
--------------- Write reg 0X10,  bit[3] to 1 to set sleep mode ------------

    RegRead(SER_ID, 16#10, 1, upperword, lowword,"SER_UART_Read")   -- sleep reg before set sleep mode    
    RegWrite(SER_ID, SR_PWR4, 1, 0,16#0A, "SER_UART_Write")  ------Disable wake up from local and remote
    if vcore > 1.14 then
        RegWrite(SER_ID, SR_CTRL0, 1, 0, 16#1D, "SER_UART_Write")        -- sleep reg, enable sleep mod  
    else
    
        RegWrite(SER_ID, SR_CTRL0, 1, 0, 16#19, "SER_UART_Write")        -- sleep reg, enable sleep mod  
    end_if
    wait(10ms)  -- NEED THIS DELAY for device go to sleep mode !!!            
--     RegRead(SER_ID, 16#10, 1, upperword, lowword,"SER_UART_Read")     -- if CAN read here then device NOT in sleep mode!!!
--     wait(100ms) 
  
------------ Measure Sleep Mode Currents ----------------
   set hcovi SER_VDD   to fv vcore  vmax 4V measure i max 500uA clamp imax 500uA imin -500uA                  
   set hcovi SER_VDDIO  to fv vio vmax 4V measure i max 400uA clamp imax 400uA imin -500uA 
   set hcovi SER_VDD18 to fv v18  vmax 4V measure i max 500uA clamp imax 500uA imin -500uA    

    disconnect digital pin ALL_PATTERN_PINS - SER_PWDNB from dcl delay 100us
    disconnect digital pin ALL_PATTERN_PINS - SER_PWDNB from ppmu delay 100us  
    wait(2ms)  -- minimum 5ms   
   set hcovi SER_VDD   to fv vcore  vmax 4V measure i max 210uA clamp imax 210uA imin -210uA
   set hcovi SER_VDDIO  to fv vio vmax 4V measure i max 210uA clamp imax 210uA imin -210uA 
   set hcovi SER_VDD18 to fv v18  vmax 4V measure i max 210uA clamp imax 210uA imin -210uA
   wait(1ms)  -- minimum 5ms 
  measure hcovi i on pinList   for 10 samples every 10us averaged into smicc1
  for idx = 1 to sites do
        site = active_sites[idx]
        smicc1fordlog[site,1] = smicc1[site,1]
        smicc1fordlog[site,2] = smicc1[site,2] 
        smicc1fordlog[site,3] = smicc1[site,3] 
  endfor 
 ---Optimum test time
    while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  (smicc1[site,1] > -0.9uA and smicc1[site,2] > -0.9uA and smicc1[site,3] > -0.9uA and smicc1[site,2] < 90uA) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true  
                    smicc1fordlog[site,1] = smicc1[site,1]
                    smicc1fordlog[site,2] = smicc1[site,2] 
                    smicc1fordlog[site,3] = smicc1[site,3] 
                end_if
                if sitecount = sites then
                    loopcont = false
                end_if     
         end_for
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
              
            if loopcont  then
                wait(1ms)
                measure hcovi i on pinList   for 10 samples every 10us averaged into smicc1
            end_if
            
--        end_for            
 
    end_while
 

----Measure sleep CapVdd volatge MT 6-2018
    wait(5ms)----needed for cold40ms
    measure digital ppmu SER_CAPVDD  voltage  average 10 delay 10us into CapVdd_Sleep
-------------- Enter Power Down mode -----------------
   set hcovi SER_VDDIO  to fv vio vmax 4V measure i max 600uA  clamp imax 600uA  imin -600uA
  set hcovi SER_VDD  to fv vcore  vmax 4V measure i max 500mA clamp imax 500mA  imin -500mA
  set hcovi SER_VDD18  to fv v18 vmax 4V measure i max 500mA  clamp imax 500mA  imin -500mA    
  set digital pin SER_PWDNB levels to vil 0V vih 100mV   -- make /PWDN=0
  wait(1ms) 

-------------- power up parts -----------------
  set digital pin SER_PWDNB levels to vil 0V vih vio-0.1v   -- make /PWDN=0
  wait(3ms)  -- minimum 1ms
----Check current make sure it is high  
  measure hcovi i on SER_VDD + SER_VDD18   for 10 samples every 10us averaged into I_PowerUpAgain

-------------- Enter Power Down mode -----------------
  set digital pin SER_PWDNB levels to vil 0V vih 100mV   -- make /PWDN=0
  wait(5ms)  -- minimum 1ms
-------------- Measure Power Down Currents ----------------
  set hcovi SER_VDD  to fv vcore  vmax 4V measure i max 50uA clamp imax 210uA  imin -210uA
  set hcovi SER_VDDIO  to fv vio vmax 4V measure i max 50uA  clamp imax 210uA  imin -210uA
  set hcovi SER_VDD18  to fv v18 vmax 4V measure i max 210uA  clamp imax 210uA  imin -210uA  
  wait(5ms) ---50ms
  measure hcovi i on pinList for 10 samples every 10us averaged into pdicc1
   loopcont  = true
   SiteCheck  = false 
   sitecount  = 0
   count  = 0

---Optimum test time
    while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  ((pdicc1[site,1] > -0.9uA and pdicc1[site,1] <18.9uA) and (pdicc1[site,2] > -0.9uA and pdicc1[site,2] < 18uA) and (pdicc1[site,3] > -0.9uA and pdicc1[site,3] < 18uA)) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true     
                end_if
                if sitecount = sites then
                    loopcont = false
                end_if     
        end_for 
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
            if loopcont  then
                wait(1ms)
                measure hcovi i on pinList   for 10 samples every 10us averaged into pdicc1
            end_if
            
           
    end_while


--  measure hcovi i on SER_VDD18 for 20 samples every 20us averaged into pdidd1 
    
---set back high current for supply pins
----############################################################################################
   set hcovi SER_VDD18 to fv v18  vmax 0V measure i max 500mA clamp imax 500mA imin -500mA     
   set hcovi SER_VDDIO  to fv vio vmax 4V measure i max 500mA  clamp imax 500mA  imin -500mA
----############################################################################################


-- -------------- Power Down ---------------------------
  set digital pin ALL_PATTERN_PINS - fpga_pattern_pins levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V

  connect digital pin ALL_PATTERN_PINS to dcl delay 100us
  wait(500us)
  set hcovi  pinList to fv 0V vmax 4V clamp imax 600mA imin -600mA           
 

 open cbit COAXB_P_RELAY + COAXB_M_RELAY  ---Connecto DC circuit  MT 11/2018
 wait(5ms)     -- extra for 47uF cap on SER_VDD    
  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)


  
  for idx = 1 to sites do
    site = active_sites[idx]
--    smicc1[site,3]  =  smidd1[site,1]    
--    pdicc1[site,3]  =  pdidd1[site,1]   
    --t_sm1[site] = smicc1[site,1]+smicc1[site,2]+smidd1[site,1]
    -- sleep mode exclude current from VDDIO
    t_sm1[site] = smicc1[site,1]+smidd1[site,1]
    t_pd1[site] = pdicc1[site,1]+pdicc1[site,2]+pdicc1[site,1]
  end_for
   
    
---+SER_VDDIO+SER_VDD18
-------------- Datalog Results ----------------
 ----fake this for debug

  test_value reg_val with devid_it
  test_value smicc1fordlog with sleep_icc --mode TVM_PINS
--  test_value t_sm1  with sm1   ----Char only
  test_value pdicc1 with pd_icc  --  mode TVM_PINS
--  test_value t_pd1  with pd1   ---char only

  test_value i_vadd  with vadd_I
  test_value i_viodd with viodd_I   
  test_value i_vddd  with vddd_I   
  test_value i_vadd2  with vadd_I2
--  test_value i_vadd_sleep2  with vadd_I_sleep2

  test_value CapVdd_Active with   CmuCapTest  
  test_value CapVdd_Sleep  with  CmuCapSleepTest
  test_value I_PowerUpAgain with IpowerUpAgain  --  mode TVM_PINS
end_body

procedure HS89_Leakage(vcore, vio, v18,  SE_ODD_HI_LEAKAGE, SE_ODD_LO_LEAKAGE, SE_EVEN_HI_LEAKAGE, SE_EVEN_LO_LEAKAGE, PWDN_HI_LEAKAGE, PWDN_LO_LEAKAGE,RSVD_HI_LKG,RSVD_LO_LKG,XRES_HI_LKG,XRES_LO_LKG,X1_Res,X2Lo,X2Hi,CapVddLo )
--------------------------------------------------------------------------------
--  

in float: vcore, vio, v18
in_out float_test: SE_ODD_HI_LEAKAGE, SE_ODD_LO_LEAKAGE, SE_EVEN_HI_LEAKAGE, SE_EVEN_LO_LEAKAGE, PWDN_HI_LEAKAGE, PWDN_LO_LEAKAGE ,RSVD_HI_LKG,RSVD_LO_LKG,XRES_HI_LKG,XRES_LO_LKG,X1_Res,X2Lo,X2Hi,CapVddLo
--in_out float_test: TRI_HI_LEAKAGE, TRI_LO_LEAKAGE
--in_out float_test: OD_HI_LEAKAGE, OD_LO_LEAKAGE, GPO_HI_LEAKAGE, GPO_LO_LEAKAGE
--in_out float_test: GPIO_LO_LEAKAGE


local

word    : site , idx
--integer : idx

multisite float     : leakage_SE_low[22], leakage_SE_high[22]

multisite float     : leak_SE_odd_hi[24], leak_SE_even_hi[25], leak_SE_odd_lo[24], leak_SE_even_lo[25]
multisite float     : leak_pwd_hi[1],    leak_pwd_lo[1],RSVD_HI,XRES_HI,XRES_LO,RSVD_LO
float               : Vconf0, Vconf1
multisite lword     : lowword, upperword, data
multisite float     : leak_x1_hi[1],leak_x2_hi[1],x1_res,x2_res
multisite float     : leak_x2_lo[1],leak_CapVdd_lo[1]
boolean             : MPW5
PIN LIST[24]            : temp



end_local

body

-- NEED to ADD leakage for X1/X2/XRES/RSVD/CAP_VDD later !!!!!!!!!!!!!!!!

  active_sites = get_active_sites
  sites = word(len(active_sites))  
    
    MPW5 = false 
--  disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!  
  connect hvvi chan SER_RSVD + SER_XRES remote
--  connect hvvi chan  SER_XRES remote

  set hvvi chan SER_RSVD + SER_XRES to fv 0v max r5v  
  set hvvi chan SER_RSVD  irange to r500ua iclamps percent to imax 90.0 imin 0.0  

  set hvvi chan  SER_XRES irange to r5ma iclamps percent to imax 90.0 imin 0.0
  set hvvi chan  SER_XRES to measure i  max 5ma
  set hvvi chan SER_RSVD  to measure i  max 400ua
 
  -- reset levels
  set digital pin ALL_PATTERN_PINS  - fpga_pattern_pins levels to vil 0V vih 0.1V vol 0V voh 0V iol 0mA ioh 0mA vref 0V
  set digital pin ALL_PATTERN_PINS modes to driver pattern     -- Do not delete !!!
  wait(1ms)
  

  -- DPs shared from FPGA switched to X1, X2, XRES DUT pins
    close cbit XRES1_RELAY + X1X2_OSC_DP   --HOVI_RELAYS  
    open cbit XRES_RELAY    --HOVI_RELAYS  ----RevB HW


    open  cbit FB_RELAY  ---Make sure Dp connect to CSI pins


--disconnect Serial Link to VI16s

-----Disconnect SIO+/- from DPs --- this will be taken care by disconnect dcl pin group all pattern pins   
  wait(3ms)
  

    --The function below is for setting DUT supplies ONLY, change Voltage if Required  
    Set_SER_Voltages(vio, vcore, v18)
--    wait (5ms) -- trial for 47uF cap on SER_VDD

    force_instr(ALL_PATTERN_PINS - fpga_pattern_pins,   "PPMU", "VOLTAGE" ,0V, 200uA,  -200uA,   200uA)
    wait(1ms)
    
    disconnect digital pin ALL_PATTERN_PINS - fpga_pattern_pins from dcl delay 100us
    set digital pin ALL_PATTERN_PINS- fpga_pattern_pins levels to vil 0V vih vio*0.9 iol 0uA ioh 0uA vref 0V
    
    connect digital pin ALL_PATTERN_PINS- fpga_pattern_pins to ppmu --delay 100us               
    disconnect digital pin SER_ODD_PINS + SER_EVEN_PINS - SER_PWDNB + SER_CAPVDD from dcl delay 100us
    connect digital pin SER_ODD_PINS + SER_EVEN_PINS - SER_PWDNB - SER_SIOBN - SER_SIOBP-SER_SIOAN-SER_SIOAP + SER_CAPVDD to ppmu --delay 100us   
    disconnect digital pin SER_SIOBN - SER_SIOBP-SER_SIOAN-SER_SIOAP   from ppmu 

    wait(1ms)

    
-----Need check with DE that no need to bring Power down pins up for output leakage test       
--     -- power down pin go high
--     force_instr(SER_PWDNB,  "PPMU", "VOLTAGE", vio, 200uA,  -200uA,  200uA)      
--     wait (6ms)  -- need this for power up time complete
----------------------------------------------------    

----Can not measure leakage on X2 pins
    -- odd high
--    force_instr(SER_ODD_PINS ,   "PPMU", "VOLTAGE", vio, 200uA,  -200uA,   200uA)
    force_instr(SER_ODD_PINS - SER_PWDNB - CSI_Leakage_Odd,   "PPMU", "VOLTAGE", vio-0.5v , 200uA,  -200uA,   200uA) -----   slow increase glitch per Umut donot pull link over Vdd18
    force_instr(SER_ODD_PINS - SER_PWDNB - CSI_Leakage_Odd ,   "PPMU", "VOLTAGE", vio, 200uA,  -200uA,   200uA) -----per Umut donot pull link over Vdd18
    force_instr( CSI_Leakage_Odd ,   "PPMU", "VOLTAGE", 1.35v, 200uA,  -200uA,   200uA) -----max voltage of csi pin is 1.35

    -- even low
    force_instr(SER_EVEN_PINS - SER_X2_AUXSDA ,  "PPMU", "VOLTAGE", 0V, 200uA,  -200uA,  200uA) 
    if MPW5 then
        force_instr(SER_CKBN,   "PPMU", "VOLTAGE", vio, 200uA,  -200uA,   200uA)    -----MPW5 need phyb clk pair test at same voltage
    end_if


--    set hvvi chan SER_RSVD to fv vio max r5v
    connect hvvi chan SER_RSVD + SER_XRES remote
--    set hvvi chan SER_RSVD to fv 1.0V max r5v   ----- per Bill Leake RSVD only force to 1V
    set hvvi chan SER_RSVD to fv vio max r5v   ----- change to Vio 2.2019
    set hvvi chan SER_XRES to fv 0.0v max r5v   

    wait(5ms)


---Turn this on next silicon
--    meas_instr(leak_SE_odd_hi, SER_ODD_PINS -SER_PWDNB ,  "PPMU", "CURRENT", 100uA,  10, 10us) ---With current revision, CSI have problem high leakage
--    meas_instr(leak_SE_odd_hi, SER_ODD_PINS -SER_PWDNB  - SER_X1_AUXSCL - SER_SIOBP - SER_SIOAN,  "PPMU", "CURRENT", 10uA,  10, 10us) ---With current revision, CSI have problem high leakage
    temp = SER_ODD_PINS -SER_PWDNB - SER_X1_AUXSCL - SER_SIOBN - SER_SIOAN 
    meas_instr(leak_SE_odd_hi, temp ,  "PPMU", "CURRENT", 2uA,  10, 10us) ---With current revision, CSI have problem high leakage

    measure hvvi on chan SER_RSVD for 20 samples every 10us averaged into RSVD_HI  
---Seperate X1 from the pack
    meas_instr(leak_x1_hi,  SER_X1_AUXSCL,  "PPMU", "CURRENT", 400uA,  10, 10us)

   set hvvi chan SER_XRES irange to r5ua  iclamps percent to imax 90.0 imin 80.0  ----Set range to 5uA for more accurate
wait(5ms)     
--    meas_instr(leak_SE_even_lo, SER_EVEN_PINS ,  "PPMU", "CURRENT", 200uA,  10, 10us)         ---With current revision, CSI have problem high leakage

----No need X2 low


    
    temp = SER_EVEN_PINS - SER_X2_AUXSDA - SER_SIOBP - SER_SIOAP ---remove Sioa and siob pins from measurement
    meas_instr(leak_SE_even_lo, temp,  "PPMU", "CURRENT", 2uA,  10, 10us) ---remove Sioa and siob pins from measurement. per Umut 6/2018
--    meas_instr(leak_SE_even_lo, SER_EVEN_PINS - SER_X2_AUXSDA,  "PPMU", "CURRENT", 10uA,  10, 10us) ---With current revision, CSI have problem high leakage

wait(0ms)  


    measure hvvi on chan SER_XRES for 20 samples every 10us averaged into XRES_LO  

   
    -- odd low
    force_instr(SER_ODD_PINS-SER_PWDNB,   "PPMU", "VOLTAGE" ,0V, 2uA,  -2uA,   2uA)  ---glitch
    force_instr(SER_ODD_PINS-SER_PWDNB,   "PPMU", "VOLTAGE" ,0V, 20uA,  -20uA,   20uA)

    -- even high
     force_instr(SER_EVEN_PINS - SER_X2_AUXSDA -CSI_Leakage_Even,  "PPMU", "VOLTAGE", vio-0.5v, 20uA,  -20uA,  20uA)   ------ slowly increase prevent glitch mt 2/2019
    force_instr(SER_EVEN_PINS - SER_X2_AUXSDA -CSI_Leakage_Even,  "PPMU", "VOLTAGE" , vio, 20uA,  -20uA,  20uA)
    force_instr(CSI_Leakage_Even,  "PPMU", "VOLTAGE" , 1.35, 20uA,  -20uA,  20uA)  ---Max voltage for csi pin is 1.35
    if MPW5 then
        force_instr(SER_CKBP,   "PPMU", "VOLTAGE", 0.0v, 200uA,  -200uA,   200uA)    -----MPW5 need phyb clk pair test at same voltage
        force_instr(SER_CKBN,   "PPMU", "VOLTAGE", 0.0V, 200uA,  -200uA,   200uA)    -----MPW5 need phyb clk pair test at same voltage
    end_if

    set hvvi chan SER_XRES irange to r5ma  iclamps percent to imax 90.0 imin 80.0    ---Change range back to 5mA
    set hvvi chan SER_RSVD to fv 0.0 max r5v
    wait(1ms)

-- no need to measure x1 lo
    
    temp = SER_ODD_PINS -SER_PWDNB - SER_X1_AUXSCL - SER_SIOBN - SER_SIOAN     
    meas_instr(leak_SE_odd_lo, temp  ,  "PPMU", "CURRENT", 2uA,  10, 10us)  ---remove Sioa and siob pins from measurement. per Umut 6/2018
--    meas_instr(leak_SE_odd_lo, SER_ODD_PINS-SER_PWDNB -SER_X1_AUXSCL  ,  "PPMU", "CURRENT", 10uA,  10, 10us)  ---With current revision, CSI have problem high leakage

    measure hvvi on chan SER_RSVD for 20 samples every 10us averaged into RSVD_LO


----Turn this on for next silicon    
    temp = SER_EVEN_PINS - SER_X2_AUXSDA - SER_SIOBP - SER_SIOAP ---remove Sioa and siob pins from measurement
    meas_instr(leak_SE_even_hi, temp,  "PPMU", "CURRENT", 2uA,  10, 10us)  ---remove Sioa and siob pins from measurement. per Umut 6/2018
--    meas_instr(leak_SE_even_hi, SER_EVEN_PINS  - SER_X2_AUXSDA,  "PPMU", "CURRENT", 10uA,  10, 10us) ---With current revision, CSI have problem high leakage
---seperate x2 
   if MPW5 then
        force_instr(SER_CKBP,   "PPMU", "VOLTAGE", vio, 200uA,  -200uA,   200uA)    -----MPW5 need phyb clk pair test at same voltage
        force_instr(SER_CKBN,   "PPMU", "VOLTAGE", vio, 200uA,  -200uA,   200uA)    -----MPW5 need phyb clk pair test at same voltage
--        meas_instr(leak_SE_even_hi, SER_EVEN_PINS  - SER_X2_AUXSDA,  "PPMU", "CURRENT", 10uA,  10, 10us) ---With current revision, CSI have problem high leakage
        meas_instr(leak_SE_even_hi, temp,  "PPMU", "CURRENT", 10uA,  10, 10us) ---remove Sioa and siob pins from measurement. per Umut 6/2018

    end_if
  


    set hvvi chan SER_XRES to fv v18 max r5v
    wait(2ms)
    measure hvvi on chan SER_XRES for 50 samples every 10us averaged into XRES_HI  

 wait(0ms)

--    meas_instr(leak_pwd_hi,   SER_PWDNB,   "PPMU", "CURRENT", 200uA,  10, 10us)   
    
    -- power down pin go low now
    force_instr(SER_PWDNB,  "PPMU", "VOLTAGE", 0V, 20uA,  -20uA,  20uA)    
    wait(1ms)
    meas_instr(leak_pwd_lo,   SER_PWDNB,   "PPMU", "CURRENT", 20uA,  100, 10us)              
---Per Eric, we need to measure leakage on X2 and CapVdd. Discuss with Umut, capVdd measure with PDWNB low and for X1 from 0 to 1.9V max
    force_instr( SER_X2_AUXSDA + SER_X1_AUXSCL + SER_CAPVDD,  "PPMU", "VOLTAGE", 0V, 200uA,  -200uA,  200uA) 
    meas_instr(leak_x2_lo, SER_X2_AUXSDA ,  "PPMU", "CURRENT", 500uA,  10, 10us)
    meas_instr(leak_CapVdd_lo, SER_CAPVDD ,  "PPMU", "CURRENT", 2mA,  10, 10us)
 
 wait(1ms)
    force_instr( SER_X2_AUXSDA + SER_X1_AUXSCL,  "PPMU", "VOLTAGE", v18, 200uA,  -200uA,  200uA) 
    meas_instr(leak_x2_hi, SER_X2_AUXSDA ,  "PPMU", "CURRENT", 2ma,  10, 10us)
wait(1ms)



-----
----------force even pins to low before set power down hi prevent glitch
    force_instr(SER_EVEN_PINS - SER_X2_AUXSDA,  "PPMU", "VOLTAGE" , 0.3v, 2uA,  -2uA,  2uA)
    force_instr(SER_PWDNB,  "PPMU", "VOLTAGE", vio*0.9, 20uA,  -20uA,  20uA)    ---- deliglitch
    force_instr(SER_PWDNB,  "PPMU", "VOLTAGE", vio, 20uA,  -20uA,  20uA)    

    wait(1ms)
    meas_instr(leak_pwd_hi,   SER_PWDNB,   "PPMU", "CURRENT", 20uA,  10, 10us) 

    force_instr(SER_PWDNB,   "PPMU", "VOLTAGE" ,0V, 20uA,  -20uA,   20uA)   ---- deliglitch set power down low fist before other pins.
    force_instr(ALL_PATTERN_PINS - fpga_pattern_pins,   "PPMU", "VOLTAGE" ,0V, 20uA,  -20uA,   20uA)

    wait(1ms)

    disconnect digital pin ALL_PATTERN_PINS - fpga_pattern_pins from ppmu    
    connect digital pin ALL_PATTERN_PINS - fpga_pattern_pins to dcl
    --wait(3ms)
    
 -------     X1 and X2 always have 10Kpull up
    for idx = 1 to sites do
        site = active_sites[idx]
        x1_res[site]  =  vio/leak_x1_hi[site,1] 
--        x2_res[site]  =  vio/leak_x2_hi[site,1]
-----For now, remove leakage measurement on MIPI clock channel b
        if MPW5 then
            leak_SE_odd_hi[site,17]=1.999uA
            leak_SE_odd_lo[site,17]=1.999uA
            leak_SE_even_lo[site,18]=1.999uA
            leak_SE_even_hi[site,18]=1.999uA
        end_if
    end_for
------------ Power Down ---------------------------

  
  disconnect digital pin SER_ODD_PINS + SER_EVEN_PINS + SER_CAPVDD from ppmu --delay 100us   

  connect digital pin SER_ODD_PINS + SER_EVEN_PINS  - SER_CSI_PINS to dcl delay 100us



  set hvvi chan SER_RSVD + SER_XRES to fv 0v max r5v
  disconnect hvvi chan SER_RSVD+ SER_XRES

  set digital pin ALL_PATTERN_PINS - fpga_pattern_pins levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0.0V
  wait(200us)
  set hcovi SER_VDD + SER_VDD18 +SER_VDDIO  to fv 0.0V vmax 4V clamp imax 600mA imin -600mA
 	  
  wait(3ms)     -- extra for 47uF cap on SER_VDD  

  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)

  open cbit XRES1_RELAY+ X1X2_OSC_DP
  close cbit XRES_RELAY
  wait(3ms)                 
  
    test_value leak_SE_odd_hi  with SE_ODD_HI_LEAKAGE    
    test_value leak_SE_odd_lo  with SE_ODD_LO_LEAKAGE
    test_value leak_SE_even_hi  with SE_EVEN_HI_LEAKAGE    
    test_value leak_SE_even_lo  with SE_EVEN_LO_LEAKAGE
    test_value leak_pwd_hi  with PWDN_HI_LEAKAGE    
    test_value leak_pwd_lo  with PWDN_LO_LEAKAGE
    test_value RSVD_HI  with RSVD_HI_LKG    
    test_value RSVD_LO  with RSVD_LO_LKG
    test_value XRES_HI  with XRES_HI_LKG
    test_value XRES_LO  with  XRES_LO_LKG
    test_value x1_res   with X1_Res
    test_value leak_x2_lo   with X2Lo
    test_value leak_x2_hi   with X2Hi      
    test_value leak_CapVdd_lo   with CapVddLo

end_body

procedure Por(Vdd, Vddio, Vdd18, avdd, por_on, por_off,TestPins, SrchPass, SrchFail, CurLim,TestVltg,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
--  
in float          : TestVltg, SrchPass, SrchFail, CurLim
in float          : Vdd, Vddio, Vdd18, avdd
in_out float_test : por_on,por_off
in PIN LIST[5]    :TestPins
in boolean        : POWERUP,POWERDOWN

local

    multisite float   : icc[1]
    float             : vramp
    multisite float   : por1,por2

    multisite lword   : lowword, upperword
    word              : sites, idx, site
    integer           : idxs
    multisite integer : reg_val
    multisite float   : PorOn,PorOff, SupCur[1]
    float               :  Vconf0, Vconf1,min_val, max_val

end_local

body

  get_expr("OpVar_Char", CHAR)
  active_sites = get_active_sites
  sites = word(len(active_sites))
  csite = active_sites[1]
  min_val   = 100.0
  max_val   = -100.0
 --    --POWER_CONNECT    -- need this for reseting device
--     
--CHAR =false

    --make sure RSVD pin float (HVVI disconnect)
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
    connect digital pin ALL_PATTERN_PINS to dcl
    disconnect digital pin SER_CAPVDD from dcl                 -- need to float CAP_VDD pin  
    wait(3ms) 
        


-----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
   RegRead(SER_ID, 16#00, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device, to comply with check list
   wait(200us)
--     
--   for idxs = 1 to len(active_sites) do
--     site = active_sites[idxs]
--     reg_val[site]  = integer(lowword[site])        
--   end_for 
  
  ------------ crystal should running at 25MHz now ----------
 ----For This test only need pwdn/uart pins connect to dcl other pin should off 
 ---- because when searching level for VDDIO from low to high it mays turn on proctection diodes due to other pins have higher voltage setting
    disconnect digital pin ALL_PATTERN_PINS - SER_PWDNB - fpga_pattern_pins -DES_TX_RX -SER_GPO4_CFG0  - SER_GPO6_CFG2- SER_GPO5_CFG1 -SER_GPIO19_RXSDA -SER_GPIO20_TXSCL from dcl
  
  if CHAR then
--- POR turn on threshold search
--- POR threshold is found when AVDD supply current is greater than 5mA
    PorOff =  PorSearchHcovi(TestPins, SrchPass, SrchFail, CurLim, 2mV, "DOWN",Vddio) -- POR OFF threshold
    for idx = 1 to sites do
        site = active_sites[idx]                
        if min_val > PorOff[site] then
            min_val =  PorOff[site]        
        end_if
    end_for        
    
--    PorOn = PorSearchHcovi(TestPins, SrchFail, SrchPass, CurLim, 2mV, "UP",Vddio)   -- POR ON threshold
    PorOn = PorSearchHcovi(TestPins, min_val -10mV, SrchPass, CurLim, 2mV, "UP",Vddio)   -- POR ON threshold

 else    -- Go/NoGo
--    SetAp (TestPins, "v", SrchFail, 4V, "i", 300mA, 300mA, -300mA, 2ms)
--    SetAp (TestPins, "v", TestVltg, 4V, "i", 300mA, 300mA, -300mA, 20ms)
    if TestPins = SER_VDD then 
        set hcovi SER_VDD to fv SrchFail vmax 4V
        wait(1ms)
        set hcovi SER_VDD to fv TestVltg  vmax 4V
    elseif  TestPins = SER_VDDIO then 
        set digital pin  SER_PWDNB + SER_GPIO19_RXSDA + SER_GPIO20_TXSCL levels to vil 0V vih SrchFail -200mV  ---reducevih levwl
        set hcovi SER_VDDIO to fv SrchFail vmax 4V
        wait(1ms)
        set hcovi SER_VDDIO to fv TestVltg  vmax 4V    
        set digital pin  SER_PWDNB + SER_GPIO19_RXSDA + SER_GPIO20_TXSCL levels to vil 0V vih TestVltg -100mV  ---reducevih levwl
    else
        set hcovi SER_VDD18 to fv SrchFail vmax 4V
        wait(1ms)
        set hcovi SER_VDD18 to fv TestVltg  vmax 4V      
   end_if        
   
     wait(5ms) -- CKT:032719: To address invalid POR failures.     
  -------- Set PWDN =1 to power up DUT --------
        execute digital pattern "PowerUp" at label "TP" run to end wait
        wait(6ms) 

    wait(6ms)--wait(200us)
    if CurLim == 0.0 then --check if readable!
      RegRead(SER_ID, SR_REG0, 1, RdWordUpper, RdWordLower, "SER_UART_Read")    
--      RegRead(SER_ID, SR_REG0, 1, RdWordUpper, RdWordLower, "SER_I2C_Read")    

      for idx = 1 to sites do
          csite = active_sites[idx]
          if RdWordLower[csite] == 16#80 then
             PorOn[csite] = TestVltg
          else 
 --            PrintHexValue("POR ON FAIL: ", RdWordLower)
             PorOn[csite] = 0mV
          endif
      end_for
    else
      measure hcovi i on TestPins for 25 samples every 20us averaged into SupCur
       for idx = 1 to sites do
         csite = active_sites[idx]
         if  SupCur[csite, 1] > CurLim then
           PorOn[csite] = TestVltg
         else
           PorOn[csite] = 0mV
         endif
       end_for
    endif    
    end_if    

----Viet's code below
-- 
-- 
--   for vramp= 1.0 to 1.9 by 0.002 do
--     set hcovi SER_VDDA to fv vramp vmax 4V
--     wait(3ms)
--     measure hcovi i on SER_VDDA for 20 samples every 20us averaged into icc  
--     if  icc[test_site,1] > 0.005 then
--        break
--     end_if
--   end_for 
--   
--   por1 = vramp  -- store POR(on) threshold
--   
--   
-- --- POR turn off threshold search  
-- --- begin from turn on threshold plus 100mV
-- --- POR (off) threshold is found when AVDD supply current is less than 5mA
--           
--   for vramp= (por1[test_site]+0.1) downto 0.7 by 0.002 do
--     set hcovi SER_VDDA to fv vramp vmax 4V
--     wait(3ms)
--     measure hcovi i on SER_VDDA for 20 samples every 20us averaged into icc  
--     if icc[test_site,1] < 5.0e-3 then
--        break
--     end_if
--   end_for
-- 
--   por2 = vramp  -- store POR(off) threshold
--   
--   else    -- Go/NoGo
--     set hcovi SER_VDDA  to fv avdd-20mV vmax 4V clamp imax 600mA imin -600mA  
--     wait(1ms)
--     set hcovi SER_VDDA  to fv avdd vmax 4V clamp imax 600mA imin -600mA
--     wait(4.5ms)
--     measure hcovi i on SER_VDDA for 20 samples every 20us averaged into icc
--     
--     for idx = 1 to sites do
--         csite = active_sites[idx]
--         if icc[csite] > 5mA then
--            por1[csite] = avdd
--         else 
--            por1[csite] = 0mV
--         endif
--     end_for
--   endif  
  


-- Power Down 
  execute digital pattern "PowerUp" at label "ALL_ZERO" wait   -- Do not delete in order to reset all pins to vil level !!!   
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
  wait(200us)
  set hcovi SER_VDD + SER_VDD18 +  SER_VDDIO to fv 0V vmax 4V clamp imax 600mA imin -600mA
   connect digital pin ALL_PATTERN_PINS to dcl
  wait(10ms)     -- extra for 47uF cap on SER_VDD  

  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)

-- Datalog Results   
  test_value PorOn with por_on
  if CHAR then
     test_value PorOff with por_off
  endif  
 
end_body

procedure CFG_VIN(vcore, vio, v18, TestPins, CFGRegId, Cfgmax0Test, Cfgmax1Test,Cfgmin1Test, Cfgmax2Test,Cfgmin2Test, Cfgmax3Test,Cfgmin3Test, Cfgmax4Test,Cfgmin4Test, Cfgmax5Test,Cfgmin5Test, Cfgmax6Test,Cfgmin6Test, Cfgmax7Test,Cfgmin7Test, Cfgmax8Test,Cfgmin8Test, Cfgmax9Test,Cfgmin9Test, Cfgmax10Test,Cfgmin10Test, Cfgmax11Test,Cfgmin11Test, Cfgmax12Test,Cfgmin12Test, Cfgmax13Test,Cfgmin13Test, Cfgmax14Test,Cfgmin14Test, Cfgmax15Test,Cfgmin15Test,Vmax0,Vmax1,Vmin1,Vmax2,Vmin2,Vmax3,Vmin3,Vmax4,Vmin4,Vmax5,Vmin5,Vmax6,Vmin6,Vmax7,Vmin7,Vmax8,Vmin8 , Vmax9, Vmin9, Vmax10, Vmin10, Vmax11, Vmin11, Vmax12, Vmin12, Vmax13, Vmin13, Vmax14, Vmin14, Vmax15, Vmin15,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------

in float            : vcore, vio, v18
in PIN LIST[5]    : TestPins
in_out float_test : Cfgmax0Test, Cfgmax1Test,Cfgmin1Test, Cfgmax2Test,Cfgmin2Test, Cfgmax3Test,Cfgmin3Test, Cfgmax4Test,Cfgmin4Test, Cfgmax5Test,Cfgmin5Test, Cfgmax6Test,Cfgmin6Test, Cfgmax7Test,Cfgmin7Test, Cfgmax8Test,Cfgmin8Test
in_out float_test : Cfgmax9Test,Cfgmin9Test, Cfgmax10Test,Cfgmin10Test, Cfgmax11Test,Cfgmin11Test, Cfgmax12Test,Cfgmin12Test, Cfgmax13Test,Cfgmin13Test, Cfgmax14Test,Cfgmin14Test, Cfgmax15Test,Cfgmin15Test
in float          : Vmax0,Vmax1,Vmin1,Vmax2,Vmin2,Vmax3,Vmin3,Vmax4,Vmin4,Vmax5,Vmin5,Vmax6,Vmin6,Vmax7,Vmin7,Vmax8,Vmin8
in float          : Vmax9, Vmin9, Vmax10, Vmin10, Vmax11, Vmin11, Vmax12, Vmin12, Vmax13, Vmin13, Vmax14, Vmin14, Vmax15, Vmin15
in word           : CFGRegId
in boolean        : POWERUP,POWERDOWN


-- in_out array of float_test : MbistDone
-- in_out array of float_test : MbistPassFail


local

  
 
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword--, des_read0, des_read1, des_read2, reg_val20, reg_val21

  multisite integer : reg_val, reg_val0, reg_val1
  word              : sites, idx, site
  integer           : idxs

  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
 
     multisite float   : Cfgmax0,Cfgmin0, Cfgmax1,Cfgmin1, Cfgmax2,Cfgmin2, Cfgmax3,Cfgmin3, Cfgmax4,Cfgmin4, Cfgmax5,Cfgmin5, Cfgmax6,Cfgmin6, Cfgmax7,Cfgmin7, Cfgmax8,Cfgmin8
    multisite float   : Cfgmax9,Cfgmin9, Cfgmax10,Cfgmin10, Cfgmax11,Cfgmin11, Cfgmax12,Cfgmin12, Cfgmax13,Cfgmin13, Cfgmax14,Cfgmin14, Cfgmax15,Cfgmin15, Cfgmax16,Cfgmin16
    boolean           : CHAR
 end_local


body
  
    get_expr("OpVar_Char", CHAR)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    --make sure RSVD pin float (HVVI disconnect)
    CHAR = TRUE
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!

-----Dut power up function
   DutPowerUp(vio, v18, vcore, "UART", "TP_GMSL2",POWERUP)

 --   RegRead(SER_ID, 0x18, 1, upperword, lowword,"SER_UART_Read")
--     RegWrite(SER_ID, 0x18, 1, 0xE0, 0xe0, "SER_UART_Write") 
    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)
--    RegRead(SER_ID, 16#06, 1, upperword, lowword,"SER_UART_Read")   
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      reg_val[site]  = integer(lowword[site])        
    end_for 

-----Code from here
 RegRead(SER_ID, 0x0323, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
 
   enable digital ppmu TestPins fv 0V vmax 5V measure i max 2mA
  set digital ppmu TestPins  to fv 0V vmax 5V measure i max 2mA
  disconnect digital pin TestPins  from dcl
  connect digital ppmu TestPins to fv 0V vmax 5V measure i max 2mA
  if CHAR then
        Cfgmax0 = Cfg1Search(TestPins, 187mV , 255mV , 2mV, CFGRegId,0, "UP") 
        Cfgmax1 = Cfg1Search(TestPins, 255mV, 340mV , 2mV, CFGRegId,1, "UP")    
        Cfgmin1 = Cfg1Search(TestPins, 255mV, 187mV, 2mV, CFGRegId, 1, "DOWN")  
        Cfgmax2 = Cfg1Search(TestPins, 340mV, 425mV , 2mV, CFGRegId,2, "UP")    
        Cfgmin2 = Cfg1Search(TestPins, 340mV, 255mV, 2mV, CFGRegId, 2, "DOWN")  
        Cfgmax3 = Cfg1Search(TestPins, 425mV, 510mV , 2mV, CFGRegId,3, "UP")    
        Cfgmin3 = Cfg1Search(TestPins, 425mV, 340mV, 2mV, CFGRegId, 3, "DOWN")  
        Cfgmax4 = Cfg1Search(TestPins, 510mV, 595mV , 2mV,CFGRegId, 4, "UP")    
        Cfgmin4 = Cfg1Search(TestPins, 510mV, 425mV, 2mV,  CFGRegId,4, "DOWN")  
        Cfgmax5 = Cfg1Search(TestPins, 595mV, 680mV , 2mV, CFGRegId,5, "UP")    
        Cfgmin5 = Cfg1Search(TestPins, 595mV, 510mV, 2mV, CFGRegId, 5, "DOWN")  
        Cfgmax6 = Cfg1Search(TestPins, 680mV, 765mV , 2mV,CFGRegId, 6, "UP")    
        Cfgmin6 = Cfg1Search(TestPins, 680mV, 595mV, 2mV,  CFGRegId,6, "DOWN")  
        Cfgmax7 = Cfg1Search(TestPins, 765mV, 850mV , 2mV,CFGRegId, 7, "UP")    
        Cfgmin7 = Cfg1Search(TestPins, 765mV, 680mV, 2mV, CFGRegId, 7, "DOWN")  
        Cfgmax8 = Cfg1Search(TestPins, 850mV, 918mV , 2mV,CFGRegId, 8, "UP")    
        Cfgmin8 = Cfg1Search(TestPins, 850mV, 765mV, 2mV, CFGRegId, 8, "DOWN")  
        Cfgmax9 = Cfg1Search(TestPins, 918mV, 1V , 2mV,CFGRegId, 9, "UP")    
        Cfgmin9 = Cfg1Search(TestPins, 918mV, 850mV, 2mV, CFGRegId, 9, "DOWN")  
        Cfgmax10 = Cfg1Search(TestPins, 1V, 1.1V , 2mV, CFGRegId,10, "UP")    
        Cfgmin10 = Cfg1Search(TestPins, 1V, 0.9V, 2mV,  CFGRegId,10, "DOWN")  
        Cfgmax11 = Cfg1Search(TestPins, 1.0881V, 1.2V , 2mV,CFGRegId, 11, "UP")    
        Cfgmin11 = Cfg1Search(TestPins, 1.088V, 1V, 2mV,CFGRegId, 11, "DOWN")  
        Cfgmax12 = Cfg1Search(TestPins, 1.173V, 1.26V , 2mV,CFGRegId, 12, "UP")    
        Cfgmin12 = Cfg1Search(TestPins, 1.173V, 1.088V, 2mV,CFGRegId, 12, "DOWN")  
        Cfgmax13 = Cfg1Search(TestPins, 1.258V, 1.428 , 2mV, CFGRegId,13, "UP")    
        Cfgmin13 = Cfg1Search(TestPins, 1.258V, 1.173V, 2mV, CFGRegId,13, "DOWN")  
        Cfgmax14 = Cfg1Search(TestPins, 1.343V, 1.462V , 2mV,CFGRegId, 14, "UP")    
        Cfgmin14 = Cfg1Search(TestPins, 1.343V, 1.258V, 2mV, CFGRegId,14, "DOWN")  
        Cfgmax15 = Cfg1Search(TestPins, 1.428V, 1.6V , 2mV, CFGRegId,15, "UP")    
        Cfgmin15 = Cfg1Search(TestPins, 1.428V, 1.343V, 2mV,CFGRegId, 15, "DOWN")  
  else
        Cfgmax0 = CfgGoNoGo(TestPins, CFGRegId,Vmax0-15mV, 0)
        Cfgmax1 = CfgGoNoGo(TestPins, CFGRegId,Vmax1-15mV, 1)
        Cfgmin1 = CfgGoNoGo(TestPins, CFGRegId,Vmin1+15mV, 1)
        Cfgmax2 = CfgGoNoGo(TestPins, CFGRegId,Vmax2-15mV, 2)
        Cfgmin2 = CfgGoNoGo(TestPins, CFGRegId,Vmin2+15mV, 2)
        Cfgmax3 = CfgGoNoGo(TestPins, CFGRegId,Vmax3-15mV, 3)
        Cfgmin3 = CfgGoNoGo(TestPins, CFGRegId,Vmin3+15mV, 3)
        Cfgmax4 = CfgGoNoGo(TestPins, CFGRegId,Vmax4-15mV, 4)
        Cfgmin4 = CfgGoNoGo(TestPins, CFGRegId,Vmin4+15mV, 4)
        Cfgmax5 = CfgGoNoGo(TestPins, CFGRegId,Vmax5-15mV, 5)
        Cfgmin5 = CfgGoNoGo(TestPins, CFGRegId,Vmin5+15mV, 5)
        Cfgmax6 = CfgGoNoGo(TestPins, CFGRegId,Vmax6-15mV, 6)
        Cfgmin6 = CfgGoNoGo(TestPins, CFGRegId,Vmin6+15mV, 6)
        Cfgmax7 = CfgGoNoGo(TestPins, CFGRegId,Vmax7-15mV, 7)
        Cfgmin7 = CfgGoNoGo(TestPins, CFGRegId,Vmin7+15mV, 7)
        Cfgmax8 = CfgGoNoGo(TestPins, CFGRegId,Vmax8-15mV, 8)
        Cfgmin8 = CfgGoNoGo(TestPins, CFGRegId,Vmin8+15mV, 8)
        Cfgmax9 = CfgGoNoGo(TestPins, CFGRegId,Vmax9-15mV, 9)
        Cfgmin9 = CfgGoNoGo(TestPins, CFGRegId,Vmin9+15mV, 9)
        Cfgmax10 = CfgGoNoGo(TestPins, CFGRegId,Vmax10-15mV, 10)
        Cfgmin10 = CfgGoNoGo(TestPins, CFGRegId,Vmin10+15mV, 10)
        Cfgmax11 = CfgGoNoGo(TestPins, CFGRegId,Vmax11-15mV, 11)
        Cfgmin11 = CfgGoNoGo(TestPins, CFGRegId,Vmin11+15mV, 11)
        Cfgmax12 = CfgGoNoGo(TestPins, CFGRegId,Vmax12-15mV, 12)
        Cfgmin12 = CfgGoNoGo(TestPins, CFGRegId,Vmin12+15mV, 12)
        Cfgmax13 = CfgGoNoGo(TestPins, CFGRegId,Vmax13-15mV, 13)
        Cfgmin13 = CfgGoNoGo(TestPins, CFGRegId,Vmin13+15mV, 13)
        Cfgmax14 = CfgGoNoGo(TestPins, CFGRegId,Vmax14-15mV, 14)
        Cfgmin14 = CfgGoNoGo(TestPins, CFGRegId,Vmin14+15mV, 14)
        Cfgmax15 = CfgGoNoGo(TestPins, CFGRegId,Vmax15-15mV, 15)
        Cfgmin15 = CfgGoNoGo(TestPins, CFGRegId,Vmin15+15mV, 15)  


  end_if
 ---------------------------------------------

-------------- Power Down ---------------------------
   disconnect digital pin TestPins  from ppmu
   connect digital pin TestPins  to dcl
      powerdown_device(POWERDOWN)  


   -- Datalog Results   
      test_value Cfgmax0 with Cfgmax0Test  
      test_value Cfgmin1 with Cfgmin1Test
      test_value Cfgmax1 with Cfgmax1Test  
      test_value Cfgmin2 with Cfgmin2Test
      test_value Cfgmax2 with Cfgmax2Test  
      test_value Cfgmin3 with Cfgmin3Test
      test_value Cfgmax3 with Cfgmax3Test
      test_value Cfgmin4 with Cfgmin4Test
      test_value Cfgmax4 with Cfgmax4Test
      test_value Cfgmin5 with Cfgmin5Test
      test_value Cfgmax5 with Cfgmax5Test
      test_value Cfgmin6 with Cfgmin6Test
      test_value Cfgmax6 with Cfgmax6Test
      test_value Cfgmin7 with Cfgmin7Test
      test_value Cfgmax7 with Cfgmax7Test
      test_value Cfgmin8 with Cfgmin8Test
      test_value Cfgmax8 with Cfgmax8Test
      test_value Cfgmin9 with Cfgmin9Test
      test_value Cfgmax9 with Cfgmax9Test
      test_value Cfgmin10 with Cfgmin10Test
      test_value Cfgmax10 with Cfgmax10Test
      test_value Cfgmin11 with Cfgmin11Test
      test_value Cfgmax11 with Cfgmax11Test
      test_value Cfgmin12 with Cfgmin12Test
      test_value Cfgmax12 with Cfgmax12Test
      test_value Cfgmin13 with Cfgmin13Test
      test_value Cfgmax13 with Cfgmax13Test
      test_value Cfgmin14 with Cfgmin14Test
      test_value Cfgmax14 with Cfgmax14Test
      test_value Cfgmin15 with Cfgmin15Test
      test_value Cfgmax15 with Cfgmax15Test 
 end_body


procedure VilVih(Vdd18, Vdd, Vddio, TestPins, VilSrchTest, VihSrchTest,VilSrchI2CTest,VihSrchI2CTest, VilPatTest, VihPatTest, VilPatI2CTest, VihPatI2CTest, ForceVil, ForceVih, POWERUP,POWERDOWN)
--------------------------------------------------------------------------------------------------------------------------------------
 
in float             : Vdd18, Vdd, Vddio ---supplies
in float             : ForceVil, ForceVih
in PIN LIST[50]      : TestPins
in_out array of float_test    : VilSrchTest, VihSrchTest, VilPatTest, VihPatTest,VilSrchI2CTest,VihSrchI2CTest, VilPatI2CTest, VihPatI2CTest
in boolean          : POWERUP,POWERDOWN


local
multisite float   : PorOn,PorOff, SupCur[1], VilSrchRes[50], VihSrchRes[50]
boolean           : CHAR = False, VilDc = False, VihDc = False
multisite float   : VilPatCalc, VihPatCalc, VihI2C[2], VilI2C[2],VilPatCalcI2C, VihPatCalcI2C
multisite boolean : VilPatRes, VihPatRes
word              : CurSite
multisite word    : Status
multisite integer : LockState
multisite lword     :UpperRdWord, LowerRdWord
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword


end_local

body

  get_expr("OpVar_Char", CHAR)
  
  active_sites = get_active_sites
  sites = word(len(active_sites))

--CHAR = false
   disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!  
--    connect digital pin ALL_PATTERN_PINS to dcl
--  
--   -- reset levels
--   set digital pin ALL_PATTERN_PINS levels to vil 0V vih 0.2V vol 0V voh 0V iol 0mA ioh 0mA vref 0V
--   set digital pin ALL_PATTERN_PINS modes to driver pattern     -- Do not delete !!!
--   wait(1ms)
--   execute digital pattern "PowerUp" at label "ALL_ZERO" wait   -- Do not delete in order to reset all pins to vil level !!!
--     wait(1ms)        
-- -----The function below is for setting DUT supplies ONLY, change Voltage if Required  
--     Set_SER_Voltages(Vddio, Vdd, Vdd18)
--     wait (10ms) -- trial for 47uF cap on SER_VDD       
--     Vconf0 = 0.11 * Vddio
--     Vconf1 = 0.16 * Vddio
--         
--     set digital pin SER_GPO4_CFG0  + SER_GPO6_CFG2 levels to vil Vconf0 vih Vddio   -- TP/UART mode with DEV_ID = 0x80
--     set digital pin  SER_GPO5_CFG1 levels to vil Vconf1 vih Vddio                    ---GMSL2 mode 
--   
--     wait(1ms)
-- 
--         
--   -------- Set PWDN =1 to power up DUT --------
--     execute digital pattern "PowerUp" at label "TP" run to end wait
--     wait(6ms) 
     
--    DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL1",POWERUP) ---Set link to GMSL1
    DutPowerUp(Vddio, Vdd18, Vdd, "I2C", "TP_GMSL2",POWERUP) ---Set link to GMSL1

    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_I2C_Read")
--    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device, to comply with check list
    wait(200us)
     
--   SetTestMode(15, False, "SER_UART_Write")
 SetTestMode(15, False, "SER_I2C_Write")

   set digital pin SER_GPO4_CFG0  + SER_GPO5_CFG1 levels to vol 0.5*Vddio voh 0.5*Vddio iol 1mA ioh -1mA vref  Vddio
   set digital pin  SER_GPO4_CFG0  + SER_GPO5_CFG1  modes to comparator enable all fails

    if (CHAR) then ---This will take care all GPIO and PWDN pins. Need to work on SDA and SCL
        VilSrchRes = VilVihSearch(TestPins, Vddio*0.7, Vddio*0.2, "VIL","Vil_Vih" , "VihSrchStart")
        set digital pin TestPins levels to vil 0V vih Vddio  
        VihSrchRes = VilVihSearch(TestPins,Vddio*0.4, Vddio*0.9 , "VIH", "Vil_Vih", "VilStart") 
        set digital pin TestPins levels to vil 0V vih Vddio
--------Umut request to test Vil Vih for SDA and SCL 
        
        TestPins =  SER_GPIO19_RXSDA+SER_GPIO20_TXSCL---
        VihI2C = VilVihSearch_RXTX(TestPins,Vddio*0.9, Vddio*0.3 , "VIH",Vddio) 
        VilI2C = VilVihSearch_RXTX(TestPins,Vddio*0.3, Vddio*0.9 , "VIL",Vddio) 
    

    else----Go and no go test 
        set digital pin TestPins levels to vil ForceVil vih Vddio    
        execute digital pattern "Vil_Vih" at label "VilStart" into VilPatRes  

        set digital pin TestPins levels to vil 0V vih ForceVih   
        execute digital pattern "Vil_Vih" at label "VihStart" into VihPatRes  

        for idx = 1 to sites do
            CurSite = active_sites[idx]
            if VihPatRes[CurSite] then
                VihPatCalc = ForceVih                   ------0.001
 
            endif
            if VilPatRes[CurSite] then
                VilPatCalc = ForceVil                   -----+0.00001
            endif       
        endfor
----Go and no go for TX/RX pin 
        set digital pin SER_GPIO19_RXSDA+SER_GPIO20_TXSCL  levels to vil ForceVil vih  ForceVih
        RegWrite(SER_ID, SR_CTRL1, 1, 0, 16#05,"SER_I2C_Write" )
        wait(100us)
        RegRead(SER_ID, SR_CTRL1, 1, upperword, lowword,"SER_I2C_Read")
        for idx = 1 to sites do
            CurSite = active_sites[idx]
            if lowword[CurSite]=0x5 then
                VihPatCalcI2C = ForceVih                -----0.001
                VilPatCalcI2C = ForceVil                -----+0.00001
            endif

        endfor

    end_if 
 
 
 
   set digital pin ALL_PATTERN_PINS - fpga_pattern_pins levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
  wait(500us)
  
  
  set hcovi SER_VDD + SER_VDD18 to fv 0V vmax 4V clamp imax 600mA imin -600mA         
  set hcovi SER_VDDIO to fv 0V   vmax 4V clamp imax 600mA imin -600mA
  
 	  
  wait(10ms)     -- extra for 47uF cap on SER_VDD        

  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)
------    -- Datalog 
    if (CHAR) then
        test_value VilSrchRes with VilSrchTest
        test_value VihSrchRes with VihSrchTest
        test_value VilI2C with VilSrchI2CTest
        test_value VihI2C with VihSrchI2CTest

    else
        test_value VilPatCalc with VilPatTest
        test_value VihPatCalc with VihPatTest
        test_value VilPatCalcI2C with VilPatI2CTest
        test_value VihPatCalcI2C with VihPatI2CTest
    end_if     
end_body


procedure VolVoh(Vdd, Vdd18, Vddio, TestPins, ForceIol, ForceIoh, ForceIol2, ForceIoh2, VolMax, VolMax2, VohMin2mA, VohMin4mA, VolPat2mATest, VolPat4mATest,VohPat2mATest,VohPat4mATest, VolMeas2mATest, VolMeas4mATest,VohMeas2mATest,VohMeas4mATest,POWERUP,POWERDOWN) 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
in float            : Vdd, Vdd18, Vddio, ForceIol, ForceIoh, ForceIol2, ForceIoh2, VolMax, VolMax2, VohMin2mA, VohMin4mA
in PIN LIST[50]     : TestPins
in_out float_test   : VolPat2mATest, VolPat4mATest,VohPat2mATest,VohPat4mATest
in_out float_test   : VolMeas2mATest, VolMeas4mATest,VohMeas2mATest,VohMeas4mATest
in boolean          : POWERUP,POWERDOWN
local
  multisite float   : VohMeasRes2mA[30], VohMeasRes4mA[30],VolMeasRes2mA[30], VolMeasRes4mA[30]
  multisite boolean : VohPatRes2mA, VohPatRes4mA, VolPatRes2mA, VolPatRes4mA
  multisite float   : VohPatCalc2mA, VohPatCalc4mA, VolPatCalc2mA, VolPatCalc4mA
  boolean           : CHAR = False, VolDc2mA = False, VolDc4mA = False, VohDc2mA = False, VohDc4mA = False
  word              : CurSite
  multisite word    : Status
  multisite lword     :UpperRdWord, LowerRdWord
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword

end_local

body
  active_sites = get_active_sites
  sites = word(len(active_sites))

  get_expr("OpVar_Char", CHAR)
CHAR = true ---for debug  I prefer to measure output and see the value than run pattern MT 2/2019
  if CHAR then
    VolDc2mA = True
    VolDc4mA = True
    VohDc2mA = True
    VohDc4mA = True  

  endif
  VolPatCalc2mA = 0V
  VolPatCalc4mA = 0V
  VohPatCalc2mA = 0V
  VohPatCalc4mA = 0V
  
 
    --POWER_CONNECT    -- need this for reseting device
    --make sure RSVD pin float (HVVI disconnect)
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!

-----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
 
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device, to comply with check list
    wait(200us)

   SetTestMode(1, False, "SER_UART_Write")
  --RegRead(SER_ID,SR_TEST1 , 1, UpperRdWord, LowerRdWord, "SER_UART_Read")    

  
  set digital pin TestPins  modes to comparator enable all fails
  

--   --Iol=4mA
  set digital pin TestPins  levels to vol VolMax2 iol ForceIol2 vref Vddio/2.0
  execute digital pattern "Vol_Voh" at label "VolStart" into VolPatRes4mA  

  for idx = 1 to sites do
    CurSite = active_sites[idx]
    if not VolPatRes4mA[CurSite] then
      VolDc4mA = True
     else
       VolPatCalc4mA[CurSite] = VolMax2-0.000001
    endif
  end_for
  
  if VolDc4mA then
    set digital pin SER_PWDNB fx1 driver preset low  -- enable testing of I2C I/O in output mode
    enable digital ppmu TestPins fi 0A imax 10mA measure v max 2V
    connect digital ppmu TestPins to fi 0A imax 10mA measure v max 2v
    disconnect digital pin TestPins from dcl
--    set digital ppmu TestPins to fi ForceIol2 imax 10mA measure v max 2V clamps to vmin 0V vmax 4V
    set digital ppmu TestPins to fi ForceIol2 imax ForceIol2 measure v max 2V clamps to vmin 0V vmax 4V
    wait(1ms)
    measure digital ppmu TestPins voltage average 170 delay 10us into VolMeasRes4mA
    for idx = 1 to sites do
        CurSite = active_sites[idx] 
        VolMeasRes4mA[CurSite] = VolMeasRes4mA[CurSite] - 8mV
    end_for
    set digital ppmu TestPins to fi 0A imax 10mA measure v max 2V
    disconnect digital ppmu TestPins from fi
    disable digital ppmu TestPins fv 0V vmax 4v measure i max 2mA
    connect digital pin TestPins to dcl
    set digital pin SER_PWDNB fx1 driver preset high ------HERE
  endif
  
  
  --VOH


  set digital pin  SER_GPIO20_TXSCL + SER_GPIO19_RXSDA levels to vil 0V vih Vddio  vol Vddio*0.5 voh 0.5*Vddio iol 2mA ioh -2mA vref Vddio
  SetTestMode(2, false, "SER_UART_Write")----- Set to false has smaller glitch at 3.6V and shorter duration MT

   set digital pin TestPins  modes to comparator enable all fails
--  set digital pin TestPins -SER_GPO_PINS  modes to comparator enable all fails
  

  
  
   --Ioh= -4mA
  set digital pin TestPins  levels to voh VohMin4mA ioh ForceIoh2 vref Vddio/2.0
  wait(2ms)
  execute digital pattern "Vol_Voh" at label "VohStart" into VohPatRes4mA  

  for idx = 1 to sites do
    CurSite = active_sites[idx]
    if not VohPatRes4mA[CurSite] then
      VohDc4mA = True
     else
       VohPatCalc4mA[CurSite] = VohMin4mA+0.000001
    endif
  end_for
  --with ioh =-8mA, Voh of some pins are ~3.1V, suppose to be vddio-0.4V =3.2V, change limit to 3.1V for now.   
  if VohDc4mA then
  --   enable digital ppmu TestPins -SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL -SER_GPO_PINS fi 0A imax 10mA measure v max 2V
--     connect digital ppmu TestPins -SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL -SER_GPO_PINS to fi 0A imax 10mA measure v max 4v
--     disconnect digital pin TestPins-SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL -SER_GPO_PINS from dcl
--     set digital ppmu TestPins-SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL -SER_GPO_PINS to fi ForceIoh2 imax 10mA measure v max 4V clamps to vmin 0V vmax 4V
--     measure digital ppmu TestPins -SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL -SER_GPO_PINS voltage average 5 delay 10us into VohMeasRes4mA
--     set digital ppmu TestPins-SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL -SER_GPO_PINS to fi 0A imax 10mA measure v max 2V
--     disconnect digital ppmu TestPins from fi
--     disable digital ppmu TestPins fv 0V vmax 4v measure i max 2mA
--     connect digital pin TestPins to dcl

    enable digital ppmu TestPins -SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL fi 0A imax 10mA measure v max 2V
    connect digital ppmu TestPins -SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL to fi 0A imax 10mA measure v max 4v
    disconnect digital pin TestPins-SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL from dcl

    set digital ppmu TestPins-SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL to fi ForceIoh2 imax ForceIoh2 measure v max 4V clamps to vmin 0V vmax 4V

     measure digital ppmu TestPins -SER_PWDNB  voltage average 5 delay 10us into VohMeasRes4mA
    measure digital ppmu TestPins -SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL voltage average 5 delay 10us into VohMeasRes4mA
    set digital ppmu TestPins-SER_PWDNB - SER_GPIO19_RXSDA -SER_GPIO20_TXSCL to fi 0A imax 10mA measure v max 2V



    disconnect digital ppmu TestPins from fi
    disable digital ppmu TestPins fv 0V vmax 4v measure i max 2mA
    connect digital pin TestPins to dcl
----Add offset 4mA * 2ohm trace and ltx relay on resistance
    for idx = 1 to sites do
        CurSite = active_sites[idx] 
        VohMeasRes4mA[CurSite] = VohMeasRes4mA[CurSite] +  8mV
    end_for

  endif
 
  
-- 
--   set digital pin dut_i2c_pins levels to vref Vddio
--   set digital pin TestPins levels to iol 0A ioh 0A

  connect digital pin TestPins to dcl
 

--  DutPowerDown
-------------- Power Down ---------------------------
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
  wait(500us)
  powerdown_device(POWERDOWN) 



  -- Datalog VOL and VOH Tests

--   if VolDc2mA then
--     test_value VolMeasRes2mA with VolMeas2mATest  
--   else
--     test_value VolPatCalc2mA with VolPat2mATest
--   endif
  if VolDc4mA then  
     test_value VolMeasRes4mA with VolMeas4mATest  
  else
    test_value VolPatCalc4mA with VolPat4mATest
  endif

--   if VohDc2mA then
--     test_value VohMeasRes2mA with VohMeas2mATest  
--   else
--     test_value VohPatCalc2mA with VohPat2mATest
--   endif
  if VohDc4mA then
    test_value VohMeasRes4mA with VohMeas4mATest  
  else
    test_value VohPatCalc4mA with VohPat4mATest
  endif

end_body

procedure X1_X2_Tests(Vdd18, Vdd, Vddio, X2Vlow_test, X2Vhigh_test, X1Vil_test, X1Vih_test,X1Vil_FT,X1Vih_FT, X1VIHFT,X1VILFT, POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
in float               : Vdd, Vdd18, Vddio,X1Vil_FT,X1Vih_FT
in_out float_test      : X2Vlow_test, X2Vhigh_test, X1Vil_test, X1Vih_test, X1VIHFT,X1VILFT
in boolean             : POWERUP,POWERDOWN
local
  multisite float  :  ResVal[1], X2VohMeas[1], X2VolMeas[1], X2CurLMeas[1], X2CurHMeas[1], X2VohSiteVltg, X1VilVltg, X1VihVltg, TestMeas[1]
  multisite float  :  X1VilMeas[1], X1VihMeas[1], X1CurLMeas[1], X1CurHMeas[1]
  word             :  Cs, LpIdx, TmpSiteCnt,idx,sites,site
  boolean          :  CHAR
  float            :  VltgStep, VihStart = 900mV, VilStart=400mV
   float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword
  multisite float  : X1_VIL_FT[1], X1_VIH_FT[1],X2_MEAS[1]
  word list[MAX_SITES]   : active_sites 
end_local

body
  active_sites = get_active_sites()
  sites = word(len(active_sites))

  get_expr("OpVar_Char", CHAR)

  if  CHAR then
    VltgStep = 2mV
  else
    VltgStep = 100mV   
  endif



   disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!  

 
  -- reset levels
--   set digital pin ALL_PATTERN_PINS levels to vil 0V vih 0.2V vol 0V voh 0V iol 0mA ioh 0mA vref 0V
--   set digital pin ALL_PATTERN_PINS modes to driver pattern     -- Do not delete !!!
--   wait(1ms)
--   execute digital pattern "PowerUp" at label "ALL_ZERO" wait   -- Do not delete in order to reset all pins to vil level !!!
--     wait(1ms)        
-- -----The function below is for setting DUT supplies ONLY, change Voltage if Required  
--     Set_SER_Voltages(Vddio, Vdd, Vdd18)
--     wait (10ms) -- trial for 47uF cap on SER_VDD       
--     Vconf0 = 0.11 * Vddio
--     Vconf1 = 0.16 * Vddio
--         
--     set digital pin SER_GPO4_CFG0  + SER_GPO6_CFG2 levels to vil Vconf0 vih Vddio   -- TP/UART mode with DEV_ID = 0x80
--     set digital pin  SER_GPO5_CFG1 levels to vil Vconf1 vih Vddio                    ---GMSL2 mode 
--   
--     wait(1ms)
-- 
--         
--   -------- Set PWDN =1 to power up DUT --------
--     execute digital pattern "PowerUp" at label "TP" run to end wait
--     wait(6ms) 
     
    DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)   

    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device, to comply with check list
    wait(200us)
 
  close cbit X1X2_OSC_DP
 
  enable digital ppmu SER_X1_AUXSCL fv 0V vmax 5V measure i max 2mA
  set digital ppmu  SER_X1_AUXSCL to fv 0V  vmax 5V measure i max 2mA
  connect digital ppmu SER_X1_AUXSCL to fv 0V  vmax 5V measure i max 2mA

  enable digital ppmu SER_X2_AUXSDA fi 0mA imax 20mA measure v max 5V
  set digital ppmu  SER_X2_AUXSDA  to fi 0mA imax 20mA measure v max 5V
  disconnect digital pin  SER_X2_AUXSDA + SER_X1_AUXSCL  from dcl
  connect digital ppmu  SER_X2_AUXSDA  to fi 0mA imax 20mA measure v max 5V
 
  wait(2ms)
  --meas X2 Voh

  measure digital ppmu  SER_X2_AUXSDA voltage vmax 5V average 5 into X2VohMeas
 

   set digital ppmu  SER_X1_AUXSCL to fv Vdd18
   wait(1ms)
   measure digital ppmu  SER_X2_AUXSDA  voltage vmax 5V average 5 into X2VolMeas
  -- Test Vil for X1_OSC
    if  CHAR then
        current_active_sites = get_active_sites()
        TmpSiteCnt = word(len(current_active_sites))
        LpIdx = 0
        while TmpSiteCnt > 0 do
            LpIdx = LpIdx + 1
            set digital ppmu SER_X1_AUXSCL to fv (VilStart + (float(LpIdx)*VltgStep)) vmax 2V 
            wait(1ms)
            measure digital ppmu   SER_X2_AUXSDA voltage vmax 2V average 5 into TestMeas

            for idx = 1 to TmpSiteCnt do
                Cs = current_active_sites[idx]
            
                if TestMeas[Cs, 1] <Vdd/2.0 then
                    X1VilVltg[Cs] = (VilStart + (float(LpIdx-1)*VltgStep))
                    deactivate site Cs
                endif
            endfor
            current_active_sites = get_active_sites()
            TmpSiteCnt = word(len(current_active_sites))
        endwhile
        activate site active_sites

------ Test Vih for X1_OSC
        current_active_sites = get_active_sites()
        TmpSiteCnt = word(len(current_active_sites))
        LpIdx = 0
        while TmpSiteCnt > 0 do
            LpIdx = LpIdx + 1
            set digital ppmu  SER_X1_AUXSCL to fv (VihStart - (float(LpIdx)*VltgStep))
            wait(1ms)
    
            measure digital ppmu  SER_X2_AUXSDA voltage vmax 2V average 10 into TestMeas
            for idx = 1 to TmpSiteCnt do
                Cs = current_active_sites[idx]
                if TestMeas[Cs, 1] > Vdd*0.5 then
                    X1VihVltg[Cs] = (VihStart - (float(LpIdx-1)*VltgStep))
                    deactivate site Cs
                endif
            endfor
            current_active_sites = get_active_sites()
            TmpSiteCnt = word(len(current_active_sites))
         endwhile
        activate site active_sites
  
 --------    
     else --- measure with go and no go value
-------Measure X1 VIL         
         set digital ppmu SER_X1_AUXSCL to fv  X1Vil_FT 
         wait(1ms)----
         measure digital ppmu   SER_X2_AUXSDA voltage vmax 2V average 5 into X2_MEAS ---Expect high at X2
         for idx = 1 to sites do ---prepare for datalog
             site = active_sites[idx]
             if X2_MEAS [site] > Vdd18/2.0 then           ---part passed; next revision need to change vdd to vdd18------Vdd/2.0 
                X1_VIL_FT[site] = X1Vil_FT ---part passed
             else 
                X1_VIL_FT[site] =0.0 ---fail the part
             end_if   
         end_for  
----Test Vih go/no go test
         set digital ppmu SER_X1_AUXSCL to fv  X1Vih_FT 
         wait(1ms)----
         measure digital ppmu   SER_X2_AUXSDA voltage vmax 2V average 5 into X2_MEAS ---Expect low at X2
         for idx = 1 to sites do ---prepare for datalog
             site = active_sites[idx]
             if X2_MEAS [site] < Vdd18/2.0 then ---part passed; next revision need to change vdd to vdd18
                X1_VIH_FT[site] = X1Vih_FT ---part passed
             else 
                X1_VIH_FT[site] =0.0 ---fail the part
             end_if   
        end_for
     end_if 
  disable digital ppmu  SER_X1_AUXSCL + SER_X2_AUXSDA  fv
  disconnect digital pin  SER_X1_AUXSCL + SER_X2_AUXSDA  from ppmu
    connect digital pin  SER_X1_AUXSCL + SER_X2_AUXSDA  to dcl
--  DutPowerDown
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
  wait(500us)
  
  
  set hcovi SER_VDD + SER_VDD18 to fv 0V vmax 4V clamp imax 600mA imin -600mA         
  set hcovi SER_VDDIO to fv 0V   vmax 4V clamp imax 600mA imin -600mA
  
 	  
  wait(10ms)     -- extra for 47uF cap on SER_VDD        

  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)
  for idx = 1 to sites do
    Cs = active_sites[idx]
    ResVal[Cs, 1] = abs(Vddio / X1CurHMeas[Cs, 1])
  endfor      
  open cbit X1X2_OSC_DP
 ----Data log 
  test_value X2VolMeas with X2Vlow_test
  test_value X2VohMeas with X2Vhigh_test
  if CHAR then
    test_value X1VilVltg with X1Vil_test
    test_value X1VihVltg with X1Vih_test
  else
    test_value X1_VIL_FT with X1VILFT
    test_value X1_VIH_FT with  X1VIHFT
  end_if   
end_body

procedure LMN_Vih_Vil_Dynamic(Vdd18, Vddio, Vdd, Ignd_ft, Vopen_ft, float_char_tests,  gng_threshold_tests,RDRIFI,RDRIFTREG, RDRIFI_NEW, RDRIFTREG_NEW, POWERUP,POWERDOWN,LMN02SHRTBATT,LMN02OpMin,LMN02OpMax,LMN02NMMin,LMN02NMMax,LMN02ShrtGnd,LMN13SHRTBATT,LMN13OpMin,LMN13OpMax,LMN13NMMin,LMN13NMMax,LMN13ShrtGnd,LMN13LineShrtLineMin,LMN13LineShrtLineMax,Normalize)

--  
in float            :  Vdd18, Vddio, Vdd
in float            : LMN02SHRTBATT,LMN02OpMin,LMN02OpMax,LMN02NMMin,LMN02NMMax,LMN02ShrtGnd
in float            : LMN13SHRTBATT,LMN13OpMin,LMN13OpMax,LMN13NMMin,LMN13NMMax,LMN13ShrtGnd,LMN13LineShrtLineMin,LMN13LineShrtLineMax
in_out array of float_test   : Ignd_ft, Vopen_ft, RDRIFI, RDRIFI_NEW --,Threshold
-- in_out integer_test : Iopen01_ft_min, Iopen01_ft_max,Iopen23_ft_min,Iopen23_ft_max, Inormal01_ft_min, Inormal01_ft_max, Inormal23_ft_min, Inormal23_ft_max
-- in_out integer_test : Ilinetoline23_ft_min, Ilinetoline23_ft_max, Ishorttognd01_ft, Ishorttognd23_ft, Ishorttobat01_ft, Ishorttobat23_ft

in_out array of integer_test : gng_threshold_tests,RDRIFTREG, RDRIFTREG_NEW
in_out array of float_test   :float_char_tests, Normalize

-- in_out float_test   : ISHBAT_0,ISHBAT_2,Inm_min_0,Inm_min_2,Inm_max_0,Inm_max_2,Ishrtgnd_0,Ishrtgnd_2
-- in_out float_test   : ISHBAT_1,ISHBAT_3,Inm_min_1,Inm_min_3,Inm_max_1,Inm_max_3,Ishrtgnd_1,Ishrtgnd_3
-- in_out float_test   : Iop_min_0,Iop_min_2,Iop_max_0,Iop_max_2
-- in_out float_test   : Iop_min_1,Iop_min_3,Iop_max_1,Iop_max_3
in boolean          : POWERUP,POWERDOWN
--in_out float_test   : Iline_min_1,Iline_min_3,Iline_max_1,Iline_max_3


local
    word list[16]     : active_sites
    word              : sites, idx, site
    boolean           : CHAR

    multisite float   : Isg[4], Vopen[4], Isg02[2], Isg13[2]
    multisite float   :lmn0_nm_min, lmn2_nm_min,lmn0_nm_max,lmn2_nm_max
    multisite float   :lmn0_line_min, lmn2_line_min,lmn0_line_max,lmn2_line_max  
    multisite float   :lmn0_shortgnd, lmn2_shortgnd
    multisite float   :lmn0_shortbat, lmn2_shortbat,lmn1_shortbat, lmn3_shortbat
    multisite float   :lmn1_nm_min, lmn3_nm_min,lmn1_nm_max,lmn3_nm_max
    multisite float   :lmn1_line_min, lmn3_line_min,lmn1_line_max,lmn3_line_max
    multisite float   :lmn1_shortgnd, lmn3_shortgnd
    multisite float   :lmn0_op_min, lmn2_op_min,lmn0_op_max,lmn2_op_max
    multisite float   :lmn1_op_min, lmn3_op_min,lmn1_op_max,lmn3_op_max
--    multisite lword   : word1_26, word1_27,word2_26,word2_27, word3_26, word3_27, word4_26, word4_27, word5_26, word5_27, word6_26, word6_27
    multisite lword   : LineShrtBatt1,LineOp_min1,LineOp_Max1,LineShrtGnd1,LineNmMin1,LineNmMax1,LineShrtBatt2,LineOp_min2,LineOp_Max2,LineShrtGnd2,LineNmMin2,LineNmMax2,LineShrtLineMin2,LineShrtLineMax2
    multisite lword   :LineShrtLineMin1,LineShrtLineMax1
    float             : Vconf0, Vconf1
    multisite lword   : lowword, upperword
    multisite float   : my_float, datalog_threshold[14]
    multisite float   :  lmn1_shortgndNormalize, lmn3_shortgndNormalize ,  lmn0_shortgndNormalize, lmn2_shortgndNormalize
    multisite integer : temp_integer
    multisite integer : threshold_registers[14],RDrift_3pc_Reg[8], RDrift_3pc_Reg_new[8]
    multisite float   :    float_char_measurements[38], float_normalize[20]-----8
    multisite float   : Isg0, Isg2,Isg1,Isg3
              float    : GB02_Shrgnd, GB13_Shrgnd
--    multisite float   :  lmn1_nm_3pc_off, lmn3_nm_3pc_off ,  lmn0_nm_3pc_off, lmn2__nm_3pc_off
    string[5]              : LimitsCategory
    multisite float   : Ifn0_min, Ifn0_max, Ifn1_min, Ifn1_max, Iflls1_min, Iflls1_max, RDRIFT_nonspec_currents[12], RDRIFT_nonspec_currents_new[12]
    multisite float   : Ifn2_min, Ifn2_max, Ifn3_min, Ifn3_max, Iflls3_min, Iflls3_max    
    float             : GBnm02, GBnm13, GBll_13
    multisite lword   : Normal_3pc_02_Min,Normal_3pc_02_Max, Normal_3pc_13_Min,Normal_3pc_13_Max
    multisite lword   : Line2line_3pc_01_Min,Line2line_3pc_01_Max, Line2line_3pc_23_Min,Line2line_3pc_23_Max   
    multisite float   : lmn0_shortgndNormalize3, lmn2_shortgndNormalize3,lmn1_shortgndNormalize1p5, lmn3_shortgndNormalize1p5
    multisite float   : lmn1_shortgndNormalize3, lmn3_shortgndNormalize3, lmn1_shortgndNormalize5, lmn3_shortgndNormalize5
    multisite float   : lmn0_normalized_open_to_normal,lmn2_normalized_open_to_normal,lmn0_normalized_normal_to_open,lmn2_normalized_normal_to_open
    multisite float   : lmn1_normalized_open_to_line2line_short,lmn3_normalized_open_to_line2line_short,lmn1_normalized_line2line_short_to_open,lmn3_normalized_line2line_short_to_open
    multisite float   : lmn1_normalize_line2line_short_to_normal,lmn3_normalize_line2line_short_to_normal,lmn1_normalize_normal_to_l2l_short,lmn3_normalize_normal_to_l2l_short
    multisite float   : LMN0OpMax,LMN2OpMax, LMN1OpMax,LMN3OpMax
    multisite float   : LMN0NMMax,LMN2NMMax, LMN1NMMax,LMN3NMMax
    multisite float   : LMN0NMMin,LMN2NMMin, LMN1NMMin,LMN3NMMin
    multisite float   : LMN0ShrtGnd,  LMN2ShrtGnd,LMN1ShrtGnd,  LMN3ShrtGnd
    multisite float   : LMN1LineShrtLineMin,LMN3LineShrtLineMin, LMN1LineShrtLineMax,LMN3LineShrtLineMax

    multisite float   : Ifn0_min_new, Ifn0_max_new, Ifn1_min_new, Ifn1_max_new, Iflls1_min_new, Iflls1_max_new
    multisite float   : Ifn2_min_new, Ifn2_max_new, Ifn3_min_new, Ifn3_max_new, Iflls3_min_new, Iflls3_max_new 
    multisite lword   : Line2line_3pc_01_Min_new, Line2line_3pc_01_Max_new, Line2line_3pc_23_Min_new, Line2line_3pc_23_Max_new
    multisite lword   : Normal_3pc_02_Min_new, Normal_3pc_02_Max_new, Normal_3pc_13_Min_new, Normal_3pc_13_Max_new
     string[8]       : response
end_local

body
    get_expr("OpVar_Char", CHAR)
--   CHAR =  true
    get_expr("OpVar_LimitsCategory", LimitsCategory)
    if LimitsCategory == "0" OR LimitsCategory == "2" OR LimitsCategory == "4" then  -- QA insertion
        GB02_Shrgnd = 0.0ua
        GB13_Shrgnd = 0.0ua 
        GBnm02      = 0.0uA
        GBnm13      = 0.0uA
        GBll_13     = 0.0uA
    else
        GB02_Shrgnd = 0.2ua   ----for now later on use the normalize after char.
        GB13_Shrgnd = 0.1ua   ----for now
        GBnm02      = 0.1uA
        GBnm13      = 0.1uA
        GBll_13     = 25nA
    end_if            
  active_sites = get_active_sites
  sites = word(len(active_sites))


   disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!  

  
    if gLMN_PMU_CAL_FAIL then
        println(stdout, ">>@t@t@t LMN_PMU_CAL_FAIL!<<")
        println(stdout, ">>@tCheck DigitalPin PPMU calibration on ONLOAD function<<")
        println(stdout, ">>@tDo not Continue testing. Call Engineer <<")       
        Print_banner_message(" @tLMN_PMU_CAL_FAIL!","@tDo not Continue testing. Call Engineer","Press 'Enter' to Continue")
       input(stdin, response!L)
    end_if
    DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device, to comply with check list
    wait(200us)
 
     enable digital ppmu SER_LMN_PINS fv 0V vmax 5V measure i max 2mA
     set digital ppmu SER_LMN_PINS   to fv 0V vmax 1V measure i max 50uA
     disconnect digital pin  SER_LMN_PINS  from dcl
     connect digital pin  SER_LMN_PINS  to ppmu
     connect digital ppmu SER_GPIO13_LMN0 + SER_GPIO15_LMN2_SS2_RO  to fv 0V vmax 1V measure i max 50uA 
     connect digital ppmu SER_GPIO14_LMN1 + SER_GPIO16_LMN3_SS1_BNE  to fv 0V vmax 1V measure i max 20uA
 
   --Power up Line Fault dectecto on LMN0/1/2/3
   RegWrite(SER_ID, SR_REG5, 1, 0, 16#0F, "SER_UART_Write")
   RegRead(SER_ID, SR_REG5, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
   
   --meas open current
--   measure digital ppmu SER_LMN_PINS  current imax 50uA average 17 parallel into Iopen
   measure digital ppmu SER_GPIO13_LMN0 + SER_GPIO15_LMN2_SS2_RO  current imax 50uA average 20 parallel into Isg02
   measure digital ppmu SER_GPIO14_LMN1 + SER_GPIO16_LMN3_SS1_BNE current imax 20uA average 20 parallel into Isg13
    for idx = 1 to sites do
        site = active_sites[idx]
        Isg[site,1] = Isg02[site,1]
        Isg[site,2] = Isg13[site,1]
        Isg[site,3] = Isg02[site,2]
        Isg[site,4] = Isg13[site,2]
        Isg0[site]  = Isg02[site,1]     ----ShortGND LMN0
        Isg2[site]  = Isg02[site,2]     ----ShortGND LMN2
        Isg1[site]  = Isg13[site,1]     ----ShortGND LMN1
        Isg3[site]  = Isg13[site,2]     ----ShortGND LMN3
    end_for

   disconnect digital ppmu  SER_LMN_PINS  from fv 0V 
   --meas open volt   
   connect digital ppmu  SER_LMN_PINS to fi 0.01uA imax 1uA measure v max 2V
   measure digital ppmu  SER_LMN_PINS voltage vmax 2V average 17 into Vopen

  if CHAR then
        --Short to Batt to Open

        lmn0_shortbat =  Lmn_Search_mod1(SER_GPIO13_LMN0, 15uA, 25uA, 0.01uA, SR_REG26, 0x0, "UP",0)   ---- search from open to short battery
        lmn2_shortbat=  Lmn_Search_mod1(SER_GPIO15_LMN2_SS2_RO, 15uA, 25uA, 0.01uA, SR_REG27, 0x0, "UP",2)---- search from open to short battery        

-------Search for open range min and max
        ----Search from short battery to open min
        lmn0_op_min = Lmn_Search_mod1(SER_GPIO13_LMN0, 25uA, 15uA, 0.01uA, SR_REG26, 0x3, "DOWN",0)   
        lmn2_op_min = Lmn_Search_mod1(SER_GPIO15_LMN2_SS2_RO, 25uA, 15uA, 0.01uA, SR_REG27, 0x3, "DOWN",2)

        ----Search from normal to open max
        lmn0_op_max = Lmn_Search_mod1(SER_GPIO13_LMN0, -9.5uA, -6.5uA, 0.01uA, SR_REG26, 0x3, "UP",0)   
        lmn2_op_max = Lmn_Search_mod1(SER_GPIO15_LMN2_SS2_RO, -9.5uA, -6.5uA, 0.2uA, SR_REG27, 0x3, "UP",2)



        --Open to Normal threshold search min
        lmn0_nm_min = Lmn_Search_mod1(SER_GPIO13_LMN0, -6uA, -15uA, 0.01uA, SR_REG26, 0x2, "DOWN",0)         
        lmn2_nm_min = Lmn_Search_mod1(SER_GPIO15_LMN2_SS2_RO, -6uA, -15uA, 0.01uA, SR_REG27, 0x2, "DOWN",2)  
     
        --Short GND to Normal threshold search max( search upper value of Normal)
        lmn0_nm_max = Lmn_Search_mod1(SER_GPIO13_LMN0, -22uA, -14uA, 0.01uA, SR_REG26, 0x2, "UP",0)  
        lmn2_nm_max = Lmn_Search_mod1(SER_GPIO15_LMN2_SS2_RO, -22uA, -14uA, 0.01uA, SR_REG27, 0x2, "UP",2)   
 

-------Normal to line to line threshold no longer in spec MT 1/2018

--         lmn0_line_min = Lmn_Search_mod(SER_GPIO13_LMN0, -10uA, -20uA, 0.2uA, SR_REG26, 0x4, "DOWN",0) 
--         lmn2_line_min = Lmn_Search_mod(SER_GPIO15_LMN2_SS2_RO, -10uA, -20uA, 0.2uA, SR_REG27, 0x4, "DOWN",2)  
-- 
-- -------ShortGND to line  threshold  search for line threshold max value   
--         lmn0_line_max = Lmn_Search_mod(SER_GPIO13_LMN0, -16uA, -20uA, 0.2uA, SR_REG26, 0x4, "UP",0) 
--         lmn2_line_max = Lmn_Search_mod(SER_GPIO15_LMN2_SS2_RO, -25uA, -10uA, 0.2uA, SR_REG27, 0x4, "UP",2)     
---------------------- to here

 -----Search for Short gnd threshold from Normal note: 
 
        lmn0_shortgnd = Lmn_Search_mod1(SER_GPIO13_LMN0, -14uA, -30uA, 0.01uA, SR_REG26, 0x1, "DOWN",0) 
        lmn2_shortgnd = Lmn_Search_mod1(SER_GPIO15_LMN2_SS2_RO, -14uA, -30uA, 0.01uA, SR_REG27, 0x1, "DOWN",2)  
----Normalize to IshortGnd
        for idx = 1 to sites do
            site = active_sites[idx]
            lmn0_shortgndNormalize[site] = lmn0_shortgnd[site] - Isg[site,1]
            lmn2_shortgndNormalize[site] = lmn2_shortgnd[site] - Isg[site,3]
            lmn0_shortgndNormalize3[site] =Isg[site,1] +3uA
            lmn2_shortgndNormalize3[site] =Isg[site,3] +3uA


        end_for
-----Done with LMN0 and LMN2
---Do LMN1 and LMN3
-------open to short battery; only 1 value. tried to
        lmn1_shortbat = Lmn_Search_mod1(SER_GPIO14_LMN1,7.5uA, 12.5uA, 0.01uA, SR_REG26, 0x0, "UP",1)  
        lmn3_shortbat = Lmn_Search_mod1(SER_GPIO16_LMN3_SS1_BNE,7.5uA, 12.5uA, 0.01uA, SR_REG27, 0x0, "UP",3)  
----- Search Line open min from shortbatt

        lmn1_op_min = Lmn_Search_mod1(SER_GPIO14_LMN1, 12.5uA, 7.5uA, 0.01uA, SR_REG26, 0x3, "DOWN",1)   
        lmn3_op_min = Lmn_Search_mod1(SER_GPIO16_LMN3_SS1_BNE,12.5uA, 7.5uA, 0.01uA, SR_REG27, 0x3, "DOWN",3)

        ----Search from normal to open max
        lmn1_op_max = Lmn_Search_mod1(SER_GPIO14_LMN1, -4uA, -2uA, 0.01uA, SR_REG26, 0x3, "UP",1)   
        lmn3_op_max = Lmn_Search_mod1(SER_GPIO16_LMN3_SS1_BNE, -4uA, -2uA, 0.01uA, SR_REG27, 0x3, "UP",3)


-------Open to Line threshold search min for lmn1 and lmn3
        lmn1_line_min = Lmn_Search_mod1(SER_GPIO14_LMN1, -2uA, -4uA, 0.01uA, SR_REG26,  0x4, "DOWN",1)  
        lmn3_line_min = Lmn_Search_mod1(SER_GPIO16_LMN3_SS1_BNE, -2uA, -4uA, 0.01uA, SR_REG27, 0x4, "DOWN",3)  


-------Normal to line threshold search max for lmn1 and lmn3
        lmn1_line_max = Lmn_Search_mod1(SER_GPIO14_LMN1, -7uA, -5uA, 0.01uA, SR_REG26,  0x4, "UP",1)  
        lmn3_line_max = Lmn_Search_mod1(SER_GPIO16_LMN3_SS1_BNE, -7uA, -5uA, 0.01uA, SR_REG27, 0x4, "UP",3)  

-----line to normal threshold search for min threshold of normal for LMN1 and LMN3
        lmn1_nm_min = Lmn_Search_mod1(SER_GPIO14_LMN1, -5uA, -7uA, 0.01uA, SR_REG26,  0x2, "DOWN",1)  
        lmn3_nm_min = Lmn_Search_mod1(SER_GPIO16_LMN3_SS1_BNE, -5uA, -7uA, 0.01uA, SR_REG27, 0x2, "DOWN",3)  

-----shortgnd to normal threshold search for max threshold of normal for LMN1 and LMN3
        lmn1_nm_max = Lmn_Search_mod1(SER_GPIO14_LMN1, -10uA, -8uA, 0.01uA, SR_REG26,  0x2, "UP",1)  
        lmn3_nm_max = Lmn_Search_mod1(SER_GPIO16_LMN3_SS1_BNE, -10uA, -8uA, 0.01uA, SR_REG27, 0x2, "UP",3)  

----Normal to shortgnd threshold; only 1 value in MPW3

        lmn1_shortgnd = Lmn_Search_mod1(SER_GPIO14_LMN1, -8.5uA, -10uA, 0.01uA, SR_REG26,  0x1, "DOWN",1)  
        lmn3_shortgnd = Lmn_Search_mod1(SER_GPIO16_LMN3_SS1_BNE, -8.5uA, -10uA, 0.01uA, SR_REG27, 0x1, "DOWN",3)  

------ShortGnd new method 1 uA away from measured short gnd
        for idx = 1 to sites do
            site = active_sites[idx]
            lmn1_shortgndNormalize[site]  = lmn1_shortgnd[site] - Isg[site,2]
            lmn3_shortgndNormalize [site]  = lmn3_shortgnd[site] - Isg[site,4]

            lmn1_shortgndNormalize3[site] =Isg[site,2] +3uA
            lmn3_shortgndNormalize3[site] =Isg[site,4] +3uA
            lmn1_shortgndNormalize5[site] =Isg[site,2] +5uA
            lmn3_shortgndNormalize5[site] =Isg[site,4] +5uA

            lmn1_shortgndNormalize1p5[site] =Isg[site,2] +1.5uA
            lmn3_shortgndNormalize1p5[site] =Isg[site,4] +1.55uA
----      request by Umut on 12/2018       
            lmn0_normalized_open_to_normal[site] = Isg[site,1] -lmn0_op_max[site]   ---- around 12uA
            lmn2_normalized_open_to_normal[site] = Isg[site,3] -lmn2_op_max[site]
            lmn0_normalized_normal_to_open[site] = Isg[site,1] -lmn0_nm_min[site]
            lmn2_normalized_normal_to_open[site] = Isg[site,3] -lmn2_nm_min[site]
            lmn1_normalized_open_to_line2line_short[site] =   Isg[site,2] -lmn1_line_min[site] ---- around 7uA
            lmn3_normalized_open_to_line2line_short[site] =   Isg[site,4] -lmn3_line_min[site]
            lmn1_normalized_line2line_short_to_open[site] =   Isg[site,2] -lmn1_op_max[site]
            lmn3_normalized_line2line_short_to_open[site] =   Isg[site,4] -lmn3_op_max[site]

            lmn1_normalize_line2line_short_to_normal[site] =   Isg[site,2] -lmn1_line_max[site] ---- around 4uA
            lmn3_normalize_line2line_short_to_normal[site] =   Isg[site,4] -lmn3_line_max[site] ---- around 4uA
            lmn1_normalize_normal_to_l2l_short[site] =   Isg[site,2] -lmn1_nm_min[site] ---- around 4uA
            lmn3_normalize_normal_to_l2l_short[site] =   Isg[site,4] -lmn3_nm_min[site] ---- around 4uA

        end_for
    wait(0)

--------------//////
-------########### add go no go 3% R drift request by Bill Leakage
    set digital ppmu SER_LMN_PINS to fi 10nA imax 20uA measure v max 1V

 --calculate these currents, force them, and read reg4/reg5 to check that the desired threshold conditions are met across allowed resistor variation in systems:  
  -- -1uA accounts for tester-centric current direction.
    for idx = 1 to sites do
        site = active_sites[idx]
--         Ifn0_min[site]       =  (9.66 * Vopen[site,1]) * -1uA  + GBnm02
--         Ifn0_max[site]       =  (10.7 * Vopen[site,1]) * -1uA  - GBnm02
--         Ifn2_min[site]       =  (9.66 * Vopen[site,3]) * -1uA  + GBnm02
--         Ifn2_max[site]       =  (10.7 * Vopen[site,3]) * -1uA  - GBnm02
--         Ifn1_min[site]       =  (9.66 * Vopen[site,2]) * -1uA + GBnm13
--         Ifn1_max[site]       =  (10.7 * Vopen[site,2]) * -1uA - GBnm13
--         Ifn3_min[site]       =  (9.66 * Vopen[site,4]) * -1uA + GBnm13
--         Ifn3_max[site]       =  (10.7 * Vopen[site,4]) * -1uA - GBnm13
--         Iflls1_min[site]    =  (15.03 * Vopen[site,2] - 5.21 * Vopen[site,1]) * -1uA + GBll_13   -- 3 percent RDRIFT values -- spec
--         Iflls3_min[site]    =  (15.03 * Vopen[site,4] - 5.21 * Vopen[site,3]) * -1uA + GBll_13   -- 3 percent RDRIFT values -- spec
--         Iflls1_max[site]    =  (15.80 * Vopen[site,2] - 5.06 * Vopen[site,1]) * -1uA + GBll_13   -- 3 percent RDRIFT values -- spec
--         Iflls3_max[site]    =  (15.80 * Vopen[site,4] - 5.06 * Vopen[site,3]) * -1uA + GBll_13   -- 3 percent RDRIFT values -- spec   
----New 9/2018        
        Ifn0_min[site]       =  (9.53 * Vopen[site,1]) * -1uA  + GBnm02
        Ifn0_max[site]       =  (10.52 * Vopen[site,1]) * -1uA  - GBnm02
        Ifn2_min[site]       =  (9.53 * Vopen[site,3]) * -1uA  + GBnm02
        Ifn2_max[site]       =  (10.52 * Vopen[site,3]) * -1uA  - GBnm02
        Ifn1_min[site]       =  (9.53 * Vopen[site,2]) * -1uA + GBnm13
        Ifn1_max[site]       =  (10.52 * Vopen[site,2]) * -1uA - GBnm13
        Ifn3_min[site]       =  (9.53 * Vopen[site,4]) * -1uA + GBnm13
        Ifn3_max[site]       =  (10.52 * Vopen[site,4]) * -1uA - GBnm13

        Iflls1_min[site]    =  (14.63 * Vopen[site,2] - 5.06 * Vopen[site,1]) * -1uA + GBll_13   -- 3 percent RDRIFT values -- spec
        Iflls1_max[site]    =  ( 15.36* Vopen[site,2] - 4.91 * Vopen[site,1]) * -1uA - GBll_13   -- 3 percent RDRIFT values -- spec

        Iflls3_min[site]    =  ( 14.63* Vopen[site,4] - 5.06 * Vopen[site,3]) * -1uA + GBll_13   -- 3 percent RDRIFT values -- spec
        Iflls3_max[site]    =  (15.36 * Vopen[site,4] - 4.91 * Vopen[site,3]) * -1uA - GBll_13   -- 3 percent RDRIFT values -- spec   

----New 2/2019    by Bill Leake. Umut wants to add this in parallel with spec of 9/2018 to compare yield.  MT 3/2019
---Channel 0 and 2
        Ifn0_min_new[site]       =  (9.713 * Vopen[site,1]) * -1uA  + GBnm02
        Ifn0_max_new[site]       =  (11.021 * Vopen[site,1]) * -1uA  - GBnm02
        Ifn2_min_new[site]       =  (9.713 * Vopen[site,3]) * -1uA  + GBnm02
        Ifn2_max_new[site]       =  (11.021 * Vopen[site,3]) * -1uA  - GBnm02
---Channel 1 and 3
        Ifn1_min_new[site]       =  (9.713 * Vopen[site,2]) * -1uA + GBnm13
        Ifn1_max_new[site]       =  (10.305 * Vopen[site,2]) * -1uA - GBnm13
        Ifn3_min_new[site]       =  ( 9.713* Vopen[site,4]) * -1uA + GBnm13
        Ifn3_max_new[site]       =  (10.305 * Vopen[site,4]) * -1uA - GBnm13    
---Channel 1 and 3
        Iflls1_min_new[site]    =  (14.803 * Vopen[site,2] - 5.592 * Vopen[site,1]) * -1uA + GBll_13   -- 3 percent RDRIFT values -- spec
        Iflls1_max_new[site]    =  (15.538 * Vopen[site,2] - 5.444 * Vopen[site,1]) * -1uA - GBll_13   -- 3 percent RDRIFT values -- spec

        Iflls3_min_new[site]    =  ( 14.803* Vopen[site,4] - 5.592 * Vopen[site,3]) * -1uA + GBll_13   -- 3 percent RDRIFT values -- spec
        Iflls3_max_new[site]    =  (15.538 * Vopen[site,4] - 4.444 * Vopen[site,3]) * -1uA - GBll_13   -- 3 percent RDRIFT values -- spec   

    end_for     

--     Iflls1_min     =  (15.03 * Vopen1 - 5.21 * Vopen0) * -1uA + GB5   -- 3 percent RDRIFT values -- spec
--     Iflls1_max     =  (15.80 * Vopen1 - 5.06 * Vopen0) * -1uA - GB5   -- 3 percent RDRIFT values -- spec

--------Go no go old spec 8/2018. This needs to remove later pending for DE decision 3/2019. MT
    set digital ppmu SER_GPIO13_LMN0   to fi Ifn0_min imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu SER_GPIO15_LMN2_SS2_RO   to fi Ifn2_min imax 20uA measure v max 2V  -- normal current, minimum

    set digital ppmu SER_GPIO14_LMN1  to fi Ifn1_min imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Ifn3_min imax 20uA measure v max 2V  -- normal current, minimum


    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Normal_3pc_02_Min = RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")    
    Normal_3pc_13_Min = RdWordLower
----check normal 3 percent max

    set digital ppmu SER_GPIO13_LMN0   to fi Ifn0_max imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu SER_GPIO15_LMN2_SS2_RO   to fi Ifn2_max imax 20uA measure v max 2V  -- normal current, minimum

    set digital ppmu SER_GPIO14_LMN1  to fi Ifn1_max imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Ifn3_max imax 20uA measure v max 2V  -- normal current, minimum

    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Normal_3pc_02_Max = RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")    
    Normal_3pc_13_Max = RdWordLower

----Check 3percent ll for 1 and 3 Min
    set digital ppmu SER_GPIO14_LMN1  to fi Iflls1_min imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_01_Min = RdWordLower
    
    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Iflls3_min imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_23_Min = RdWordLower
----Check 3percent ll for 1 and 3 Max
    set digital ppmu SER_LMN_PINS to fi 10nA imax 20uA measure v max 1V ---- reset to line open
    wait(20uS)
    set digital ppmu SER_GPIO14_LMN1  to fi Iflls1_max imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_01_Max = RdWordLower

    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Iflls3_max imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_23_Max = RdWordLower

--------------Added new go no go test requested by Bill Leake version 2/2019. Once this works out, will remove the previous one. MT 3/2019
    set digital ppmu SER_LMN_PINS to fi 10nA imax 20uA measure v max 1V ---- reset to line open
    wait(20uS)

---normal 3%

    set digital ppmu SER_GPIO13_LMN0   to fi Ifn0_min_new imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu SER_GPIO15_LMN2_SS2_RO   to fi Ifn2_min_new imax 20uA measure v max 2V  -- normal current, minimum

    set digital ppmu SER_GPIO14_LMN1  to fi Ifn1_min_new imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Ifn3_min_new imax 20uA measure v max 2V  -- normal current, minimum


    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Normal_3pc_02_Min_new = RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")    
    Normal_3pc_13_Min_new = RdWordLower
----check normal 3 percent max

    set digital ppmu SER_GPIO13_LMN0   to fi Ifn0_max_new imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu SER_GPIO15_LMN2_SS2_RO   to fi Ifn2_max_new imax 20uA measure v max 2V  -- normal current, minimum

    set digital ppmu SER_GPIO14_LMN1  to fi Ifn1_max_new imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Ifn3_max_new imax 20uA measure v max 2V  -- normal current, minimum

    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Normal_3pc_02_Max_new = RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")    
    Normal_3pc_13_Max_new = RdWordLower

----Check 3percent ll for 1 and 3 Min
    set digital ppmu SER_GPIO14_LMN1  to fi Iflls1_min_new imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_01_Min_new = RdWordLower
    
    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Iflls3_min_new imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_23_Min_new = RdWordLower

----Check 3percent ll for 1 and 3 Max
    set digital ppmu SER_LMN_PINS to fi 10nA imax 20uA measure v max 1V ---- reset to line open
    wait(20uS)
    set digital ppmu SER_GPIO14_LMN1  to fi Iflls1_max_new imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_01_Max_new = RdWordLower

    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Iflls3_max_new imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_23_Max_new = RdWordLower
-----------------------------------------
    my_float = Ifn0_min
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 1 )   --------LMN0_min for normal
    my_float = Ifn2_min
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 2 )   --------LMN2_min for normal

    my_float = Ifn1_min
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 3 )   --------LMN0_min for normal
    my_float = Ifn3_min
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 4 )   --------LMN2_min for normal

    my_float = Ifn0_max
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 5 )   --------LMN0_max for normal
    my_float = Ifn2_max
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 6 )   --------LMN2_max for normal

    my_float = Ifn1_max
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 7 )   --------LMN0_max for normal
    my_float = Ifn3_max
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 8 )   --------LMN2_max for normal

---- line to line
    my_float = Iflls1_min
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 9 )   --------LMN1_min for line to line
    my_float = Iflls3_min
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 10 )   --------LMN3_min for line to line
    my_float = Iflls1_max
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 11 )   --------LMN1_max for line to line
    my_float = Iflls3_max
    scatter_1d(my_float  , RDRIFT_nonspec_currents, 12 )   --------LMN3_max for line to line
---Setup for datalog reg
        temp_integer = msi(Normal_3pc_02_Min)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 1 )
        temp_integer = msi(Normal_3pc_13_Min)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 2 )
        temp_integer = msi(Normal_3pc_02_Max)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 3 )
        temp_integer = msi(Normal_3pc_13_Max)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 4 )

        temp_integer = msi(Line2line_3pc_01_Min)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 5 )
        temp_integer = msi(Line2line_3pc_23_Min)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 6 )        
        temp_integer = msi(Line2line_3pc_01_Max)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 7 )     
        temp_integer = msi(Line2line_3pc_23_Max)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 8 )            
-------End of 3% drift
----------------------Added for new 3% from Bill Leake. Request by Umut 3-2019 MT.
    my_float = Ifn0_min_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 1 )   --------LMN0_min for normal
    my_float = Ifn2_min_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 2 )   --------LMN2_min for normal

    my_float = Ifn1_min_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 3 )   --------LMN0_min for normal
    my_float = Ifn3_min_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 4 )   --------LMN2_min for normal

    my_float = Ifn0_max_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 5 )   --------LMN0_max for normal
    my_float = Ifn2_max
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 6 )   --------LMN2_max for normal

    my_float = Ifn1_max_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 7 )   --------LMN0_max for normal
    my_float = Ifn3_max_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 8 )   --------LMN2_max for normal

---- line to line
    my_float = Iflls1_min_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 9 )   --------LMN1_min for line to line
    my_float = Iflls3_min
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 10 )   --------LMN3_min for line to line
    my_float = Iflls1_max_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 11 )   --------LMN1_max for line to line
    my_float = Iflls3_max_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 12 )   --------LMN3_max for line to line
---Setup for datalog reg
        temp_integer = msi(Normal_3pc_02_Min_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 1 )
        temp_integer = msi(Normal_3pc_13_Min_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 2 )
        temp_integer = msi(Normal_3pc_02_Max_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 3 )
        temp_integer = msi(Normal_3pc_13_Max_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 4 )

        temp_integer = msi(Line2line_3pc_01_Min_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 5 )
        temp_integer = msi(Line2line_3pc_23_Min_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 6 )        
        temp_integer = msi(Line2line_3pc_01_Max_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 7 )     
        temp_integer = msi(Line2line_3pc_23_Max_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 8 )            
-------End of 3% drift

-------------////
  else

------------- Go and No go Test
wait(0)
--     multisite float   : LMN0NMMax,LMN2NMMax, LMN1NMMax,LMN3NMMax
--     multisite float   : LMN0NMMin,LMN2NMMin, LMN1NMMin,LMN3NMMin
------------Arrange Normalized value for go and no go test  MT 2-2019
    for idx = 1 to sites do
        site = active_sites[idx]
        ---------------------Open
        LMN0OpMax[site] = Isg02[site,1] -LMN02OpMax
        LMN2OpMax[site] = Isg02[site,2] -LMN02OpMax
        LMN1OpMax[site] = Isg13[site,1] -LMN13OpMax
        LMN3OpMax[site] = Isg13[site,2] -LMN13OpMax
---------Normal
        LMN0NMMax[site] = Isg02[site,1] -LMN02NMMax
        LMN2NMMax[site] = Isg02[site,2] -LMN02NMMax 
        LMN0NMMin[site] = Isg02[site,1] -LMN02NMMin
        LMN2NMMin[site] = Isg02[site,2] -LMN02NMMin 
        LMN1NMMax[site] = Isg13[site,1] -LMN13NMMax
        LMN3NMMax[site] = Isg13[site,2] -LMN13NMMax 
        LMN1NMMin[site] = Isg13[site,1] -LMN13NMMin
        LMN3NMMin[site] = Isg13[site,2] -LMN13NMMin 
----Short GND
       LMN0ShrtGnd[site] = Isg02[site,1]- LMN02ShrtGnd
       LMN2ShrtGnd[site] = Isg02[site,2]- LMN02ShrtGnd
       LMN1ShrtGnd[site] = Isg13[site,1]- LMN13ShrtGnd
       LMN3ShrtGnd[site] = Isg13[site,2]- LMN13ShrtGnd
---Line to line short only 1 and 3
       LMN1LineShrtLineMin[site] = Isg13[site,1]-   LMN13LineShrtLineMin
       LMN3LineShrtLineMin[site] = Isg13[site,2]-   LMN13LineShrtLineMin
       LMN1LineShrtLineMax[site] = Isg13[site,1]-   LMN13LineShrtLineMax
       LMN3LineShrtLineMax[site] = Isg13[site,2]-   LMN13LineShrtLineMax

    end_for
    ---------Short to Battery:0/2  from 10uA to 30uA, LMN1 and 3 From 5uA to 15
  
    set digital ppmu SER_GPIO13_LMN0 + SER_GPIO15_LMN2_SS2_RO to fi LMN02SHRTBATT imax 200uA measure v max 1V --215
    set digital ppmu SER_GPIO14_LMN1 + SER_GPIO16_LMN3_SS1_BNE to fi LMN13SHRTBATT  imax 20uA measure v max 1V --225
    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineShrtBatt1= RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineShrtBatt2 = RdWordLower
    wait(1us)

    ---*****-- open 
   set digital ppmu SER_GPIO13_LMN0 + SER_GPIO15_LMN2_SS2_RO to fi LMN02OpMin  imax 20uA measure v max 1V
   set digital ppmu SER_GPIO14_LMN1 + SER_GPIO16_LMN3_SS1_BNE to fi LMN13OpMin imax 20uA measure v max 2V

    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineOp_min1= RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineOp_min2 = RdWordLower
---Open Max seperate channels due to normalized
    set digital ppmu SER_GPIO13_LMN0        to fi LMN0OpMax imax 20uA measure v max 2V   -----need normailized
    set digital ppmu SER_GPIO15_LMN2_SS2_RO to fi LMN2OpMax imax 20uA measure v max 2V   -----need normailized    
    set digital ppmu SER_GPIO14_LMN1         to fi LMN1OpMax imax 20uA measure v max 2V
    set digital ppmu SER_GPIO16_LMN3_SS1_BNE to fi LMN3OpMax imax 20uA measure v max 2V

    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineOp_Max1= RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineOp_Max2 = RdWordLower

   ----- --*****------Normal Thres:2
    set digital ppmu SER_GPIO13_LMN0        to fi LMN0NMMin imax 20uA measure v max 1V
    set digital ppmu SER_GPIO15_LMN2_SS2_RO to fi LMN2NMMin imax 20uA measure v max 1V

    set digital ppmu SER_GPIO14_LMN1         to fi LMN1NMMin imax 20uA measure v max 1V
    set digital ppmu SER_GPIO16_LMN3_SS1_BNE to fi LMN3NMMin imax 20uA measure v max 1V

    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineNmMin1 = RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineNmMin2  = RdWordLower

    set digital ppmu SER_GPIO13_LMN0        to fi LMN0NMMax imax 20uA measure v max 1V
    set digital ppmu SER_GPIO15_LMN2_SS2_RO to fi LMN2NMMax imax 20uA measure v max 1V

    set digital ppmu SER_GPIO14_LMN1         to fi LMN1NMMax imax 10uA measure v max 1V
    set digital ppmu SER_GPIO16_LMN3_SS1_BNE to fi LMN3NMMax imax 10uA measure v max 1V


    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineNmMax1 = RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineNmMax2  = RdWordLower

---------------------
    --Line to Line short:4

    set digital ppmu SER_GPIO14_LMN1         to fi LMN1LineShrtLineMin imax 10uA measure v max 1V
    set digital ppmu SER_GPIO16_LMN3_SS1_BNE to fi LMN3LineShrtLineMin imax 10uA measure v max 1V

    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineShrtLineMin1 = RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineShrtLineMin2  = RdWordLower

    set digital ppmu SER_GPIO14_LMN1         to fi LMN1LineShrtLineMax imax 20uA measure v max 1V
    set digital ppmu SER_GPIO16_LMN3_SS1_BNE to fi LMN3LineShrtLineMax imax 20uA measure v max 1V

    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineShrtLineMax1  = RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineShrtLineMax2  = RdWordLower


    ----------Short to GND:1 ; These value are changing on fly
--     set digital ppmu SER_GPIO13_LMN0 + SER_GPIO15_LMN2_SS2_RO to fi LMN02ShrtGnd imax 200uA measure v max 1V
--     set digital ppmu SER_GPIO14_LMN1 + SER_GPIO16_LMN3_SS1_BNE to fi LMN13ShrtGnd imax 200uA measure v max 1V
     set digital ppmu SER_GPIO13_LMN0        to fi  LMN0ShrtGnd imax 200uA measure v max 1V
     set digital ppmu SER_GPIO15_LMN2_SS2_RO to fi  LMN2ShrtGnd imax 20uA measure v max 1V    
     set digital ppmu SER_GPIO14_LMN1         to fi LMN1ShrtGnd imax 20uA measure v max 1V
     set digital ppmu SER_GPIO16_LMN3_SS1_BNE to fi LMN3ShrtGnd  imax 20uA measure v max 1V
    
    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineShrtGnd1= RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    LineShrtGnd2 = RdWordLower

-------########### add go no go 3% R drift request by Bill Leakage
    set digital ppmu SER_LMN_PINS to fi 10nA imax 20uA measure v max 1V

 --calculate these currents, force them, and read reg4/reg5 to check that the desired threshold conditions are met across allowed resistor variation in systems:  
  -- -1uA accounts for tester-centric current direction.
    for idx = 1 to sites do
        site = active_sites[idx]
--         Ifn0_min[site]       =  (9.66 * Vopen[site,1]) * -1uA  + GBnm02
--         Ifn0_max[site]       =  (10.7 * Vopen[site,1]) * -1uA  - GBnm02
--         Ifn2_min[site]       =  (9.66 * Vopen[site,3]) * -1uA  + GBnm02
--         Ifn2_max[site]       =  (10.7 * Vopen[site,3]) * -1uA  - GBnm02
--         Ifn1_min[site]       =  (9.66 * Vopen[site,2]) * -1uA + GBnm13
--         Ifn1_max[site]       =  (10.7 * Vopen[site,2]) * -1uA - GBnm13
--         Ifn3_min[site]       =  (9.66 * Vopen[site,4]) * -1uA + GBnm13
--         Ifn3_max[site]       =  (10.7 * Vopen[site,4]) * -1uA - GBnm13
--         Iflls1_min[site]    =  (15.03 * Vopen[site,2] - 5.21 * Vopen[site,1]) * -1uA + GBll_13   -- 3 percent RDRIFT values -- spec
--         Iflls3_min[site]    =  (15.03 * Vopen[site,4] - 5.21 * Vopen[site,3]) * -1uA - GBll_13   -- 3 percent RDRIFT values -- spec
--         Iflls1_max[site]    =  (15.80 * Vopen[site,2] - 5.06 * Vopen[site,1]) * -1uA + GBll_13   -- 3 percent RDRIFT values -- spec
--         Iflls3_max[site]    =  (15.80 * Vopen[site,4] - 5.06 * Vopen[site,3]) * -1uA - GBll_13   -- 3 percent RDRIFT values -- spec   
----New 9/2018        
     if CHAR then    ---- Per Umut no need these test any more. Data sheets have been updated to use new equation MT 7/2019
        Ifn0_min[site]       =  (9.53 * Vopen[site,1]) * -1uA  + GBnm02  - gCAL_LMN_IFRC[site,1]
        Ifn0_max[site]       =  (10.52 * Vopen[site,1]) * -1uA  - GBnm02 - gCAL_LMN_IFRC[site,1]
        Ifn2_min[site]       =  (9.53 * Vopen[site,3]) * -1uA  + GBnm02  - gCAL_LMN_IFRC[site,3]
        Ifn2_max[site]       =  (10.52 * Vopen[site,3]) * -1uA  - GBnm02 - gCAL_LMN_IFRC[site,3]
        Ifn1_min[site]       =  (9.53 * Vopen[site,2]) * -1uA + GBnm13   - gCAL_LMN_IFRC[site,2]
        Ifn1_max[site]       =  (10.52 * Vopen[site,2]) * -1uA - GBnm13  - gCAL_LMN_IFRC[site,2]
        Ifn3_min[site]       =  (9.53 * Vopen[site,4]) * -1uA + GBnm13   - gCAL_LMN_IFRC[site,4]
        Ifn3_max[site]       =  (10.52 * Vopen[site,4]) * -1uA - GBnm13  - gCAL_LMN_IFRC[site,4]
        Iflls1_min[site]    =  (14.63 * Vopen[site,2] - 5.06 * Vopen[site,1]) * -1uA + GBll_13  - gCAL_LMN_IFRC[site,2] -- 3 percent RDRIFT values -- spec
        Iflls1_max[site]    =  (15.36 * Vopen[site,2] - 4.91 * Vopen[site,1]) * -1uA - GBll_13  - gCAL_LMN_IFRC[site,2]  -- 3 percent RDRIFT values -- spec
        Iflls3_min[site]    =  (14.63 * Vopen[site,4] - 5.06 * Vopen[site,3]) * -1uA + GBll_13  - gCAL_LMN_IFRC[site, 4]   -- 3 percent RDRIFT values -- spec
        Iflls3_max[site]    =  (15.36 * Vopen[site,4] - 4.91 * Vopen[site,3]) * -1uA - GBll_13  - gCAL_LMN_IFRC[site, 4]    -- 3 percent RDRIFT values -- spec   

    end_if
------------------------------------------------
----New 2/2019    by Bill Leake. Umut wants to add this in parallel with spec of 9/2018 to compare yield.  MT 3/2019
---Channel 0 and 2
        Ifn0_min_new[site]       =  (9.713 * Vopen[site,1]) * -1uA  + GBnm02  - gCAL_LMN_IFRC[site,1]
        Ifn0_max_new[site]       =  (11.021 * Vopen[site,1]) * -1uA  - GBnm02 - gCAL_LMN_IFRC[site,1]
        Ifn2_min_new[site]       =  (9.713 * Vopen[site,3]) * -1uA  + GBnm02  - gCAL_LMN_IFRC[site,3]
        Ifn2_max_new[site]       =  (11.021 * Vopen[site,3]) * -1uA  - GBnm02 - gCAL_LMN_IFRC[site,3]
---Channel 1 and 3
        Ifn1_min_new[site]       =  (9.713 * Vopen[site,2]) * -1uA + GBnm13   - gCAL_LMN_IFRC[site,2]
        Ifn1_max_new[site]       =  (10.305 * Vopen[site,2]) * -1uA - GBnm13  - gCAL_LMN_IFRC[site,2]
        Ifn3_min_new[site]       =  ( 9.713* Vopen[site,4]) * -1uA + GBnm13   - gCAL_LMN_IFRC[site,4]
        Ifn3_max_new[site]       =  (10.305 * Vopen[site,4]) * -1uA - GBnm13  - gCAL_LMN_IFRC[site,4]   
---Channel 1 and 3
        Iflls1_min_new[site]    =  (14.803 * Vopen[site,2] - 5.592 * Vopen[site,1]) * -1uA + GBll_13   - gCAL_LMN_IFRC[site,2]  -- 3 percent RDRIFT values -- spec
        Iflls1_max_new[site]    =  (15.538 * Vopen[site,2] - 5.444 * Vopen[site,1]) * -1uA - GBll_13   - gCAL_LMN_IFRC[site,2]  -- 3 percent RDRIFT values -- spec

        Iflls3_min_new[site]    =  ( 14.803* Vopen[site,4] - 5.592 * Vopen[site,3]) * -1uA + GBll_13   - gCAL_LMN_IFRC[site,4]  -- 3 percent RDRIFT values -- spec
        Iflls3_max_new[site]    =  (15.538 * Vopen[site,4] - 5.444 * Vopen[site,3]) * -1uA - GBll_13   - gCAL_LMN_IFRC[site,4] -- 3 percent RDRIFT values -- spec   
--------------------

    end_for     

--     Iflls1_min     =  (15.03 * Vopen1 - 5.21 * Vopen0) * -1uA + GB5   -- 3 percent RDRIFT values -- spec
--     Iflls1_max     =  (15.80 * Vopen1 - 5.06 * Vopen0) * -1uA - GB5   -- 3 percent RDRIFT values -- spec
    if CHAR then    ---- Per Umut no need these test any more. Data sheets have been updated to use new equation MT 7/2019
        set digital ppmu SER_GPIO13_LMN0   to fi Ifn0_min imax 20uA measure v max 2V  -- normal current, minimum
        set digital ppmu SER_GPIO15_LMN2_SS2_RO   to fi Ifn2_min imax 20uA measure v max 2V  -- normal current, minimum

        set digital ppmu SER_GPIO14_LMN1  to fi Ifn1_min imax 20uA measure v max 2V  -- normal current, minimum
        set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Ifn3_min imax 20uA measure v max 2V  -- normal current, minimum


        RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
        Normal_3pc_02_Min = RdWordLower
        RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")    
        Normal_3pc_13_Min = RdWordLower
----check normal 3 percent max

        set digital ppmu SER_GPIO13_LMN0   to fi Ifn0_max imax 20uA measure v max 2V  -- normal current, minimum
        set digital ppmu SER_GPIO15_LMN2_SS2_RO   to fi Ifn2_max imax 20uA measure v max 2V  -- normal current, minimum

        set digital ppmu SER_GPIO14_LMN1  to fi Ifn1_max imax 20uA measure v max 2V  -- normal current, minimum
        set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Ifn3_max imax 20uA measure v max 2V  -- normal current, minimum

        RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
        Normal_3pc_02_Max = RdWordLower
        RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")    
        Normal_3pc_13_Max = RdWordLower

----Check 3percent ll for 1 and 3 Min
        set digital ppmu SER_GPIO14_LMN1  to fi Iflls1_min imax 20uA measure v max 2V  -- normal current, minimum
        RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
        Line2line_3pc_01_Min = RdWordLower
    
        set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Iflls3_min imax 20uA measure v max 2V  -- normal current, minimum
        RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
        Line2line_3pc_23_Min = RdWordLower
----Check 3percent ll for 1 and 3 Max
        set digital ppmu SER_LMN_PINS to fi 10nA imax 20uA measure v max 1V ---- reset to line open
        wait(20uS)
        set digital ppmu SER_GPIO14_LMN1  to fi Iflls1_max imax 20uA measure v max 2V  -- normal current, minimum
        RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
        Line2line_3pc_01_Max = RdWordLower

        set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Iflls3_max imax 20uA measure v max 2V  -- normal current, minimum
        RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
        Line2line_3pc_23_Max = RdWordLower
    end_if------7/2019 MT
----------------------------------------------
--------------Added new go no go test requested by Bill Leake version 2/2019. Once this works out, will remove the previous one. MT 3/2019
        set digital ppmu SER_LMN_PINS to fi 10nA imax 20uA measure v max 1V ---- reset to line open
        wait(20uS)

---normal 3%

    set digital ppmu SER_GPIO13_LMN0   to fi Ifn0_min_new imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu SER_GPIO15_LMN2_SS2_RO   to fi Ifn2_min_new imax 20uA measure v max 2V  -- normal current, minimum

    set digital ppmu SER_GPIO14_LMN1  to fi Ifn1_min_new imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Ifn3_min_new imax 20uA measure v max 2V  -- normal current, minimum


    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Normal_3pc_02_Min_new = RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")    
    Normal_3pc_13_Min_new = RdWordLower
----check normal 3 percent max

    set digital ppmu SER_GPIO13_LMN0   to fi Ifn0_max_new imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu SER_GPIO15_LMN2_SS2_RO   to fi Ifn2_max_new imax 20uA measure v max 2V  -- normal current, minimum

    set digital ppmu SER_GPIO14_LMN1  to fi Ifn1_max_new imax 20uA measure v max 2V  -- normal current, minimum
    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Ifn3_max_new imax 20uA measure v max 2V  -- normal current, minimum

    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Normal_3pc_02_Max_new = RdWordLower
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")    
    Normal_3pc_13_Max_new = RdWordLower

----Check 3percent ll for 1 and 3 Min
    set digital ppmu SER_GPIO14_LMN1  to fi Iflls1_min_new imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_01_Min_new = RdWordLower
    
    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Iflls3_min_new imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_23_Min_new = RdWordLower

----Check 3percent ll for 1 and 3 Max
    set digital ppmu SER_LMN_PINS to fi 10nA imax 20uA measure v max 1V ---- reset to line open
    wait(20uS)
    set digital ppmu SER_GPIO14_LMN1  to fi Iflls1_max_new imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG26, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_01_Max_new = RdWordLower

    set digital ppmu  SER_GPIO16_LMN3_SS1_BNE  to fi Iflls3_max_new imax 20uA measure v max 2V  -- normal current, minimum
    RegRead(SER_ID, SR_REG27, 1, RdWordUpper, RdWordLower, "SER_UART_Read")   
    Line2line_3pc_23_Max_new = RdWordLower
-----------------------------------------
------For dlog
    if CHAR then    ---- Per Umut no need these test any more. Data sheets have been updated to use new equation MT 7/2019
        my_float = Ifn0_min
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 1 )   --------LMN0_min for normal
        my_float = Ifn2_min
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 2 )   --------LMN2_min for normal

        my_float = Ifn1_min
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 3 )   --------LMN0_min for normal
        my_float = Ifn3_min
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 4 )   --------LMN2_min for normal

        my_float = Ifn0_max
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 5 )   --------LMN0_max for normal
        my_float = Ifn2_max
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 6 )   --------LMN2_max for normal

        my_float = Ifn1_max
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 7 )   --------LMN0_max for normal
        my_float = Ifn3_max
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 8 )   --------LMN2_max for normal

---- line to line
        my_float = Iflls1_min
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 9 )   --------LMN1_min for line to line
        my_float = Iflls3_min
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 10 )   --------LMN3_min for line to line
        my_float = Iflls1_max
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 11 )   --------LMN1_max for line to line
        my_float = Iflls3_max
        scatter_1d(my_float  , RDRIFT_nonspec_currents, 12 )   --------LMN3_max for line to line
---Setup for datalog reg
        temp_integer = msi(Normal_3pc_02_Min)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 1 )
        temp_integer = msi(Normal_3pc_13_Min)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 2 )
        temp_integer = msi(Normal_3pc_02_Max)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 3 )
        temp_integer = msi(Normal_3pc_13_Max)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 4 )

        temp_integer = msi(Line2line_3pc_01_Min)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 5 )
        temp_integer = msi(Line2line_3pc_23_Min)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 6 )        
        temp_integer = msi(Line2line_3pc_01_Max)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 7 )     
        temp_integer = msi(Line2line_3pc_23_Max)
        scatter_1d( temp_integer, RDrift_3pc_Reg , 8 )            
-------End of 3% drift


------------------------Put threshold value into array for data log out
        my_float =LMN02SHRTBATT
        scatter_1d(my_float  ,datalog_threshold , 1 )
        my_float =LMN02OpMin
        scatter_1d(my_float  ,datalog_threshold , 2 )
        my_float =LMN02OpMax
        scatter_1d(my_float  ,datalog_threshold , 3 )
        my_float =LMN02NMMin
        scatter_1d(my_float  ,datalog_threshold , 4 )    
        my_float =LMN02NMMax
        scatter_1d(my_float  ,datalog_threshold , 5 )       
        my_float =LMN02ShrtGnd
        scatter_1d(my_float  ,datalog_threshold , 6 ) 
        my_float =LMN13SHRTBATT
        scatter_1d(my_float  ,datalog_threshold , 7 )            
        my_float =LMN13OpMin
        scatter_1d(my_float  ,datalog_threshold , 8 )       
        my_float =LMN13OpMax
        scatter_1d(my_float  ,datalog_threshold , 9 ) 
        my_float = LMN13NMMin
        scatter_1d(my_float  ,datalog_threshold , 10 )     
        my_float = LMN13NMMax
        scatter_1d(my_float  ,datalog_threshold , 11 )    
        my_float = LMN13ShrtGnd
        scatter_1d(my_float  ,datalog_threshold , 12 )      
        my_float =LMN13LineShrtLineMin          
        scatter_1d(my_float  ,datalog_threshold , 13 )
        my_float =LMN13LineShrtLineMax          
        scatter_1d(my_float  ,datalog_threshold , 14 )   
    end_if  --------------------7/2019 MT 
---------------------------------------------------------------------------------------
----------------------Added for new 3% from Bill Leake. Request by Umut 3-2019 MT.
    my_float = Ifn0_min_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 1 )   --------LMN0_min for normal
    my_float = Ifn2_min_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 2 )   --------LMN2_min for normal

    my_float = Ifn1_min_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 3 )   --------LMN0_min for normal
    my_float = Ifn3_min_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 4 )   --------LMN2_min for normal

    my_float = Ifn0_max_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 5 )   --------LMN0_max for normal
    my_float = Ifn2_max
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 6 )   --------LMN2_max for normal

    my_float = Ifn1_max_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 7 )   --------LMN0_max for normal
    my_float = Ifn3_max_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 8 )   --------LMN2_max for normal

---- line to line
    my_float = Iflls1_min_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 9 )   --------LMN1_min for line to line
    my_float = Iflls3_min
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 10 )   --------LMN3_min for line to line
    my_float = Iflls1_max_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 11 )   --------LMN1_max for line to line
    my_float = Iflls3_max_new
    scatter_1d(my_float  , RDRIFT_nonspec_currents_new, 12 )   --------LMN3_max for line to line
---Setup for datalog reg
        temp_integer = msi(Normal_3pc_02_Min_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 1 )
        temp_integer = msi(Normal_3pc_13_Min_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 2 )
        temp_integer = msi(Normal_3pc_02_Max_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 3 )
        temp_integer = msi(Normal_3pc_13_Max_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 4 )

        temp_integer = msi(Line2line_3pc_01_Min_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 5 )
        temp_integer = msi(Line2line_3pc_23_Min_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 6 )        
        temp_integer = msi(Line2line_3pc_01_Max_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 7 )     
        temp_integer = msi(Line2line_3pc_23_Max_new)
        scatter_1d( temp_integer, RDrift_3pc_Reg_new , 8 )            
-------End of 3% drift



-----


 endif

  set digital ppmu SER_LMN_PINS to fi 0uA imax 20uA measure v max 2V
  disconnect digital pin SER_LMN_PINS from ppmu
  connect digital pin SER_LMN_PINS to dcl
 

  test_value Isg with Ignd_ft mode TVM_PINS
  test_value Vopen with Vopen_ft mode TVM_PINS
  


    if CHAR then

----LMN0 and LMN2    
    scatter_1d(lmn0_shortbat , float_char_measurements , 1 )
    scatter_1d(lmn2_shortbat , float_char_measurements , 2 )
    scatter_1d(lmn0_op_min , float_char_measurements , 3 )
    scatter_1d(lmn2_op_min , float_char_measurements , 4 )
    scatter_1d(lmn0_op_max , float_char_measurements , 5 )
    scatter_1d( lmn2_op_max, float_char_measurements , 6 )
    scatter_1d(lmn0_nm_min, float_char_measurements , 7 )
    scatter_1d( lmn2_nm_min, float_char_measurements , 8 )
    scatter_1d( lmn0_nm_max, float_char_measurements , 9 )
    scatter_1d( lmn2_nm_max , float_char_measurements , 10 )
    scatter_1d( lmn0_shortgnd, float_char_measurements , 11 )
    scatter_1d( lmn2_shortgnd, float_char_measurements , 12 )
-------LMN1 and LMN3
    scatter_1d(lmn1_shortbat , float_char_measurements , 13 )
    scatter_1d(lmn3_shortbat, float_char_measurements , 14 )       
        
    scatter_1d(lmn1_op_min , float_char_measurements , 15 )  
    scatter_1d(lmn3_op_min, float_char_measurements , 16 )
    scatter_1d(lmn1_op_max , float_char_measurements , 17 )  
    scatter_1d(lmn3_op_max , float_char_measurements , 18 )
    scatter_1d(lmn1_line_min, float_char_measurements , 19 )  
    scatter_1d(lmn3_line_min, float_char_measurements , 20 ) 
    scatter_1d(lmn1_line_max , float_char_measurements , 21 )  
    scatter_1d(lmn3_line_max, float_char_measurements , 22 )
    scatter_1d(lmn1_nm_min , float_char_measurements , 23 )  
    scatter_1d(lmn3_nm_min, float_char_measurements , 24 ) 
    scatter_1d(lmn1_nm_max, float_char_measurements , 25 )  
    scatter_1d(lmn3_nm_max, float_char_measurements , 26 ) 
    scatter_1d(lmn1_shortgnd, float_char_measurements , 27 )  
    scatter_1d(lmn3_shortgnd, float_char_measurements , 28 )

    scatter_1d(lmn0_shortgndNormalize, float_char_measurements , 29 )  
    scatter_1d(lmn2_shortgndNormalize, float_char_measurements , 30 )
    scatter_1d(lmn1_shortgndNormalize, float_char_measurements , 31 )  
    scatter_1d(lmn3_shortgndNormalize, float_char_measurements , 32 )
    test_value float_char_measurements with float_char_tests
---Normalize new added 
    scatter_1d(lmn0_shortgndNormalize3, float_normalize , 1 ) 
    scatter_1d(lmn2_shortgndNormalize3, float_normalize , 2 ) 
    scatter_1d(lmn1_shortgndNormalize3, float_normalize , 3 ) 
    scatter_1d(lmn3_shortgndNormalize3, float_normalize , 4 ) 
    scatter_1d(lmn1_shortgndNormalize5, float_normalize , 5 ) 
    scatter_1d(lmn3_shortgndNormalize5, float_normalize , 6 ) 
    scatter_1d(lmn1_shortgndNormalize1p5, float_normalize , 7 ) 
    scatter_1d(lmn3_shortgndNormalize1p5, float_normalize , 8 ) 
    scatter_1d(lmn0_normalized_open_to_normal, float_normalize , 9 ) 
    scatter_1d(lmn2_normalized_open_to_normal, float_normalize , 10 ) 
    scatter_1d(lmn0_normalized_normal_to_open, float_normalize , 11 ) 
    scatter_1d(lmn2_normalized_normal_to_open, float_normalize , 12 ) 
    scatter_1d(lmn1_normalized_open_to_line2line_short, float_normalize , 13 )    
    scatter_1d(lmn3_normalized_open_to_line2line_short, float_normalize , 14 )    
    scatter_1d(lmn1_normalized_line2line_short_to_open, float_normalize , 15 )    
    scatter_1d(lmn3_normalized_line2line_short_to_open, float_normalize , 16 )    
    scatter_1d(lmn1_normalize_line2line_short_to_normal, float_normalize , 17 )    
    scatter_1d(lmn3_normalize_line2line_short_to_normal, float_normalize , 18 )    
    scatter_1d(lmn1_normalize_normal_to_l2l_short, float_normalize , 19)    
    scatter_1d(lmn3_normalize_normal_to_l2l_short, float_normalize , 20)    

    
----      request by Umut on 12/2018       
            lmn0_normalized_open_to_normal[site] = Isg[site,1] -lmn0_op_max[site]   ---- around 12uA
            lmn2_normalized_open_to_normal[site] = Isg[site,3] -lmn2_op_max[site]
            lmn0_normalized_normal_to_open[site] = Isg[site,1] -lmn0_nm_min[site]
            lmn2_normalized_normal_to_open[site] = Isg[site,3] -lmn2_nm_max[site]
            lmn1_normalized_open_to_line2line_short[site] =   Isg[site,2] -lmn1_line_min[site] ---- around 7uA
            lmn3_normalized_open_to_line2line_short[site] =   Isg[site,4] -lmn3_line_min[site]
            lmn1_normalized_line2line_short_to_open[site] =   Isg[site,2] -lmn1_op_max[site]
            lmn3_normalized_line2line_short_to_open[site] =   Isg[site,4] -lmn3_op_max[site]

            lmn1_normalize_line2line_short_to_normal[site] =   Isg[site,2] -lmn1_line_max[site] ---- around 4uA
            lmn3_normalize_line2line_short_to_normal[site] =   Isg[site,4] -lmn3_line_max[site] ---- around 4uA
            lmn1_normalize_normal_to_l2l_short[site] =   Isg[site,2] -lmn1_nm_min[site] ---- around 4uA
            lmn3_normalize_normal_to_l2l_short[site] =   Isg[site,4] -lmn3_nm_min[site] ---- around 4uA

        test_value RDRIFT_nonspec_currents with RDRIFI
        test_value RDrift_3pc_Reg with RDRIFTREG
        test_value float_normalize with Normalize


    else

        temp_integer = msi(LineShrtBatt1)
        scatter_1d( temp_integer, threshold_registers , 1 )
        temp_integer = msi(LineShrtBatt2)
        scatter_1d( temp_integer, threshold_registers , 2 )        
         temp_integer = msi(LineOp_min1)
        scatter_1d( temp_integer, threshold_registers , 3 )        
         temp_integer = msi(LineOp_Max1)
        scatter_1d( temp_integer, threshold_registers , 4 )         
         temp_integer = msi(LineOp_min2)
        scatter_1d( temp_integer, threshold_registers , 5 )            
         temp_integer = msi(LineOp_Max2)
        scatter_1d( temp_integer, threshold_registers , 6 )           
          temp_integer = msi(LineNmMin1)
        scatter_1d( temp_integer, threshold_registers , 7 )           
           temp_integer = msi(LineNmMax1)
        scatter_1d( temp_integer, threshold_registers , 8 )           
           temp_integer = msi(LineNmMin2)
        scatter_1d( temp_integer, threshold_registers , 9 )         
            temp_integer = msi(LineNmMax2)
        scatter_1d( temp_integer, threshold_registers , 10 )   
         temp_integer = msi(LineShrtLineMin1)
        scatter_1d( temp_integer, threshold_registers , 11 ) 
         temp_integer = msi(LineShrtLineMax1)
        scatter_1d( temp_integer, threshold_registers , 12 )                
        temp_integer = msi(LineShrtGnd1)
        scatter_1d( temp_integer, threshold_registers , 13 )            
        temp_integer = msi(LineShrtGnd2)
        scatter_1d( temp_integer, threshold_registers , 14 )  
        
        test_value threshold_registers with gng_threshold_tests

--         test_value RDRIFT_nonspec_currents with RDRIFI    ----no longer tested  MT 7/2019
--         test_value RDrift_3pc_Reg with RDRIFTREG         ----no longer tested  MT 7/2019

        test_value RDRIFT_nonspec_currents_new with RDRIFI_NEW
        test_value RDrift_3pc_Reg_new with RDRIFTREG_NEW

endif
  
   
   
   
  ------------------------------------------ 
---------power down 
   set digital pin ALL_PATTERN_PINS - fpga_pattern_pins levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
  wait(500us)
  
  
  set hcovi SER_VDD + SER_VDD18 to fv 0V vmax 4V clamp imax 600mA imin -600mA         
  set hcovi SER_VDDIO to fv 0V   vmax 4V clamp imax 600mA imin -600mA
  
 	  
  wait(10ms)     -- extra for 47uF cap on SER_VDD        

  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18) 
  
  end_body
procedure GmslOutputResistance(Vdd, Vdd18, Vddio, ResistanceTest, XresVoltageTest, VDD18_P_tst_A, VDD18_N_tst_A, VDD18_P_tst_B, VDD18_N_tst_B, VDD18_P_tst_A_5mA, VDD18_N_tst_A_5mA, VDD18_P_tst_B_5mA, VDD18_N_tst_B_5mA,SIOP_tst_A, SION_tst_A, SIOP_tst_B, SION_tst_B, SIOP_tst_A_5mA, SION_tst_A_5mA, SIOP_tst_B_5mA, SION_tst_B_5mA, DirectSIOP_tst_A, DirectSION_tst_A, DirectSIOP_tst_B, DirectSION_tst_B, DirectSIOP_tst_A_5mA, DirectSION_tst_A_5mA, DirectSIOP_tst_B_5mA, DirectSION_tst_B_5mA , POWERUP,POWERDOWN)
in float          : Vdd, Vdd18, Vddio
in_out float_test : ResistanceTest, XresVoltageTest
in_out float_test : VDD18_P_tst_A, VDD18_N_tst_A, VDD18_P_tst_B, VDD18_N_tst_B, VDD18_P_tst_A_5mA, VDD18_N_tst_A_5mA, VDD18_P_tst_B_5mA, VDD18_N_tst_B_5mA
in_out float_test : SIOP_tst_A, SION_tst_A, SIOP_tst_B, SION_tst_B, SIOP_tst_A_5mA, SION_tst_A_5mA, SIOP_tst_B_5mA, SION_tst_B_5mA 
in_out float_test : DirectSIOP_tst_A, DirectSION_tst_A, DirectSIOP_tst_B, DirectSION_tst_B, DirectSIOP_tst_A_5mA, DirectSION_tst_A_5mA, DirectSIOP_tst_B_5mA, DirectSION_tst_B_5mA 
in boolean        : POWERUP,POWERDOWN
local
--   multisite float : PhyAPHighMeas[1], PhyAPLowMeas[1], PhyANHighMeas[1], PhyANLowMeas[1]
--   multisite float : PhyAPHighMeas2[1], PhyAPLowMeas2[1], PhyANHighMeas2[1], PhyANLowMeas2[1]
--   multisite float : PhyBPHighMeas[1], PhyBPLowMeas[1], PhyBNHighMeas[1], PhyBNLowMeas[1]
--   multisite float : PhyBPHighMeas2[1], PhyBPLowMeas2[1], PhyBNHighMeas2[1], PhyBNLowMeas2[1]


  multisite float   : PhyAPTopMeas[1], PhyAPBotMeas[1], PhyANTopMeas[1], PhyANBotMeas[1]
  multisite float   : PhyAPTopMeas2[1], PhyAPBotMeas2[1], PhyANTopMeas2[1], PhyANBotMeas2[1]
  multisite float   : PhyBPTopMeas[1], PhyBPBotMeas[1], PhyBNTopMeas[1], PhyBNBotMeas[1]
  multisite float   : PhyBPTopMeas2[1], PhyBPBotMeas2[1], PhyBNTopMeas2[1], PhyBNBotMeas2[1]
  multisite float   : DirectPhyAPBotMeas[1], DirectPhyAPBotMeas2[1], DirectPhyANBotMeas[1], DirectPhyANBotMeas2[1]
  multisite float   : DirectPhyBPBotMeas[1], DirectPhyBPBotMeas2[1], DirectPhyBNBotMeas[1], DirectPhyBNBotMeas2[1]
  
  multisite float : PhyResCalc[4], XresVltg
  multisite word  : Status
  word            : CurSite
  PIN LIST[2]     : MeasVi16P, MeasVi16N

  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword


endlocal

body
  active_sites = get_active_sites()
  sites = word(len(active_sites))
--  disconnect digital pin DUT_XRES from dcl

  -- setup some pin lists to make cadence statements more readable maybe move to global pin groups
  MeasVi16N = DC_SE_M_A_VI + DC_SE_M_B_VI
  MeasVi16P = DC_SE_P_A_VI + DC_SE_P_B_VI

---  Status = DutPowerUp(Vddc, Vdda, Vdd18, Vddio, Vddio25, Vdd33, "A0_UART_COAX", "SioDc", "", 0.0)
----Procedure for power up  need put in small routine later
   disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!  

        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)
    DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)

  close digital cbit    ABUS_RELAY           ---------- connect the ABUS GPIO to the VI16 resources

  SetTestMode(11, False, "SER_UART_Write")
  wait(5ms)
  
--  Set TX amplitude field = 0x00. 
  RegWrite(SER_ID, SR_RLMS95_A, 1, 0, 0xC0, "SER_UART_Write")
  RegWrite(SER_ID, SR_RLMS95_B, 1, 0, 0xC0, "SER_UART_Write")
--  Set TX PreDrvAmplMan field = 0x30
  RegWrite(SER_ID, SR_RLMS94_A, 1, 0, 0x70, "SER_UART_Write")  ---70
  RegWrite(SER_ID, SR_RLMS94_B, 1, 0, 0x70, "SER_UART_Write")---70

-- one-shot reset of data path (register values not affected)
--  RegWrite(SER_ID, SR_CTRL0, 1, 0, 16#20, "SER_UART_Write")

 ------- Select the PHYA block / 
    RegWrite(SER_ID, SR_TEST0, 1, 0, 16#89, "SER_UART_Write")              ------- Select the PHYA block /  set vi16 chan abus0_pins+abus1_pins+abus2_pins+abus3_pins+MeasVi16P+MeasVi16N to fi 0A max 5mA measure v max 2V clamp vmax 2V vmin -1V    
    RegRead(SER_ID, SR_TEST0, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    RegRead(SER_ID, SR_RLMS48_A, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#29, "SER_UART_Write")         ------Force TXhigh
    RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#29, "SER_UART_Write")         ------Force TXhigh
    close  cbit   MFP_LT_RELAY ----Connect GPIOs to ABUS unfortunately, SDA and SCL also disconnect. Fix in RevB hw
    close cbit COAXB_P_RELAY + COAXB_M_RELAY  ---Connecto DC circuit
    close  cbit  I2C_LT_CB  + MFP_LT_K12_RELAY  ----Using FPGA to communicate
    
   
----Disconnect DP from SIOA/SIOB
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from dcl
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from ppmu
    wait(5mS)
  -- **** GMSL PHY A Testing ****
  -- Measure the differential voltage before sinking any current

    connect vi16 chan  SER_ABUS0 + SER_ABUS1+ SER_ABUS2+ SER_ABUS3 remote
    set vi16 chan SER_ABUS0  + SER_ABUS1 +  SER_ABUS2+ SER_ABUS3 to fi 0.01ua  measure V max 2v clamp vmax 2v vmin -0.1v  
    set vi16 chan SER_ABUS0  + SER_ABUS1 +  SER_ABUS2+ SER_ABUS3 + MeasVi16P+MeasVi16N to fi 0A max 5mA measure v max 2V clamp vmax 2V vmin -2V

  gate vi16 chan SER_ABUS0  + SER_ABUS1 +  SER_ABUS2+ SER_ABUS3 + MeasVi16P+MeasVi16N on ---Do I need it? I don't think I gate it off
--  connect vi16 chan SER_ABUS0+abus1_VI16_pins+abus2_VI16_pins+abus3_VI16_pins + MeasVi16P + MeasVi16N remote hot switch
  connect vi16 chan SER_ABUS0  + SER_ABUS1 +  SER_ABUS2+ SER_ABUS3 vm 
  connect vi16 chan MeasVi16P+MeasVi16N remote hot switch
  wait(5ms)---15ms

  measure vi16 v on chan SER_ABUS1 for 15 samples every 10us averaged into PhyAPBotMeas           ------PhyAPLowMeas  
  measure vi16 v on chan SER_ABUS0 for 15 samples every 10us averaged into PhyAPTopMeas           ------PhyAPHighMeas 
  measure vi16 v on chan DC_SE_P_A_VI for 15 samples every 10us averaged into DirectPhyAPBotMeas  --added hcu
--  RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#2A, "SER_UART_Write")         ------Force TXLow
 fpga_UART_Write("FPGA1","SER", SER_ID,SR_RLMS48_A , 1, 0x2A)        ------Force TXLow

--  RegRead(SER_ID,SR_RLMS48_A, 1, RdWordUpper, RdWordLower, "SER_UART_Read")  
  RdWordLower = fpga_UART_Read("FPGA1", "SER", SER_ID,SR_RLMS48_A , 1)
 


  measure vi16 v on chan SER_ABUS3 for 15 samples every 10us averaged into PhyANBotMeas
  measure vi16 v on chan SER_ABUS2 for 15 samples every 10us averaged into PhyANTopMeas
  measure vi16 v on chan DC_SE_M_A_VI for 15 samples every 10us averaged into DirectPhyANBotMeas  --added hcu
 wait(0)

  -- Sink 5mA of current and re-measure the differential voltage
  set vi16 chan MeasVi16P+MeasVi16N to fi -5mA max 5mA measure v max 2V clamp vmax 2V vmin -1V
  wait(5ms)---15ms
  measure vi16 v on chan SER_ABUS3 for 15 samples every 10us averaged into  PhyANBotMeas2           ------PhyANLowMeas2
  measure vi16 v on chan SER_ABUS2 for 15 samples every 10us averaged into  PhyANTopMeas2            ------PhyANHighMeas2
  measure vi16 v on chan DC_SE_M_A_VI for 15 samples every 10us averaged into DirectPhyANBotMeas2 --added hcu
--  RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#29, "SER_UART_Write")         ------Force TXhigh
 fpga_UART_Write("FPGA1","SER", SER_ID,SR_RLMS48_A , 1, 0x29)        ------Force TXhigh
--  RdWordLower = fpga_UART_Read("FPGA1", "SER", SER_ID,SR_RLMS48_A , 1)

  measure vi16 v on chan SER_ABUS1 for 15 samples every 10us averaged into PhyAPBotMeas2            ------ PhyAPLowMeas2  
  measure vi16 v on chan SER_ABUS0 for 15 samples every 10us averaged into PhyAPTopMeas2           ------ PhyAPHighMeas2
  measure vi16 v on chan DC_SE_P_A_VI for 15 samples every 10us averaged into DirectPhyAPBotMeas2--added hcu
  -- Determine the voltage difference between 0mA and 1mA to calculate the resistance
  for idx = 1 to sites do 
    CurSite = active_sites[idx]
    PhyResCalc[CurSite, 1] = ((PhyAPTopMeas2[CurSite, 1] - PhyAPBotMeas2[CurSite, 1] )- (PhyAPTopMeas[CurSite, 1] - PhyAPBotMeas[CurSite, 1] )) / 5mA
    PhyResCalc[CurSite, 2] =  ((PhyANTopMeas2[CurSite, 1] - PhyANBotMeas2[CurSite, 1]-  (PhyANTopMeas[CurSite, 1] - PhyANBotMeas[CurSite, 1] ) ) )/ 5mA
  endfor
  set vi16 chan  SER_ABUS0  + SER_ABUS1 +  SER_ABUS2+ SER_ABUS3 +MeasVi16P + MeasVi16N to fi 0A max 5mA measure v max 2V clamp vmax 2V vmin -1V

--   open digital cbit  I2C_LT_CB
--   open digital cbit   MFP_LT_RELAY  ---Connect SCL/SDA back to dp
--   wait(5ms)

  -- **** GMSL PHY B Testing ****
  -- Measure the differential voltage before sinking any current
--   RegWrite(SER_ID, SR_TEST0, 1, 0, 16#99, "SER_UART_Write")                                                       -- Select the PHYB block / Phy Pullup Resistor page
--   RegRead(SER_ID, SR_TEST0, 1, RdWordUpper, RdWordLower, "SER_UART_Read")  
--   RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#29, "SER_UART_Write")         ------Force TXhigh

 fpga_UART_Write("FPGA1","SER", SER_ID, SR_TEST0, 1, 0x99)   
  RdWordLower = fpga_UART_Read("FPGA1", "SER", SER_ID,SR_TEST0 , 1)  
 fpga_UART_Write("FPGA1","SER", SER_ID,SR_RLMS48_B , 1, 0x29)
wait(1ms) 
--   close digital cbit  I2C_LT_CB
--   close digital cbit   MFP_LT_RELAY ---Connect GPIO to abus
--   wait(15ms)
--  RdWordLower = fpga_UART_Read("FPGA1", "SER", SER_ID,SR_RLMS48_B , 1)

  measure vi16 v on chan SER_ABUS1 for 15 samples every 10us averaged into PhyBPBotMeas   
  measure vi16 v on chan SER_ABUS0 for 15 samples every 10us averaged into PhyBPTopMeas 
  measure vi16 v on chan DC_SE_P_B_VI for 15 samples every 10us averaged into DirectPhyBPBotMeas--added hcu
--  wait(5ms) 

--  RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#2A, "SER_UART_Write")

 fpga_UART_Write("FPGA1","SER", SER_ID,SR_RLMS48_B , 1, 0x2A)        ------Force TXlow
--  RdWordLower = fpga_UART_Read("FPGA1", "SER", SER_ID,SR_RLMS48_B , 1)  
  wait(1ms)  

  measure vi16 v on chan SER_ABUS3 for 15 samples every 10us averaged into PhyBNBotMeas
  measure vi16 v on chan SER_ABUS2 for 15 samples every 10us averaged into PhyBNTopMeas 
 measure vi16 v on chan DC_SE_M_B_VI for 15 samples every 10us averaged into DirectPhyBNBotMeas --added hcu
  -- Sink 5mA of current and re-measure the differential voltage
  set vi16 chan MeasVi16P+MeasVi16N to fi -5mA max 5mA measure v max 2V clamp vmax 2V vmin -1V
  wait(5ms)---15ms

  measure vi16 v on chan SER_ABUS1 for 15 samples every 10us averaged into PhyBPBotMeas2          ------ PhyBPLowMeas2  
  measure vi16 v on chan SER_ABUS0 for 15 samples every 10us averaged into PhyBPTopMeas2          ------PhyBPHighMeas2
 measure vi16 v on chan DC_SE_P_B_VI for 15 samples every 10us averaged into DirectPhyBPBotMeas2 --added hcu
--  RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#29, "SER_UART_Write")

 fpga_UART_Write("FPGA1","SER", SER_ID,SR_RLMS48_B , 1, 0x29)        
    wait(1mS)
  measure vi16 v on chan SER_ABUS3 for 15 samples every 10us averaged into PhyBNBotMeas2    ------ PhyBNLowMeas2
  measure vi16 v on chan SER_ABUS2 for 15 samples every 10us averaged into PhyBNTopMeas2    ------ PhyBNHighMeas2
measure vi16 v on chan DC_SE_M_B_VI for 15 samples every 10us averaged into DirectPhyBNBotMeas2  --added hcu

  -- Determine the voltage difference between 0mA and 1mA to calculate the resistance
  for idx = 1 to sites do 
    CurSite = active_sites[idx]
    PhyResCalc[CurSite, 3] = ((PhyBPTopMeas2[CurSite, 1] - PhyBPBotMeas2[CurSite, 1] ) - (PhyBPTopMeas[CurSite, 1] - PhyBPBotMeas[CurSite, 1] )) / 5.0mA
    PhyResCalc[CurSite, 4] = ((PhyBNTopMeas2[CurSite, 1] - PhyBNBotMeas2[CurSite, 1] ) -  (PhyBNTopMeas[CurSite, 1] - PhyBNBotMeas[CurSite, 1] )) / 5.0mA
  endfor

  set vi16 chan SER_ABUS0+SER_ABUS1+SER_ABUS2+SER_ABUS3+MeasVi16P+MeasVi16N to fi 0A max 5mA measure v max 2V clamp vmax 2V vmin -1V
  wait(1ms)
  disconnect vi16 chan SER_ABUS0+SER_ABUS1+SER_ABUS2+SER_ABUS3+MeasVi16P+MeasVi16N
  set vi16 chan SER_ABUS0+SER_ABUS1+SER_ABUS2+SER_ABUS3+MeasVi16P+MeasVi16N to fv 0V max 5V measure i max 100mA clamp imax 100mA imin -100mA

--  gate vi16 chan SER_ABUS0+SER_ABUS1+SER_ABUS2+SER_ABUS3+MeasVi16P+MeasVi16N off

---------power down 
  if POWERDOWN then
    set digital pin ALL_PATTERN_PINS levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
     wait(500us)
    open digital cbit    ABUS_RELAY +  MFP_LT_RELAY  + I2C_LT_CB + MFP_LT_K12_RELAY 
    open cbit CB2_SLDC + CB1_SLDC  ---Connecto DC circuit
    open cbit COAXB_P_RELAY + COAXB_M_RELAY 
    connect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP to dcl

    set hcovi SER_VDD + SER_VDD18 to fv 0V vmax 4V clamp imax 600mA imin -600mA         
    set hcovi SER_VDDIO to fv 0V   vmax 4V clamp imax 600mA imin -600mA
      wait(2ms)     -- extra for 47uF cap on SER_VDD        

  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
    vdd_global[1] = 0V   --SER_VDDIO
    vdd_global[2] = 0V   --SER_VDD  
    vdd_global[3] = 0V   --SER_VDDA(VDD18)  
   end_if 
----Datalog

  test_value PhyResCalc with ResistanceTest
  test_value XresVltg with XresVoltageTest
  test_value PhyAPTopMeas with VDD18_P_tst_A
  test_value PhyANTopMeas with VDD18_N_tst_A
  test_value PhyBPTopMeas with VDD18_P_tst_B
  test_value PhyBNTopMeas with VDD18_N_tst_B
  test_value PhyAPTopMeas2 with VDD18_P_tst_A_5mA
  test_value PhyANTopMeas2 with VDD18_N_tst_A_5mA
  test_value PhyBPTopMeas2 with VDD18_P_tst_B_5mA
  test_value PhyBNTopMeas2 with VDD18_N_tst_B_5mA
  test_value PhyAPBotMeas with SIOP_tst_A
  test_value PhyANBotMeas with SION_tst_A
  test_value PhyBPBotMeas with SIOP_tst_B
  test_value PhyBNBotMeas with SION_tst_B
  test_value PhyAPBotMeas2 with SIOP_tst_A_5mA
  test_value PhyANBotMeas2 with SION_tst_A_5mA
  test_value PhyBPBotMeas2 with SIOP_tst_B_5mA
  test_value PhyBNBotMeas2 with SION_tst_B_5mA
  
  test_value DirectPhyAPBotMeas with DirectSIOP_tst_A
  test_value DirectPhyANBotMeas with DirectSION_tst_A
  test_value DirectPhyBPBotMeas with DirectSIOP_tst_B
  test_value DirectPhyBNBotMeas with DirectSION_tst_B
  test_value DirectPhyAPBotMeas2 with DirectSIOP_tst_A_5mA
  test_value DirectPhyANBotMeas2 with DirectSION_tst_A_5mA
  test_value DirectPhyBPBotMeas2 with DirectSIOP_tst_B_5mA
  test_value DirectPhyBNBotMeas2 with DirectSION_tst_B_5mA
endbody


procedure GPIOPullUpDownTest(Vdd, Vdd18, Vddio, TestPins, ForceV, ConnectV, IRange, RegConfigStr, ConnectToDclAtEnd, ResultTest, Test_LOCK_ERRB,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
in float               : Vdd, Vdd18, Vddio, ForceV, IRange, ConnectV
in PIN LIST[25]        : TestPins
in string[32]          : RegConfigStr
in boolean             : ConnectToDclAtEnd
in_out float_test      : ResultTest, Test_LOCK_ERRB
in boolean              : POWERUP,POWERDOWN
local
  multisite float  :  CurMeas[27], ResVal[27], Cur_LOCK_ERRB[2], Res_LOCK_ERRB[2]
  word             :  CurSite
  float            :  ForceRange, ForceAvg
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword
end_local  

body
  active_sites = get_active_sites()
  sites = word(len(active_sites))
  ForceRange = abs(ForceV - ConnectV)
  ForceAvg = (ForceV + ConnectV)/2.0

  -- Power up the device and setup to measure the pullup / pulldown values of the inputs and GPIO pins

 ----Procedure for power up  need put in small routine later
   disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!  
  -- reset levels
--   set digital pin ALL_PATTERN_PINS levels to vil 0V vih 0.2V vol 0V voh 0V iol 0mA ioh 0mA vref 0V
--   set digital pin ALL_PATTERN_PINS modes to driver pattern     -- Do not delete !!!
--   wait(1ms)
--   execute digital pattern "PowerUp" at label "ALL_ZERO" wait   -- Do not delete in order to reset all pins to vil level !!!
--     wait(1ms)        
-- -----The function below is for setting DUT supplies ONLY, change Voltage if Required  
--     Set_SER_Voltages(Vddio, Vdd, Vdd18)
--     wait (10ms) -- trial for 47uF cap on SER_VDD       
--     Vconf0 = 0.11 * Vddio
--     Vconf1 = 0.16 * Vddio
--         
--     set digital pin SER_GPO4_CFG0  + SER_GPO6_CFG2 levels to vil Vconf0 vih Vddio   -- TP/UART mode with DEV_ID = 0x80
--     set digital pin  SER_GPO5_CFG1 levels to vil Vconf1 vih Vddio                    ---GMSL2 mode 
--   
--     wait(1ms)
-- 
--         
--   -------- Set PWDN =1 to power up DUT --------
--     execute digital pattern "PowerUp" at label "TP" run to end wait
--     wait(6ms) 

   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP) ---Set link to GMSL1
--    RegRead(SER_ID, SR_REG5, 1, RdWordUpper, RdWordLower, "SER_UART_Read")




---------------Disable LOCK and ERROR function on MFP0 and MFP1 for gpio resistance test Man Tran 6/2017
    



    RegWrite(SER_ID, SR_REG5, 1, 0, 16#00, "SER_UART_Write") 
    if POWERUP then    ---reset resister
        DevRegConfig(RegConfigStr)
    end_if    
--     RegRead(SER_ID,SR_GPIO_A_4 , 1, RdWordUpper, RdWordLower, "SER_UART_Read")
--     RegRead(SER_ID,SR_GPIO_B_4 , 1, RdWordUpper, RdWordLower, "SER_UART_Read")

    if( RegConfigStr[5] = "u") then ----GPO 4 5 6
        RegWrite(SER_ID, SR_GPIO_A_4, 1, 0, 16#80, "SER_UART_Write") 
        RegWrite(SER_ID, SR_GPIO_B_4, 1, 0, 16#80, "SER_UART_Write")
        RegWrite(SER_ID, SR_GPIO_A_5, 1, 0, 16#80, "SER_UART_Write") 
        RegWrite(SER_ID, SR_GPIO_B_5, 1, 0, 16#80, "SER_UART_Write")
        RegWrite(SER_ID, SR_GPIO_A_6, 1, 0, 16#80, "SER_UART_Write") 
        RegWrite(SER_ID, SR_GPIO_B_6, 1, 0, 16#80, "SER_UART_Write")

    end_if     
--------------------------***********************************************************----------------
---------------Disable UART local for GPIO testing on TXSDA/RXSCL pins. Last step before making measurement; no longer using local commnication after this write

     RegWrite(SER_ID,SR_REG1 , 1, 0, 16#20, "SER_UART_Write")   

--------------------------***********************************************************----------------

--      RegWrite(SER_ID,SR_GPIO_C_5 , 1, 0, 16#c3, "SER_UART_Write")  -- GPIO_B -- need 0xA0 or would 0x80 also work OK?
--  SetRelays("DisDutI2cPullup")
  
  disconnect digital pin TestPins from dcl

  enable digital ppmu TestPins fv ConnectV vmax 5V measure i max IRange
  set digital ppmu TestPins to fv ConnectV vmax 5V measure i max IRange
  connect digital ppmu TestPins to fv ConnectV vmax 5V measure i max IRange
  wait(1ms)
  if ForceRange > 3.0 then
    set digital ppmu TestPins to fv ForceAvg vmax 5V measure i max IRange    -- DEGLITCH related.
    wait(500us)
  endif  
  set digital ppmu TestPins to fv (ForceAvg + 0.5*(ForceV-ForceAvg)) vmax 5V measure i max IRange       -- DEGLITCH related.  When connect & force V's are too far apart,have to make one more step in between.
  set digital ppmu TestPins to fv ForceV vmax 5V measure i max IRange
  wait(2ms)---2 not work--0-10
  measure digital ppmu TestPins current imax IRange average 10 parallel into CurMeas

  if ForceRange > 3.0 then
    set digital ppmu TestPins to fv ForceAvg vmax 5V measure i max IRange    -- DEGLITCH related.
    set digital ppmu TestPins to fv (ForceAvg + 0.5*(ConnectV-ForceAvg))  -- DEGLITCH related. 
    wait(500us)
  endif  
---------------------------------  set digital ppmu TestPins to fv 0.9*ConnectV vmax 5V measure i max IRange    -- DEGLITCH related. 
  set digital ppmu TestPins to fv ConnectV
  disconnect digital pin TestPins from ppmu
  disable digital ppmu TestPins fv
  if ConnectToDclAtEnd then
    connect digital pin TestPins to dcl  
  endif



-----------**********************************************
----- NOTE: Need to go back this function and write from DNUT to reset LOCAL bit then used local uart to communicate with dut for setting again. it will save a lot of testtime. MT 6/2017
--------------********************************************
--  SetRelays("AllOpen")
---------power down 
  if (POWERDOWN) then
    set digital pin ALL_PATTERN_PINS - fpga_pattern_pins levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
    wait(500us)

    set hcovi SER_VDD + SER_VDD18 to fv 0V vmax 4V clamp imax 600mA imin -600mA         
    set hcovi SER_VDDIO to fv 0V   vmax 4V clamp imax 600mA imin -600mA
    wait(2ms)     -- extra for 47uF cap on SER_VDD        

  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)  
    end_if  
  for idx = 1 to sites do
    CurSite = active_sites[idx]
    for i = 1 to word(len(TestPins)) do
      ResVal[CurSite, i] = abs(Vddio / CurMeas[CurSite, i])
    endfor
  endfor      

  test_value ResVal with ResultTest

--   if RegConfigStr = "PullupGpio40k" then   -- also test LOCK pin 40k Pullup
--     test_value Res_LOCK_ERRB with Test_LOCK_ERRB
--   endif
    
end_body





procedure GmslVolVoh(Vdd,  Vdd18, Vddio, VoutTest, VoutDeltaTest,VodHTest, VcmHTest, VcmDeltaTest,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
in float           : Vdd, Vdd18, Vddio
in_out float_test  : VoutTest, VoutDeltaTest,VodHTest, VcmHTest, VcmDeltaTest   -------------VodDeltaTest,
in boolean         : POWERUP,POWERDOWN
local
  multisite float : TxPHMeas[2], TxPLMeas[2], TxNHMeas[2], TxNLMeas[2]
  multisite float : VodH[4], VodL[4], Vod[4], VodDelta[4], VcmH[4], VcmL[10], Vcm[4], VcmDelta[10],Vout[4], VoutDelta[2]
  multisite float : TxPDisMeas[2], TxNDisMeas[2], TxDis[4]
  PIN LIST[2]     : MeasVi16P, MeasVi16N
  word            : CurSite
  lword           : Reg1Value, Junk
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword  
end_local

body
  active_sites = get_active_sites
  sites = word(len(active_sites))
  
  -- setup some pin lists to make cadence statements more readable maybe move to global pin groups
    MeasVi16N =  DC_SE_M_A_VI + DC_SE_M_B_VI                 --DES_TXOUT0_N_SIOA_N_VI16+DES_TXOUT1_N_SIOB_N_VI16
    MeasVi16P =  DC_SE_P_A_VI + DC_SE_P_B_VI                 --DES_TXOUT0_P_SIOA_P_VI16+DES_TXOUT1_P_SIOB_P_VI16

    set digital pin SER_GPO4_CFG0  + SER_GPO6_CFG2 levels to vil Vconf0 vih Vddio   -- TP/UART mode with DEV_ID = 0x80
    set digital pin  SER_GPO5_CFG1 levels to vil Vconf1 vih Vddio                    ---GMSL2 mode  AND COAX
    close hcovi DC_K7 cbits
    close ovi chan COAXB_P_RELAY + COAXB_M_RELAY cbit ---Connecto DC circuit
    wait(1ms)

----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)

--        close ovi chan CB2_SLDC cbit  ---

    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!




---debug in what mode    
    RegRead(SER_ID,SR_REG6 , 1, RdWordUpper, RdWordLower, "SER_UART_Read")

----Disconnect DP from SIOA/SIOB
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from dcl
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from ppmu

  -- Setup the analog hardware that will be used to measure the LVDS output pin voltages
  set vi16 chan MeasVi16P+MeasVi16N to fi 10pA max 50mA measure v max 2V clamp vmax 2V vmin 0V
  gate vi16 chan MeasVi16P+MeasVi16N on
  connect vi16 chan MeasVi16P+MeasVi16N remote hot switch

--    RegRead(SER_ID, SR_REG6, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
--    
--    RegRead(SER_ID, SR_REG1, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
--    RegWrite(SER_ID, SR_REG1, 1, 0, 16#B, "SER_UART_Write")                                        -- Set the Transmit mode to maximum 6.0Gb to enable 410mV output levels
-- 


-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################

--WH:FOLLOWUP 
  --  Disable Outputs and measure disabled voltage prior to output tests

  RegWrite(SER_ID, SR_CTRL7, 1, 0, 16#81, "SER_UART_Write")
  wait(5ms)
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into TxPDisMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into TxNDisMeas


----
--  RegWrite(SER_ID, SR_CTRL7, 1, 0, 16#1, "SER_UART_Write")


  -- Set the GMSL I/O transmit rate and force a static 0/1
--   GetTxRateVal(6.0, 1.5, Reg1Value, Junk)                                     -- call GetTxRateVal to get proper value for Reg1Value.   GetTxRateVal(FwTransmitRate, RevTransmitRate, Rate87, Rate84)  
-- 
-- 
--   RegWrite(SER_ID, SR_REG1, 1, 0, Reg1Value, "SER_UART_Write")              -- Set the Transmit rate to maximum 6Gb to enable 410mV output levels




-- DEBUG CODE 
-- RegRead(SER_ID, SR_RLMS95_A, 1, RdWordUpper, RdWordLower, "dut_uart_read") -- check Tx swing value. multiply by 10mV to get target swing.
-- wait(0s)
-- DEBUG CODE
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################




  -- Set the outputs to logic high
  RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#29, "SER_UART_Write")
  RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#29, "SER_UART_Write")

  RegWrite(SER_ID, SR_CTRL0, 1, 0, 16#20, "SER_UART_Write")
  wait(5ms)
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into TxPHMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into TxNLMeas

  --  Set the outputs in a low state
  RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#2A, "SER_UART_Write")
  RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#2A, "SER_UART_Write")
------------------RegRead(SER_ID, SR_RLMS95_A, 1, RdWordUpper, RdWordLower, "dut_uart_read")
  wait(5ms)
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into TxPLMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into TxNHMeas

  disconnect vi16 chan MeasVi16P+MeasVi16N
  set vi16 chan MeasVi16P+MeasVi16N to fv 0V max 4V measure i max 100mA clamp imax 100mA imin -100mA
--  gate vi16 chan MeasVi16P+MeasVi16N off
  
 -----------------------
---------power down 
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
  wait(500us)
  open digital cbit    ABUS_RELAY +  MFP_LT_RELAY
  open ovi chan CB2_SLDC + CB1_SLDC cbit ---Connecto DC circuit
  open ovi chan COAXB_P_RELAY + COAXB_M_RELAY cbit
  connect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP to dcl
  open hcovi DC_K7 cbits
--  open ovi chan CB2_SLDC cbit ---
      powerdown_device(POWERDOWN)


----Datalog


  -- Calculate the VOD, VCM and complimetary differences, store into single variables or all I/O  
  -- I/O Order TXOUTA_0, TXOUTA_1, TXOUTA_2, TXOUTA_3, TXCLKA, TXOUTB_0, TXOUTB_1, TXOUTB_2, TXOUTB_3, TXCLKB
  for idx = 1 to sites do
    CurSite = active_sites[idx]
----New definition as Jon Rose spec
      Vout[CurSite, 1] = TxPHMeas[CurSite, 1] - TxPLMeas[CurSite, 1]         -- SIOA_P  same as VOD in GMSL1 previous product
      Vout[CurSite, 2] = TxNHMeas[CurSite, 1] - TxNLMeas[CurSite, 1]         -- SIOA_N
      Vout[CurSite, 3] = TxPHMeas[CurSite, 2] - TxPLMeas[CurSite, 2]         -- SIOB_P
      Vout[CurSite, 4] = TxNHMeas[CurSite, 2] - TxNLMeas[CurSite, 2]         -- SIOB_N
      
      VoutDelta[CurSite, 1] = Vout[CurSite, 1] - Vout[CurSite, 2]
      VoutDelta[CurSite, 2] = Vout[CurSite, 3] - Vout[CurSite,4]

-----      Vod = (VPH - VNL)+ (VNH-VPL) definition is changed
      Vod[CurSite, 1] = (TxPHMeas[CurSite, 1]  - TxNLMeas[CurSite, 1]) + ( TxNHMeas[CurSite, 1] - TxPLMeas[CurSite, 1] )        -- SIOA
      Vod[CurSite, 2] = (TxPHMeas[CurSite, 2]  - TxNLMeas[CurSite, 2]) + ( TxNHMeas[CurSite, 2] - TxPLMeas[CurSite, 2] )        -- SIOb


--       Vod[CurSite, 2] = TxNHMeas[CurSite, 1] - TxNLMeas[CurSite, 1]         -- SIOA_N
--       Vod[CurSite, 3] = TxPHMeas[CurSite, 2] - TxPLMeas[CurSite, 2]         -- SIOB_P
--       Vod[CurSite, 4] = TxNHMeas[CurSite, 2] - TxNLMeas[CurSite, 2]         -- SIOB_N
--       VodDelta[CurSite, 1] = Vod[CurSite, 1] - Vod[CurSite, 2]
--       VodDelta[CurSite, 2] = Vod[CurSite, 3] - Vod[CurSite,4]

      Vcm[CurSite, 1] = (TxPHMeas[CurSite, 1] + TxPLMeas[CurSite, 1])/2.0   -- SIOA_P
      Vcm[CurSite, 2] = (TxNHMeas[CurSite, 1] + TxNLMeas[CurSite, 1])/2.0   -- SIOA_N
      Vcm[CurSite, 3] = (TxPHMeas[CurSite, 2] + TxPLMeas[CurSite, 2])/2.0   -- SIOB_P
      Vcm[CurSite, 4] = (TxNHMeas[CurSite, 2] + TxNLMeas[CurSite, 2])/2.0   -- SIOB_N
      VcmDelta[CurSite, 1] = Vcm[CurSite, 1] - Vcm[CurSite, 2]  
      VcmDelta[CurSite, 2] = Vcm[CurSite, 3] - Vcm[CurSite, 4]  

--       TxDis[CurSite,1] = TxPDisMeas[CurSite,1]
--       TxDis[CurSite,2] = TxNDisMeas[CurSite,1]
--       TxDis[CurSite,3] = TxPDisMeas[CurSite,2]
--       TxDis[CurSite,4] = TxNDisMeas[CurSite,2]
   endfor

  -- Datalog Tests
  test_value Vout with VoutTest
  test_value VoutDelta with VoutDeltaTest
  test_value Vod with VodHTest
--  test_value VodDelta with VodDeltaTest
  test_value Vcm with VcmHTest
  test_value VcmDelta with VcmDeltaTest
    
end_body

procedure GetTxRateVal(FwRate, RevRate, UsrRate87, UsrRate84)
--------------------------------------------------------------------------------
in float  : FwRate, RevRate
out lword : UsrRate87, UsrRate84

body
  -- Build REG1 TX_RATE and RX_RATE values for both the 84 and 87 devices
  if FwRate = 1.5 then
    UsrRate87 = 0
    UsrRate84 = 0
  elseif FwRate = 3.0 then
    UsrRate87 = 16#4
    UsrRate84 = 16#1
  else -- Max forward rate = 6.0Gb
    UsrRate87 = 16#8
    UsrRate84 = 16#2
  endif 
  
  If RevRate = 0.1875 then
    UsrRate84 = UsrRate84 + 16#0 
    UsrRate87 = UsrRate87 + 16#0
  elseif RevRate = 0.75 then
    UsrRate84 = UsrRate84 + 16#8 
    UsrRate87 = UsrRate87 + 16#2
  elseif RevRate = 0.375 then
    UsrRate84 = UsrRate84 + 16#4 
    UsrRate87 = UsrRate87 + 16#1
  else  -- Max reverse rate = 1.5Gb
    UsrRate84 = UsrRate84 + 16#C 
    UsrRate87 = UsrRate87 + 16#3
  endif
end_body

procedure Rise_Fall_Rx_Tx(Vdd,Vdd18,Vddio, rx_fall_ft, tx_fall_ft, rx_rise_ft, tx_rise_ft,POWERUP,POWERDOWN )
--------------------------------------------------------------------------------
--  
in float            : Vdd,Vdd18,Vddio
in_out float_test   : rx_fall_ft, tx_fall_ft, rx_rise_ft, tx_rise_ft
in boolean          : POWERUP, POWERDOWN

local

    multisite float   : rx_fall, rx_rise, tx_fall, tx_rise
    multisite boolean : time_out
    

    multisite lword   : lowword, upperword
    word              : site, idx
    word list[MAX_SITES]   : active_sites
   
end_local

body

   get_expr("OpVar_Char", CHAR)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

   --POWER_CONNECT    -- need this for reseting device
    --make sure RSVD pin float (HVVI disconnect)
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!

-----Dut power up function
    DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
 
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device, to comply with check list
    wait(200us)
------Make all output swing low
    SetTestMode(1, False, "SER_UART_Write")

----Setup to measure fall time----------------------------------------
-----Close relays to pull up 1kohm

    close digital cbit RXTX_K1          -------------CONNECT 1K PULLUP 
    wait(4ms)
------------ Set Pin Levels ----------------------
    set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL modes to driver off load off
    set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL levels to vol 0.3*Vddio voh 0.7*Vddio iol 0mA ioh -0mA vref 0.0-----RXSDA AND TXSCL no drive pullup


    for idx = 1 to sites do 
        site = active_sites[idx]
---switch to RX pin         
            deactivate site active_sites
            activate site site
            set digital tmu SER_GPIO19_RXSDA  on site site fx1 to measure fall time     
            set digital tmu fx1 to arm immediately
            start digital tmu fx1
            set digital pin SER_PWDNB fx1 driver preset low  ------- enable testing of I2C I/O in output mode; SCL and SDA low
            wait for digital tmu fx1 timeout 1ms into time_out    
            read digital tmu SER_GPIO19_RXSDA fx1 measurements into rx_fall ---- one at a time
            wait(0ms)
---switch to TX pin 
            set digital pin SER_PWDNB fx1 driver preset high  ----- return SDA and SCL back to UART or I2C mode
            wait(20us)
            set digital tmu SER_GPIO20_TXSCL on site site   fx1 to measure fall time
            set digital tmu fx1 to arm immediately
            start digital tmu fx1
            wait(3uS)
            set digital pin SER_PWDNB fx1 driver preset low  ------- enable testing of I2C I/O in output mode; SCL and SDA low
            wait for digital tmu fx1 timeout 1ms into time_out   
            read digital tmu SER_GPIO20_TXSCL fx1 measurements into tx_fall ---- one at a time
            wait(0ms)
---Switch to measure rise time
            set digital pin SER_PWDNB fx1 driver preset low  ----- return SDA and SCL back to UART or I2C mode
            wait(20us)
------ ------Make all output swing high
            set digital tmu SER_GPIO19_RXSDA  on site site fx1 to measure rise time
            set digital tmu fx1 to arm immediately
            start digital tmu fx1
            set digital pin SER_PWDNB fx1 driver preset high  ----- return SDA and SCL to high
            wait for digital tmu fx1 timeout 1ms into time_out    
            read digital tmu SER_GPIO19_RXSDA fx1 measurements into rx_rise                        ---- one at a time
            wait(0ms)

            set digital pin SER_PWDNB fx1 driver preset low  ----- return SDA and SCL back to UART or I2C mode
            wait(20us)
------ ------Make all output swing high
            set digital tmu  SER_GPIO20_TXSCL  on site site fx1 to measure rise time
            set digital tmu fx1 to arm immediately
            start digital tmu fx1
            wait(20us)
            set digital pin SER_PWDNB fx1 driver preset high  ----- return SDA and SCL to high
            wait for digital tmu fx1 timeout 1ms into time_out    
            read digital tmu SER_GPIO20_TXSCL fx1 measurements into tx_rise                        ---- one at a time
            wait(0ms)

    end_for 
        activate site active_sites
----Power down
    open digital cbit RXTX_K1          -------------CONNECT 1K PULLUP 
    set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL + SER_PWDNB modes to driver pattern 
    set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL modes to driver pattern load on
    powerdown_device(POWERDOWN)
    wait(4ms)
  test_value rx_fall with rx_fall_ft
  test_value tx_fall with tx_fall_ft
  test_value rx_rise with rx_rise_ft
  test_value tx_rise with tx_rise_ft

end_body

procedure Rise_Fall_Rx_Tx_FT(Vdd,Vdd18,Vddio, rx_fall_ft, tx_fall_ft, rx_rise_ft, tx_rise_ft,POWERUP,POWERDOWN )
--------------------------------------------------------------------------------
--  
in float          : Vdd,Vdd18,Vddio
in_out float_test : rx_fall_ft, tx_fall_ft, rx_rise_ft, tx_rise_ft
in boolean          : POWERUP, POWERDOWN


local
    multisite lword   : lowword, upperword
    word              : site, idx ,i
    word list[MAX_SITES]   : active_sites

    multisite word      : cap_0p30_rx_tx[256], cap_0p30_tx[256],cap_0p70_rx_tx[256], cap_0p70_tx[256], i2
    multisite boolean   : time_out,rf_timeout   
    multisite float     : rx_rise_70, rx_rise_30, rx_fall_70, rx_fall_30, tx_rise_70, tx_rise_30, tx_fall_70, tx_fall_30 
    multisite float     : rx_fall, rx_rise, tx_fall, tx_rise, rx, tx
    boolean             : method1
   multisite lword      : fail_count_fall_low_0p3[2],fail_count_fall_low_0p7[2],fail_count_rise_high_0p3[2],fail_count_rise_high_0p7[2]
end_local

body

---Still not decide with method to use MT 7/2017
    method1 =  true----false ---true----
---------------------------------------------------------------------
    active_sites = get_active_sites
    sites = word(len(active_sites))  

   --POWER_CONNECT    -- need this for reseting device
    --make sure RSVD pin float (HVVI disconnect)
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!

-----Dut power up function
    DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
 
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device, to comply with check list
    wait(200us)
------Make all output swing low
    SetTestMode(1, False, "SER_UART_Write")

----Setup to measure fall time----------------------------------------
-----Close relays to pull up 1kohm

    close digital cbit RXTX_K1          -------------CONNECT 1K PULLUP 
    wait(4ms)
------------ Set Pin Levels ----------------------
    set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL modes to driver off load off
    set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL  modes to comparator enable all fails --------?????? should be disable all failed
    set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL levels to vol 0.3*Vddio voh 0.3*Vddio iol 0mA ioh -0mA vref 0.0-----RXSDA AND TXSCL no drive pullup
    wait(1ms)

    if method1 then
------In calculation, multiply by 2 because RXSDA/TXSCL using DP(FX1) in EX2 mode. if these 2 are HS pins then don't need to time by 2.0----Man Tran 7/2017

---Fall time
        execute digital pattern "Rise_Fall_FT"  at label "GO_LOW"  override fails ---run to end --dlog
--        wait for digital capture fx1 waveform "cap_0p30" timeout 2s into rf_timeout  -- false = timeout
        read digital pattern SER_GPIO19_RXSDA + SER_GPIO20_TXSCL fail count into fail_count_fall_low_0p3

        set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL levels to vol 0.7*Vddio voh 0.7*Vddio iol 0mA ioh -0mA vref 0.0-----RXSDA AND TXSCL no drive pullup
        execute digital pattern "Rise_Fall_FT"  at label "GO_LOW" override fails----run to end --dlog
        read digital pattern SER_GPIO19_RXSDA + SER_GPIO20_TXSCL fail count into fail_count_fall_low_0p7

------Rise time
        
        execute digital pattern "Rise_Fall_FT"  at label "GO_HIGH"  override fails ---run to end --dlog
        read digital pattern SER_GPIO19_RXSDA + SER_GPIO20_TXSCL fail count into fail_count_rise_high_0p7

        set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL levels to vol 0.3*Vddio voh 0.3*Vddio iol 0mA ioh -0mA vref 0.0-----RXSDA AND TXSCL no drive pullup
        execute digital pattern "Rise_Fall_FT"  at label "GO_HIGH" override fails----run to end --dlog
        read digital pattern SER_GPIO19_RXSDA + SER_GPIO20_TXSCL fail count into fail_count_rise_high_0p3

        for idx = 1 to sites do
            site = active_sites[idx]
            rx_rise[site] = (float(fail_count_rise_high_0p7[site,1] - fail_count_rise_high_0p3[site,1]) * 5ns)*2.0     ---RX
            rx_fall[site] = (float(fail_count_fall_low_0p3[site,1] - fail_count_fall_low_0p7[site,1]) * 5ns)*2.0       ---RX
            tx_rise[site] = (float(fail_count_rise_high_0p7[site,2] - fail_count_rise_high_0p3[site,2]) * 5ns)*2.0      ---TX
            tx_fall[site] = (float(fail_count_fall_low_0p3[site,2] - fail_count_fall_low_0p7[site,2]) * 5ns)*2.0        ---TX

    end_for
    else

-- -- -- - -- **************** RX/TX 0p30 Measure
   	       enable digital capture fx1 waveform "cap_0p30"

   	       execute digital pattern "Rise_Fall_FT"  run to end --dlog
   	      
   	       wait for digital capture fx1 waveform "cap_0p30" timeout 2s into rf_timeout  -- false = timeout
   	       read digital capture fx1 waveform "cap_0p30" into cap_0p30_rx_tx

-- -- -- -- -- **************** RX/TX 0p70 Measure
   	       set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL levels to vol 0.7*Vddio voh 0.7*Vddio iol 0mA ioh -0mA vref 0.0
   	       wait(1ms)
   					  
   	       enable digital capture fx1 waveform "cap_0p70"

   	       execute digital pattern "Rise_Fall_FT"  run to end --dlog  --at label "TP" wait

   	       wait for digital capture fx1 waveform "cap_0p70" timeout 2s into rf_timeout  -- false = timeout
   	       read digital capture fx1 waveform "cap_0p70" into cap_0p70_rx_tx  

   		-- Note: The RX data is the MSB bit
   		
   		--**********************FALL TIME post process*****************************************
   		
   		    for idx = 1 to sites do
   			site = active_sites[idx]
   			    for i = 1 to 128 do   
   				if  cap_0p30_rx_tx[site,i] = 2#00  then
   				    if  (tx[site] = 0.0 AND  rx[site] = 0.0) then
   					rx_fall_30[site] =   float(i)*5.0ns 
   					tx_fall_30[site] =   float(i)*5.0ns
   				    else_if (tx[site] = 0.0) then
   					tx_fall_30[site] =   float(i)*5ns
   				    else_if (rx[site] = 0.0) then
   					rx_fall_30[site] =   float(i)*5ns			   
   				    end_if 
   				    break			 
   				else_if cap_0p30_rx_tx[site,i] = 2#01  and tx_fall_30[site] = 0.0 then
   				    tx_fall_30[site] =   float(i)*5.0ns 
   				    rx[site] = 0.0
   				    tx[site] = 1.0
   				else_if cap_0p30_rx_tx[site,i] = 2#10 and tx_fall_30[site] = 0.0 then
   				    rx_fall_30[site] =   float(i)*5.0ns 
   				    rx[site] = 1.0
   				    tx[site] = 0.0
   				end_if
   				
   				if i=128 then
   				    tx_fall_30[site] = 1.0
   				    rx_fall_30[site] = 1.0
   				    i2[site] = i
   				end_if    
   			    end_for
   		    end_for

   		     

--*--*--*--*--*************************************************************** 
   		
   		    rx = 0.0
   		    tx = 0.0
   		    for idx = 1 to sites do
   			site = active_sites[idx]
   			    for i = 1 to 128 do   
   				if  cap_0p70_rx_tx[site,i] = 2#00  then 
   				    if  (tx[site] = 0.0 AND  rx[site] = 0.0) then
   					rx_fall_70[site] =   float(i)*5ns 
   					tx_fall_70[site] =   float(i)*5ns
   				    else_if (tx[site] = 0.0) then
   					tx_fall_70[site] =   float(i)*5ns
   				    else_if (rx[site] = 0.0) then
   					rx_fall_70[site] =   float(i)*5ns			    
   				    end_if	  
   				    break			 
   				else_if cap_0p70_rx_tx[site,i] = 2#01  and tx_fall_70[site] =0.0 then
   				    tx_fall_70[site] =   float(i)*5ns 
   				    rx[site] = 0.0
   				    tx[site] = 1.0
   				else_if cap_0p70_rx_tx[site,i] = 2#10  and tx_fall_70[site] =0.0 then
   				    rx_fall_70[site] =   float(i)*5ns 
   				    rx[site] = 1.0
   				    tx[site] = 0.0
   				end_if
   				
   				if i=128 then
   				    tx_fall_70[site] = 2.0
   				    rx_fall_70[site] = 2.0
   				    i2[site] = i
   				end_if  			  
   			    end_for
   		    end_for


   		    

--*--*--*--*--********************************RISE TIME post process******************************************

   		     rx = 0.0
   		     tx = 0.0	    
   		     for idx = 1 to sites do
   			site = active_sites[idx]
   			    for i = 129 to 256 do   
   				if  cap_0p30_rx_tx[site,i] = 2#11  then
   				    if  (tx[site] = 0.0 AND  rx[site] = 0.0) then
   					rx_rise_30[site] =   float(i)*5ns 
   					tx_rise_30[site] =   float(i)*5ns
   				    else_if (tx[site] = 0.0) then
   					tx_rise_30[site] =   float(i)*5ns
   				    else_if (rx[site] = 0.0) then
   					rx_rise_30[site] =   float(i)*5ns			 
   				    end_if 
   				    break			 
   				else_if cap_0p30_rx_tx[site,i] = 2#10  and rx_rise_30[site] <> 0.0 then
   				    rx_rise_30[site] =   float(i)*5ns 
   				    rx[site] = 1.0
   				    tx[site] = 0.0
   				else_if cap_0p30_rx_tx[site,i] = 2#01 and tx_rise_30[site] <> 0.0 then
   				    tx_rise_30[site] =   float(i)*5ns 
   				    rx[site] = 0.0
   				    tx[site] = 1.0
   				end_if
   				
   				if i=256 then
   				    tx_rise_30[site] = 1.0
   				    rx_rise_30[site] = 1.0
   				    i2[site] = i
   				end_if  							
   			    end_for
   		    end_for

   	     
   		   
   		   
 -- -- -- -- --*********************************************************************************************

   		     rx = 0.0
   		     tx = 0.0		
   		    rx_rise_70 =0.0
   		    tx_rise_70 = 0.0
   		     for idx = 1 to sites do
   			site = active_sites[idx]
   			    for i = 129 to 256 do   
   				if  cap_0p70_rx_tx[site,i] = 2#11  then 
   				    if  (tx[site] = 0.0 AND  rx[site] = 0.0) then
   					rx_rise_70[site] =   float(i)*5ns 
   					tx_rise_70[site] =   float(i)*5ns
   				    else_if (tx[site] = 0.0) then
   					tx_rise_70[site] =   float(i)*5ns
   				    else_if (rx[site] = 0.0) then
   					rx_rise_70[site] =   float(i)*5ns			 
   				    end_if					       
   				    break			 
   				else_if (cap_0p70_rx_tx[site,i] = 2#10)  and (rx_rise_70[site] = 0.0) then
   				    rx_rise_70[site] =   float(i)*5ns 
   				    rx[site] = 1.0
   				    tx[site] = 0.0
   				else_if cap_0p70_rx_tx[site,i] = 2#01 and tx_rise_70[site] = 0.0then
   				    tx_rise_70[site] =   float(i)*5ns 
   				    rx[site] = 0.0
   				    tx[site] = 1.0 
   				end_if
   				
   				if i=256 then
   				    tx_rise_70[site] = 2.0
   				    rx_rise_70[site] = 2.0
   				    i2[site] = i
   				end_if  				    
   			    end_for
   		    end_for

        for idx = 1 to sites do
            site = active_sites[idx]

            rx_rise[site] = rx_rise_70[site] - rx_rise_30[site]
            rx_fall[site] = rx_fall_30[site] - rx_fall_70[site]
            tx_rise[site] = tx_rise_70[site] - tx_rise_30[site]
            tx_fall[site] = tx_fall_30[site] - tx_fall_70[site]

        end_for
    end_if ---- Method1

----Power down
    open digital cbit RXTX_K1          -------------CONNECT 1K PULLUP 
    set digital pin SER_GPIO19_RXSDA + SER_GPIO20_TXSCL modes to driver pattern 
    powerdown_device(POWERDOWN)
    wait(4ms) 
   


------------ Datalog Results ---------------------
  test_value rx_fall with rx_fall_ft
  test_value tx_fall with tx_fall_ft
  test_value rx_rise with rx_rise_ft
  test_value tx_rise with tx_rise_ft



end_body
procedure GmslVolVoh_gmsl1(Vdd,  Vdd18, Vddio, VoutTest,VoutDeltaTest,VosCoaxTest,VosCoaxDeltaTest,VodHTest, VcmHTest, VcmDeltaTest,GMSL1,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
in float                : Vdd, Vdd18, Vddio
in_out float_test       : VoutTest,VoutDeltaTest,VosCoaxTest,VosCoaxDeltaTest,VodHTest,  VcmHTest, VcmDeltaTest
in boolean              : POWERUP,POWERDOWN
in_out integer_test     : GMSL1

local
  multisite float : TxPHMeas[2], TxPLMeas[2], TxNHMeas[2], TxNLMeas[2]
  multisite float : VodH[4], VodL[4], Vod[4], VodDelta[4], VcmH[4], VcmL[10], Vcm[4], VcmDelta[10],Vout[2],VoutDelta,VosCoax[2],VosCoaxDelta
  multisite float : TxPH_1Meas[2], TxPL_1Meas[2], TxNH_1Meas[2], TxNL_1Meas[2]
  multisite float : TxPDisMeas[2], TxNDisMeas[2], TxDis[4]
  PIN LIST[2]     : MeasVi16P, MeasVi16N
  word            : CurSite
  lword           : Reg1Value, Junk
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword  
  word              : sites, idx, site
  multisite integer : reg_val 
  multisite lword   : reg_val_des

end_local

body
  active_sites = get_active_sites
  sites = word(len(active_sites))
  
  -- setup some pin lists to make cadence statements more readable maybe move to global pin groups
    MeasVi16N =  DC_SE_M_A_VI + DC_SE_M_B_VI                 --DES_TXOUT0_N_SIOA_N_VI16+DES_TXOUT1_N_SIOB_N_VI16
    MeasVi16P =  DC_SE_P_A_VI + DC_SE_P_B_VI                 --DES_TXOUT0_P_SIOA_P_VI16+DES_TXOUT1_P_SIOB_P_VI16

    set digital pin SER_GPO4_CFG0  + SER_GPO6_CFG2 levels to vil Vconf0 vih Vddio   -- TP/UART mode with DEV_ID = 0x80
    set digital pin  SER_GPO5_CFG1 levels to vil Vconf1 vih Vddio                    ---GMSL2 mode  AND COAX
    close cbit DC_K7 
    close cbit COAXB_P_RELAY + COAXB_M_RELAY  ---Connecto DC circuit
    wait(1ms)

----Dut power up function
--   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL1",POWERUP) ---Set link to GMSL1
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "COAX_GMSL1",POWERUP) ---Set link to GMSL1 
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!


-----debug in what mode    
    RegRead(SER_ID,SR_REG6 , 1, RdWordUpper, RdWordLower, "SER_UART_Read")-----GMSL1 then read back = 0xb and GMSL2 then 0x8b
----Turn on GMSL1 link mode
    RegWrite(SER_ID, SR_GMSL1_4, 1, 0, 16#40, "SER_UART_Write")

    for idx = 1 to sites do
        site = active_sites[idx]
        reg_val[site]  = (integer(RdWordLower[site])  & 0x80) >> 7   
    end_for 


----Disconnect DP from SIOA/SIOB
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from dcl
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from ppmu

  -- Setup the analog hardware that will be used to measure the LVDS output pin voltages
  set vi16 chan MeasVi16P+MeasVi16N to fi 10pA max 50mA measure v max 2V clamp vmax 2V vmin 0V
  gate vi16 chan MeasVi16P+MeasVi16N on
  connect vi16 chan MeasVi16P+MeasVi16N remote hot switch


--WH:FOLLOWUP 
  --  Disable Outputs and measure disabled voltage prior to output tests
 
  --RegWrite(SER_ID, SR_CTRL7, 1, 0, 16#81, "SER_UART_Write")                         ---For GMSL1 mode, need to set bit 7 = 1 Man Tran 7/2017
 

  RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#29, "SER_UART_Write")
  RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#29, "SER_UART_Write")
  wait(1ms)---5ms
 
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into TxPDisMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into TxNDisMeas

  -- Set the outputs to logic high
  RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#29, "SER_UART_Write")
--  RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#29, "SER_UART_Write")

  RegWrite(SER_ID, SR_CTRL0, 1, 0, 16#20, "SER_UART_Write")   ---Doesnot make any difference
  wait(1ms)---5ms
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into TxPHMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into TxNLMeas

  --  Set the outputs in a low state
  RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#2A, "SER_UART_Write")
  RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#2A, "SER_UART_Write")
------------------RegRead(SER_ID, SR_RLMS95_A, 1, RdWordUpper, RdWordLower, "dut_uart_read")
  wait(1ms)---5ms
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into TxPLMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into TxNHMeas

-----------------------Done with coax mode now swith to Tp mode

    RegRead(SER_ID,SR_CTRL1 , 1, RdWordUpper, RdWordLower, "SER_UART_Read") -----Check for Coax or Tp
    RegWrite(SER_ID, SR_CTRL1, 1, 0, 16#0A, "SER_UART_Write")
  wait(1ms)---5ms

    measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into TxPL_1Meas
    measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into TxNH_1Meas

    RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#29, "SER_UART_Write")
--    RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#29, "SER_UART_Write")
  wait(1ms)---5ms
    measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into TxPH_1Meas
    measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into TxNL_1Meas
  disconnect vi16 chan MeasVi16P+MeasVi16N
  set vi16 chan MeasVi16P+MeasVi16N to fv 0V max 4V measure i max 100mA clamp imax 100mA imin -100mA
--  gate vi16 chan MeasVi16P+MeasVi16N off
  
 -----------------------
---------power down 
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
  wait(500us)
  open  cbit    ABUS_RELAY +  MFP_LT_RELAY
  open cbit CB2_SLDC + CB1_SLDC  ---Connecto DC circuit
  open cbit COAXB_P_RELAY + COAXB_M_RELAY 
  connect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP to dcl
  open hcovi DC_K7 cbits

      powerdown_device(POWERDOWN)


----Datalog


  -- Calculate the VOD, VCM and complimetary differences, store into single variables or all I/O  
  -- I/O Order TXOUTA_0, TXOUTA_1, TXOUTA_2, TXOUTA_3, TXCLKA, TXOUTB_0, TXOUTB_1, TXOUTB_2, TXOUTB_3, TXCLKB
  for idx = 1 to sites do
    CurSite = active_sites[idx]
        Vout[CurSite, 1] = TxPHMeas[CurSite, 1] - TxPLMeas[CurSite, 1]         -- SIOA_P
        Vout[CurSite, 2] = TxNHMeas[CurSite, 1] - TxNLMeas[CurSite, 1]         -- SIOA_N
        VoutDelta[CurSite] = Vout[CurSite, 1] - Vout[CurSite, 2]               ----Delta Vo
        VosCoax[CurSite, 1] = (TxPHMeas[CurSite, 1] + TxPLMeas[CurSite, 1])/2.0   -- SIOA_P Vos
        VosCoax[CurSite, 2] = (TxNHMeas[CurSite, 1] + TxNLMeas[CurSite, 1] )/2.0   -- SIOA_N Vos
        VosCoaxDelta[CurSite] = VosCoax[CurSite, 1] - VosCoax[CurSite, 2]           ------DeltaVos Coax
        Vod[CurSite, 1] = (TxPH_1Meas[CurSite, 1] -  TxNL_1Meas[CurSite, 1])+( TxNH_1Meas[CurSite, 1] -TxPL_1Meas[CurSite, 1])         -- SIOA_VOD
        Vcm[CurSite, 1] = (TxPH_1Meas[CurSite, 1] + TxPL_1Meas[CurSite, 1])/2.0   -- SIOA_P
        Vcm[CurSite, 2] = (TxNH_1Meas[CurSite, 1] + TxNL_1Meas[CurSite, 1])/2.0   -- SIOA_N
       VcmDelta[CurSite, 1] = Vcm[CurSite, 1] - Vcm[CurSite, 2]  
--       Vod[CurSite, 1] = TxPHMeas[CurSite, 1] - TxPLMeas[CurSite, 1]         -- SIOA_P
--       Vod[CurSite, 2] = TxNHMeas[CurSite, 1] - TxNLMeas[CurSite, 1]         -- SIOA_N

--       Vod[CurSite, 3] = TxPHMeas[CurSite, 2] - TxPLMeas[CurSite, 2]         -- SIOB_P
--       Vod[CurSite, 4] = TxNHMeas[CurSite, 2] - TxNLMeas[CurSite, 2]         -- SIOB_N
--       VodDelta[CurSite, 1] = (TxPH_1Meas[CurSite, 1] -  TxPL_1Meas[CurSite, 1])-( TxNH_1Meas[CurSite, 1] -TxNL_1Meas[CurSite, 1])         -- DeltaVod
        VodDelta[CurSite, 1] = (TxPH_1Meas[CurSite, 1] -  TxNL_1Meas[CurSite, 1])-( TxNH_1Meas[CurSite, 1] -TxPL_1Meas[CurSite, 1])         --- DeltaVod
--       VodDelta[CurSite, 2] = Vod[CurSite, 3] - Vod[CurSite,4]
-- 
--       Vcm[CurSite, 1] = (TxPHMeas[CurSite, 1] + TxPLMeas[CurSite, 1])/2.0   -- SIOA_P
--       Vcm[CurSite, 2] = (TxNHMeas[CurSite, 1] + TxNLMeas[CurSite, 1])/2.0   -- SIOA_N
--       Vcm[CurSite, 3] = (TxPHMeas[CurSite, 2] + TxPLMeas[CurSite, 2])/2.0   -- SIOB_P
--       Vcm[CurSite, 4] = (TxNHMeas[CurSite, 2] + TxNLMeas[CurSite, 2])/2.0   -- SIOB_N
--       VcmDelta[CurSite, 1] = Vcm[CurSite, 1] - Vcm[CurSite, 2]  
--       VcmDelta[CurSite, 2] = Vcm[CurSite, 3] - Vcm[CurSite, 4]  

   endfor

  -- Datalog Tests
    test_value Vout with VoutTest
--    test_value VoutDelta with VoutDeltaTest   ---- No need to datalog deltaVout
    test_value VodDelta with VoutDeltaTest      ---- No need to datalog deltaVod

    test_value VosCoax with VosCoaxTest 
    test_value VosCoaxDelta with VosCoaxDeltaTest
----------Tp mode
    test_value Vod with VodHTest
    test_value Vcm with VcmHTest
   test_value VcmDelta with VcmDeltaTest
  test_value reg_val with GMSL1
end_body

procedure FeedBack_1lane_LoopTest(vcore, vio, v18, devid_it, dnutid_it, ser_lock_it, des_lock_it, bad_pat_it, good_pat_it, lbdone,POWERUP,POWERDOWN)

--------------------------------------------------------------------------------
in float            : vcore, vio, v18
in_out integer_test : lbdone
in_out integer_test : devid_it, dnutid_it, bad_pat_it, good_pat_it, ser_lock_it, des_lock_it
in boolean        : POWERUP,POWERDOWN

local



  multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
 
end_local


body
  

    LBDONE = 0  -- need initialize to fail first

    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
   DutPowerUp(vio, v18, vcore, "UART", "COAX_GMSL2",POWERUP)

 --   RegRead(SER_ID, 0x18, 1, upperword, lowword,"SER_UART_Read")
--     RegWrite(SER_ID, 0x18, 1, 0xE0, 0xe0, "SER_UART_Write") 
    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val[site]  = integer(lowword[site]) 
    end_for 
 
---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY

--  CRYSTAL running now, we should have LOCK on DES site???
--  Answer is NO on rev1 device (bug), but should be fixed on rev2 device  
    
    hizdel_reg_val = fpga_read_register("FPGA1", HIZDEL_REG)       -- should read back decimal 6000 if FPGA working OK
    wait(0ms)
    
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(0ms)


--  Power up DES (HS92/MAX96912E)   
    set ovi chan DNUT_VDD to fv 1.2V measure i max 500mA clamp imax 500mA imin -500mA   
    set hcovi  DNUT_VTERM to fv 1.2V measure i max 500mA clamp imax 500mA imin -500mA
    wait(1ms)
    connect ovi chan  DNUT_VDD remote
    connect hcovi  DNUT_VTERM remote
    wait(3ms)
    gate ovi chan DNUT_VDD on
    gate hcovi DNUT_VTERM on
    wait(3ms)
    
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
    fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
    wait(6ms)
    
    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg
    wait(0ms)
      
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read    
    wait(200us)
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val0[site]  = integer(reg_val0[site]) 
    end_for     
    
 ---------close CSI feedback loop
 close cbit  FB_RELAY

--     -- Read SER regs for debugging
--     RegRead(SER_ID, 16#11, 1, upperword, lowword,"SER_UART_Read")   -- 0x0A for TP    
--     RegRead(SER_ID, 16#06, 1, upperword, lowword,"SER_UART_Read")   -- 0x8F for UART/GMSL2 
--     RegRead(SER_ID, 16#01, 1, upperword, lowword,"SER_UART_Read")   -- 0x08 for TX/RX rate
--     RegRead(SER_ID, 16#10, 1, upperword, lowword,"SER_UART_Read")   -- 0x01 for default
--     RegRead(SER_ID, 16#17, 1, upperword, lowword,"SER_UART_Read")   -- 0x01 for default   
--     wait(0ms)  
--     
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x11, 1)   -- 0x0A for TP     
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x06, 1)   -- 0x8F for UART/GMSL2 
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x01, 1)   -- 0x02 for TX/RX rate
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x10, 1)   -- 0x11 for default
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x17, 1)   -- 0x01 for default
--     wait(0ms)

-------Set this to 3 GB
    -- now setup SER/DES link to 3G if we are in TP mode.  COAX mode up to 6G -------
--     RegWrite(SER_ID, 16#01, 1, 16#04, 16#04, "SER_UART_Write")
--     wait(200us)         
--     fpga_UART_Write("FPGA1","DES", DESA_ID, 16#01, 1, 0x01)
--     wait(200us)  
--       
--     --RegRead(SER_ID, 16#01, 1, upperword, lowword,"SER_UART_Read")      -- verify write above before updated, 0x04      
--     --des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x01, 1)      -- verify write above before updated, 0x01    
--                
--     -- write Reg0x10 to update link speed to 3G
--     RegWrite(SER_ID, 16#10, 1, 16#21, 16#21, "SER_UART_Write")
--     wait(200us)        
--     RegRead(SER_ID, 16#10, 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)
--     fpga_UART_Write("FPGA1","DES", DESA_ID, 16#10, 1, 0x21)
--     wait(200us)
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x10, 1)      -- self adjust back to 0x01(default)
------------------    
--     RegRead(SER_ID, 16#95, 1, upperword, lowword,"SER_UART_Read")        -- verify before  
--     RegWrite(SER_ID, 16#95, 1, 16#E3, 16#E3, "SER_UART_Write")           -- increase SER TX amplitude to 600mV from 400mV(default)
--     RegRead(SER_ID, 16#95, 1, upperword, lowword,"SER_UART_Read")        -- verify
--     
--     RegRead(SER_ID, 16#1495, 1, upperword, lowword,"SER_UART_Read")      -- verify before  
--     RegWrite(SER_ID, 16#1495, 1, 16#E3, 16#E3, "SER_UART_Write")         -- increase SER TX amplitude to 600mV from 400mV(default)
--     RegRead(SER_ID, 16#1495, 1, upperword, lowword,"SER_UART_Read")      -- verify
--      
--     RegRead(SER_ID, 16#1595, 1, upperword, lowword,"SER_UART_Read")      -- verify before  
--     RegWrite(SER_ID, 16#1595, 1, 16#E3, 16#E3, "SER_UART_Write")         -- increase SER TX amplitude to 600mV from 400mV(default)
--     RegRead(SER_ID, 16#1595, 1, upperword, lowword,"SER_UART_Read")      -- verify    
    -------------------------------------------------------------

 

--------------This section is for 6GHz link and it is only works with coax mode    
--     wait(0ms)
--     ----------------------------------------------------------------     
      
    -- change to COAX mode for 6G link ---------------
    RegWrite(SER_ID, 16#11, 1, 16#0F, 16#0F, "SER_UART_Write")
    RegWrite(SER_ID, 16#01, 1, 16#08, 16#08, "SER_UART_Write")             
    fpga_UART_Write("FPGA1","DES", DESA_ID, 16#11, 1, 0x0F)    -- coax
    fpga_UART_Write("FPGA1","DES", DESA_ID, 16#01, 1, 0x02)    -- 6G rate    
    wait(500us)  
      
    RegRead(SER_ID, 16#11, 1, upperword, lowword,"SER_UART_Read")      -- verify write above before updated, 0x0F      
    des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x11, 1)      -- verify write above before updated, 0x0F
    
    -- write Reg0x10 to update to COAX mode
    RegWrite(SER_ID, 16#10, 1, 16#21, 16#21, "SER_UART_Write") 
            
    RegRead(SER_ID, 16#10, 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)
    fpga_UART_Write("FPGA1","DES", DESA_ID, 16#10, 1, 0x21)
    des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x10, 1)      -- self adjust back to 0x01
    wait(0ms)
     
    
----------Changing amplitude    
--     --RegRead(SER_ID, 16#95, 1, upperword, lowword,"SER_UART_Read")      -- verify before  
--     --RegWrite(SER_ID, 16#95, 1, 16#E3, 16#E3, "SER_UART_Write")         -- increase SER TX amplitude to 600mV from 400mV(default)
--     --RegRead(SER_ID, 16#95, 1, upperword, lowword,"SER_UART_Read")      -- verify
--        
--     --RegWrite(SER_ID, 16#1495, 1, 16#E3, 16#E3, "SER_UART_Write")         -- increase SER TX amplitude to 600mV from 400mV(default)
--     --RegWrite(SER_ID, 16#1595, 1, 16#E3, 16#E3, "SER_UART_Write")
--             
--     -- close termination relay at negative SL
--     close cbit CB2_SLDC                 --OVI_RELAYS 
--     close cbit COAXB_M_RELAY            --OVI_RELAYS
--     --wait(5ms)        
--     -------------------------------------------------------------    
    
       

   --DES setup, has to write locally with another crystal running on DES site for REV1 device       
   --fpga_UART_Write("FPGA1","DES", DESA_ID, 16#14A7, 1, 0x00)
   --reg_val13  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x14A7, 1)    
   --fpga_UART_Write("FPGA1","DES", DESA_ID, 16#15A7, 1, 0x00)
   --reg_val14  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x15A7, 1) -- enough for DES (mpw1) setup for link 
     --des_read   = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x14A4, 1) -- AEQ on check (by default = 0xBD)
     --fpga_UART_Write("FPGA1","DES", DESA_ID, 16#14A4, 1, 0x00)
     --des_read   = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x14A4, 1) -- AEQ off (0x00)
     
   -- debug 6 Gig link
   --reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x1B, 1)   -- 0x00 is good 
   --reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x1D, 1)   -- 0x00 is good 
   --reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x1F, 1)   -- 0x00 is good 
   --reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x22, 1)   -- 0x00 is good     

   wait(80ms)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!

   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xDA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xDA expected   
   wait(0ms)
   
   for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val1[site]  = integer(lowword[site])
      ireg_val15[site] = integer(reg_val15[site])      
   end_for    



   -------------------------DO NOT DELETE, DEBUGGING-------------------------
   -- try to read across the link to SER from DNUT using FPGA, FPGA timeout for read back is hardcode to 128uS
   des_read =  fpga_UART_Read("FPGA1", "DES", SER_ID, 0x00, 1)      -- SER_ID read from DNUT UART mode, expect 0x80
   wait(0ms)
   --fpga_set_UART_Frequency("FPGA1", 100KHz)
   --wait(0ms)
   --RegWrite(SER_ID, 16#06, 1, 16#9F, 16#9F, "SER_UART_Write")      --  for I2C mode if want using
   --fpga_UART_Write("FPGA1","DES", DESA_ID, 16#06, 1, 16#9E)
   --des_read =  fpga_I2C_Read("FPGA1", "DES", SER_ID, 0x00, 1)     -- SER_ID read from DNUT I2C mode, expect 0x80.  I2C accross link works OK
   -------------------------------------------------------------------------



  -- setup SER/DES for loopback test here
   
  --RegWrite(DevId, RegAddr, ByteCnt, DataUpperWord, DataLowerWord, PatternName)

  --RegWrite(SER_ID, 16#06, 1, 16#9F, 16#9F, "SER_UART_Write")      --  for I2C mode if want using 
  --wait(200us)  
  --RegWrite(SER_ID, 16#01, 1, 16#08, 16#08, "SER_UART_Write")      --  for 6G link setup if link working at 6G 
  --wait(200us)    
  RegWrite(SER_ID, 16#0370, 1, 16#08, 16#08, "SER_UART_Write")    -- 
  wait(200us) 
  RegWrite(SER_ID, 16#0371, 1, 16#02, 16#02, "SER_UART_Write")    -- 
  wait(200us) 
  RegWrite(SER_ID, 16#0372, 1, 16#02, 16#02, "SER_UART_Write")    -- 
  wait(200us)
  RegWrite(SER_ID, 16#0331, 1, 16#00, 16#00, "SER_UART_Write")    -- 1 lane enable      
  wait(200us)  
  RegWrite(SER_ID, 16#0373, 1, 16#02, 16#02, "SER_UART_Write")    -- needed for MP3.
  wait(200us)  

--   RegRead(SER_ID, 16#0330, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed
--   wait(200us) 
--   RegWrite(SER_ID, 16#0330, 1, 16#80, 16#80, "SER_UART_Write")      -- CSI mode selected 
--   --RegWrite(SER_ID, 16#0330, 1, 16#00, 16#00, "SER_UART_Write")    -- CSI mode selected           
--   RegRead(SER_ID, 16#0330, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed
--   wait(200us)    
   
   
   

   --fpga_UART_Write("FPGA1","DES", DESA_ID, 16#01, 1, 16#02)    --  for 6G link setup if link working at 6G
   --reg_val11  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x01, 1) 
    
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#06, 1, 16#8E)
   --reg_val12  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x06, 1)
   --wait(0ms) 

   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)          -- CSI START FROM HERE
   --reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)    
   
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0333, 1, 0x4E) 
   --reg_val16  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0333, 1)
   
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0334, 1, 0xE4)
   --reg_val17  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0334, 1)
   
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#044A, 1, 0x00)           -- 1 lane enable, A port
   --reg_val18  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x044A, 1)
   
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#048A, 1, 0x00)           -- 1 lane enable, B port
   --reg_val19  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x048A, 1)
   
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0323, 1, 0x2C)           -- clock output to 1200M
   --reg_val20  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0323, 1)
   
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0320, 1, 0x2C)           -- clock output to 1200M
   --reg_val21  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0320, 1)
   
      
--fpga_UART_Write("FPGA1","DES", DESA_ID, 16#02, 1, 0x47)              --
   
   
    -------------- changing port output of DES -----------------------
    --des_read1   = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x51, 1) -- default is port B, 0x01
    --wait(0ms) 
    --des_read1   = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x52, 1) -- default is port B, 0x02
    wait(0ms) 
         
    fpga_UART_Write("FPGA1","DES", DESA_ID, 16#51, 1, 0x02)        -- change to port A of HS92
    fpga_UART_Write("FPGA1","DES", DESA_ID, 16#52, 1, 0x01)        -- change to port A of HS92   
    
    --des_read1   = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x51, 1) -- should be 0x02, port A activated
    --wait(0ms) 
    --des_read1   = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x52, 1) -- should be 0x01, port A activated
    --wait(0ms)    
    ------------------------------------------------------------------- 
    
    

--   -- special debug by Mu
--   wait(0ms)
--   RegRead(SER_ID, 16#102, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed
--   RegRead(SER_ID, 16#10A, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed
--   RegRead(SER_ID, 16#112, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed
--   RegRead(SER_ID, 16#11A, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed
-- 
--   RegWrite(SER_ID, 16#02, 1, 16#47, 16#47, "SER_UART_Write")         -- one video generator enable???     
--   wait(200us)  
-- 
--   RegRead(SER_ID, 16#02, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed
--   --wait(200us)     
    
       
      
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x84)          -- Force to send out MIPI clocks from DES
   -- reg_val22  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)    -- verify   
   wait(1ms)
   
   -- we should be lock now and MIPI clock running !!!
   --RegRead(SER_ID, 16#0330, 1, upperword, lowword,"SER_UART_Read")   -- for SER regs verification if needed
   --wait(200us)
   
--    RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xDA          
--    reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xDA expected   
--    wait(0ms)
--    for idxs = 1 to len(active_sites) do
--       site = active_sites[idxs]
--       reg_val1[site]  = lowword[site]       
--    end_for        


--   -- special debug by Mu
--   wait(0ms)
--   RegRead(SER_ID, 16#102, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed
--   RegRead(SER_ID, 16#10A, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed
--   RegRead(SER_ID, 16#112, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed
--   RegRead(SER_ID, 16#11A, 1, upperword, lowword,"SER_UART_Read")     -- for SER regs verification if needed



  --RegRead(SER_ID, 16#0374, 1, upperword, lowword,"SER_UART_Read")   -- should see NO BIT high, default 0x00  
  --wait(200us)  
  
  RegWrite(SER_ID, 16#0370, 1, 16#0F, 16#0F, "SER_UART_Write")      -- select bad pattern
  wait(100ms)
  --RegRead(SER_ID, 16#0370, 1, upperword, lowword,"SER_UART_Read")   -- verify write above
  --wait(0ms)
 
  RegRead(SER_ID, 16#0374, 1, upperword, lowword,"SER_UART_Read")   -- should see bit[4] are high, meaning pattern fails the comparison   
  wait(200us)
  
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val_ser_bad[site]  = integer(lowword[site])    
    end_for 
  

  RegWrite(SER_ID, 16#0370, 1, 16#0B, 16#0B, "SER_UART_Write")      -- select GOOD pattern  
  wait(100ms) 
    
  RegRead(SER_ID, 16#0374, 1, upperword, lowword,"SER_UART_Read")   -- should see NO BIT high, meaning PASS THE TEST   
  wait(200us)   

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val_ser_good[site]  = integer(lowword[site])
    end_for 

  
  for idx=1 to sites do
       site = current_active_sites[idx]
       if (ireg_val_ser_bad[site] >15) AND (ireg_val_ser_good[site] < 1) then 
           LBDONE[site] = 1
       else
           LBDONE[site] = 0
       endif
  endfor  
      

   -- turn off MIPI clocks from DES
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)            
   -- reg_val23  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)
   -- loop back relays on LB opened
   fpga_cbit_control("FPGA1", 2#0000)      -- control FPGA cbits 2#0000  (cb4, cb3, cb2, cb1)   
     open cbit CB2_SLDC                 --OVI_RELAYS 
     open cbit COAXB_M_RELAY            --OVI_RELAYS
-------------- Power Down ---------------------------
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
  --set  digital  pin ALL_PATTERN_PINS fx1 driver  preset low       
  wait(500us)
  
        powerdown_device(POWERDOWN)

 open cbit  FB_RELAY
 open cbit  DNUT_RXTX_RELAY
    test_value ireg_val  with devid_it 
    test_value ireg_val0 with dnutid_it
    test_value ireg_val1 with ser_lock_it
    test_value ireg_val15 with des_lock_it        
    test_value ireg_val_ser_bad  with bad_pat_it 
    test_value ireg_val_ser_good with good_pat_it          
    test_value LBDONE  with lbdone

 
 
 end_body



procedure HS89_Leakage_no_CSI(vcore, vio, v18,  SE_ODD_HI_LEAKAGE, SE_ODD_LO_LEAKAGE, SE_EVEN_HI_LEAKAGE, SE_EVEN_LO_LEAKAGE, PWDN_HI_LEAKAGE, PWDN_LO_LEAKAGE,RSVD_HI_LKG,RSVD_LO_LKG,XRES_HI_LKG,XRES_LO_LKG,X1_Res )
--------------------------------------------------------------------------------
--  

in float: vcore, vio, v18
in_out float_test: SE_ODD_HI_LEAKAGE, SE_ODD_LO_LEAKAGE, SE_EVEN_HI_LEAKAGE, SE_EVEN_LO_LEAKAGE, PWDN_HI_LEAKAGE, PWDN_LO_LEAKAGE ,RSVD_HI_LKG,RSVD_LO_LKG,XRES_HI_LKG,XRES_LO_LKG,X1_Res
--in_out float_test: TRI_HI_LEAKAGE, TRI_LO_LEAKAGE
--in_out float_test: OD_HI_LEAKAGE, OD_LO_LEAKAGE, GPO_HI_LEAKAGE, GPO_LO_LEAKAGE
--in_out float_test: GPIO_LO_LEAKAGE


local

word    : site , idx
--integer : idx

multisite float     : leakage_SE_low[22], leakage_SE_high[22]

multisite float     : leak_SE_odd_hi[24], leak_SE_even_hi[25], leak_SE_odd_lo[24], leak_SE_even_lo[25]
multisite float     : leak_pwd_hi[1],    leak_pwd_lo[1],RSVD_HI,XRES_HI,XRES_LO,RSVD_LO
float               : Vconf0, Vconf1
multisite lword     : lowword, upperword, data
multisite float     : leak_x1_hi[1],leak_x2_hi[1],x1_res,x2_res

end_local

body

-- NEED to ADD leakage for X1/X2/XRES/RSVD/CAP_VDD later !!!!!!!!!!!!!!!!

  active_sites = get_active_sites
  sites = word(len(active_sites))  
    
 
--  disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!  
  connect hvvi chan SER_RSVD + SER_XRES remote
  set hvvi chan SER_RSVD + SER_XRES to fv 0v max r5v  
  set hvvi chan SER_RSVD + SER_XRES irange to r500ua iclamps percent to imax 90.0 imin 0.0  
  set hvvi chan SER_RSVD + SER_XRES to measure i  max 400ua
 
  -- reset levels
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 0.2V vol 0V voh 0V iol 0mA ioh 0mA vref 0V
  set digital pin ALL_PATTERN_PINS modes to driver pattern     -- Do not delete !!!
  wait(1ms)
  
  


  -- DPs shared from FPGA switched to X1, X2, XRES DUT pins
    close cbit XRES_RELAY+ X1X2_OSC_DP   --HOVI_RELAYS  
    open digital cbit FB_RELAY  ---Make sure Dp connect to CSI pins
--disconnect Serial Link to VI16s

-----Disconnect SIO+/- from DPs --- this will be taken care by disconnect dcl pin group all pattern pins   
  wait(3ms)
  

    --The function below is for setting DUT supplies ONLY, change Voltage if Required  
    Set_SER_Voltages(vio, vcore, v18)

    wait (10ms) -- trial for 47uF cap on SER_VDD

    force_instr(ALL_PATTERN_PINS,   "PPMU", "VOLTAGE" ,0V, 2mA,  -2mA,   2mA)
    wait(1ms)
    
    disconnect digital pin ALL_PATTERN_PINS from dcl delay 100us
    set digital pin ALL_PATTERN_PINS levels to vil 0V vih vio iol 0uA ioh 0uA vref 0V
    
    connect digital pin ALL_PATTERN_PINS to ppmu --delay 100us               
    disconnect digital pin SER_ODD_PINS + SER_EVEN_PINS - SER_PWDNB from dcl delay 100us
    connect digital pin SER_ODD_PINS + SER_EVEN_PINS - SER_PWDNB to ppmu --delay 100us   
    wait(1ms)
    
-----Need check with DE that no need to bring Power down pins up for output leakage test       
--     -- power down pin go high
--     force_instr(SER_PWDNB,  "PPMU", "VOLTAGE", vio, 200uA,  -200uA,  200uA)      
--     wait (6ms)  -- need this for power up time complete
----------------------------------------------------    

----Can not measure leakage on X2 pins
    -- odd high
    force_instr(SER_ODD_PINS -SER_PWDNB,   "PPMU", "VOLTAGE", vio, 200uA,  -200uA,   200uA)
    -- even low
    force_instr(SER_EVEN_PINS - SER_X2_AUXSDA,  "PPMU", "VOLTAGE", 0V, 200uA,  -200uA,  200uA) 
    set hvvi chan SER_RSVD to fv vio max r5v
    wait(3ms)
    connect  digital pin SER_EVEN_PINS to ppmu
---Turn this on next silicon
--    meas_instr(leak_SE_odd_hi, SER_ODD_PINS -SER_PWDNB ,  "PPMU", "CURRENT", 100uA,  10, 10us) ---With current revision, CSI have problem high leakage
    meas_instr(leak_SE_odd_hi, SER_ODD_PINS -SER_PWDNB - SER_CSI_ODD_PINS - SER_X1_AUXSCL,  "PPMU", "CURRENT", 100uA,  10, 10us) ---With current revision, CSI have problem high leakage
    measure hvvi on chan SER_RSVD for 50 samples every 10us averaged into RSVD_HI  
---Seperate X1 from the pack
    meas_instr(leak_x1_hi,  SER_X1_AUXSCL,  "PPMU", "CURRENT", 400uA,  10, 10us)
wait(0ms)     
--    meas_instr(leak_SE_even_lo, SER_EVEN_PINS ,  "PPMU", "CURRENT", 200uA,  10, 10us)         ---With current revision, CSI have problem high leakage

----No need X2 low
    meas_instr(leak_SE_even_lo, SER_EVEN_PINS - SER_CSI_EVEN_PINS - SER_X2_AUXSDA,  "PPMU", "CURRENT", 200uA,  10, 10us) ---With current revision, CSI have problem high leakage

wait(0ms)  


    measure hvvi on chan SER_XRES for 50 samples every 10us averaged into XRES_LO  



    --meas_instr(leak_conf0_lo,  SER_CONF0    ,  "PPMU", "CURRENT", 2mA,  10, 10us)
    --meas_instr(leak_tx_lo,     SER_TXSCL_MFP10,  "PPMU", "CURRENT", 2mA,  10, 10us)   
wait(0ms)   
   
   
    -- odd low
    force_instr(SER_ODD_PINS-SER_PWDNB,   "PPMU", "VOLTAGE" ,0V, 200uA,  -200uA,   200uA)
    -- even high
    force_instr(SER_EVEN_PINS - SER_X2_AUXSDA,  "PPMU", "VOLTAGE", vio, 200uA,  -200uA,  200uA)
    wait(3ms)
----Turn this on for next silicon    
--    meas_instr(leak_SE_odd_lo, SER_ODD_PINS-SER_PWDNB,  "PPMU", "CURRENT", 200uA,  10, 10us) ---With current revision, CSI have problem high leakage
-- no need to measure x1 lo
    meas_instr(leak_SE_odd_lo, SER_ODD_PINS-SER_PWDNB -SER_CSI_ODD_PINS -SER_X1_AUXSCL  ,  "PPMU", "CURRENT", 200uA,  10, 10us) ---With current revision, CSI have problem high leakage
    measure hvvi on chan SER_RSVD for 50 samples every 10us averaged into RSVD_LO



    --meas_instr(leak_conf1_lo,  SER_CONF1,  "PPMU", "CURRENT", 2mA,  10, 10us)
    --meas_instr(leak_rx_lo,     SER_RXSDA_MFP9,  "PPMU", "CURRENT", 2mA,  10, 10us)
wait(0ms)     
----Turn this on for next silicon    
--    meas_instr(leak_SE_even_hi, SER_EVEN_PINS,  "PPMU", "CURRENT", 200uA,  10, 10us)                       ---With current revision, CSI have problem high leakage
---seperate x2 
    meas_instr(leak_SE_even_hi, SER_EVEN_PINS  - SER_CSI_EVEN_PINS - SER_X2_AUXSDA,  "PPMU", "CURRENT", 100uA,  10, 10us) ---With current revision, CSI have problem high leakage
    measure hvvi on chan SER_XRES for 50 samples every 10us averaged into XRES_HI  

    --meas_instr(leak_conf0_hi,  SER_CONF0    ,  "PPMU", "CURRENT", 2mA,  10, 10us)
    --meas_instr(leak_tx_hi,     SER_TXSCL_MFP10,  "PPMU", "CURRENT", 2mA,  10, 10us)   
wait(0ms)

--    meas_instr(leak_pwd_hi,   SER_PWDNB,   "PPMU", "CURRENT", 200uA,  10, 10us)   
    
    -- power down pin go low now
    force_instr(SER_PWDNB,  "PPMU", "VOLTAGE", 0V, 200uA,  -200uA,  200uA)    
    wait(1ms)
    meas_instr(leak_pwd_lo,   SER_PWDNB,   "PPMU", "CURRENT", 200uA,  10, 10us)              
-----
    force_instr(SER_PWDNB,  "PPMU", "VOLTAGE", vio, 200uA,  -200uA,  200uA)    
    wait(3ms)
    meas_instr(leak_pwd_hi,   SER_PWDNB,   "PPMU", "CURRENT", 200uA,  10, 10us) 

 
    force_instr(ALL_PATTERN_PINS,   "PPMU", "VOLTAGE" ,0V, 2mA,  -2mA,   2mA)
    wait(1ms)

    disconnect digital pin ALL_PATTERN_PINS from ppmu    
    connect digital pin ALL_PATTERN_PINS to dcl
    --wait(3ms)
    
 -------     X1 and X2 always have 10Kpull up
    for idx = 1 to sites do
        site = active_sites[idx]
        x1_res[site]  =  vio/leak_x1_hi[site,1] 
        x2_res[site]  =  vio/leak_x2_hi[site,1]
    end_for
------------ Power Down ---------------------------

  
  disconnect digital pin SER_ODD_PINS + SER_EVEN_PINS from ppmu --delay 100us   
  connect digital pin SER_ODD_PINS + SER_EVEN_PINS to dcl delay 100us
  set hvvi chan SER_RSVD + SER_XRES to fv 0v max r5v
  disconnect hvvi chan SER_RSVD+ SER_XRES

  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0.0V
  wait(200us)
  set hcovi SER_VDD + SER_VDD18 +SER_VDDIO  to fv 0V vmax 4V clamp imax 600mA imin -600mA
 	  
  wait(3ms)     -- extra for 47uF cap on SER_VDD  

  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)

  open cbit XRES_RELAY+ X1X2_OSC_DP
  wait(3ms)                 
  
    test_value leak_SE_odd_hi  with SE_ODD_HI_LEAKAGE    
    test_value leak_SE_odd_lo  with SE_ODD_LO_LEAKAGE
    test_value leak_SE_even_hi  with SE_EVEN_HI_LEAKAGE    
    test_value leak_SE_even_lo  with SE_EVEN_LO_LEAKAGE
    test_value leak_pwd_hi  with PWDN_HI_LEAKAGE    
    test_value leak_pwd_lo  with PWDN_LO_LEAKAGE
    test_value RSVD_HI  with RSVD_HI_LKG    
    test_value RSVD_LO  with RSVD_LO_LKG
    test_value XRES_HI  with XRES_HI_LKG
    test_value XRES_LO  with  XRES_LO_LKG
    test_value x1_res   with X1_Res

end_body

procedure Mipi_LP_Vin_FT(vcore,vio,v18,devid_it,dnutid_it,vil_data1_lim,vih_data1_lim,Vil_data1_ft,Vil_data2_ft,Vil_clk_ft,Vih_data1_ft,Vih_data2_ft,Vih_clk_ft,POWERUP,POWERDOWN)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--  

in float                   : vio, vcore, v18, vil_data1_lim, vih_data1_lim
in_out integer_test        : devid_it, dnutid_it
in_out array of float_test : Vil_clk_ft, Vih_clk_ft
in_out array of float_test : Vil_data1_ft, Vih_data1_ft, Vil_data2_ft, Vih_data2_ft
in boolean        : POWERUP,POWERDOWN

local

word list[16]     : active_sites
word              : sites, idx, site
multisite integer : reg_rslt_uart[8], reg_rslt_i2c[8]
integer           : idxs, i
float             : Vconf0, Vconf1, inc
multisite lword   : lowword, upperword, data, des_read, des_read0, reg_val15, reg_val, reg_val0, reg_val1
multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val15


multisite boolean : result_L, result_H
multisite float   : Vil_data1[1], Vih_data1[1], Vil_clk[1], Vih_clk[1], Vil_data2[1], Vih_data2[1]
multisite lword   : hizdel_reg_val, oreg_reg_val



end_local

body

--    get_expr("OpVar_Char", CHAR)
    active_sites = get_active_sites
    sites = word(len(active_sites))  
    --POWER_CONNECT    -- need this for reseting device
    --make sure RSVD pin float (HVVI disconnect)
--    CHAR = TRUE
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!

-----Dut power up function
   DutPowerUp(vio, v18, vcore, "UART", "TP",POWERUP)

 --   RegRead(SER_ID, 0x18, 1, upperword, lowword,"SER_UART_Read")
--     RegWrite(SER_ID, 0x18, 1, 0xE0, 0xe0, "SER_UART_Write") 
    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)
--    RegRead(SER_ID, 16#06, 1, upperword, lowword,"SER_UART_Read")   
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val[site]  = integer(lowword[site])        
    end_for 


-------------- Power Down ---------------------------
      powerdown_device(POWERDOWN)  





end_body
procedure Mipi_LP_Vin_Char(vcore,vio,v18,devid_it,dnutid_it,Vin_lp_A_data0_N_ft,Vin_lp_A_data0_P_ft,Vin_lp_A_data1_N_ft,Vin_lp_A_data1_P_ft,Vin_lp_A_clk_N_ft,Vin_lp_A_clk_P_ft,Vin_lp_A_data2_N_ft,Vin_lp_A_data2_P_ft,Vin_lp_A_data3_N_ft,Vin_lp_A_data3_P_ft,Vin_lp_B_data0_N_ft,Vin_lp_B_data0_P_ft,Vin_lp_B_data1_N_ft,Vin_lp_B_data1_P_ft,Vin_lp_B_clk_N_ft,Vin_lp_B_clk_P_ft,Vin_lp_B_data2_N_ft,Vin_lp_B_data2_P_ft,Vin_lp_B_data3_N_ft,Vin_lp_B_data3_P_ft,Vin_Lp_Hyst,POWERUP,POWERDOWN,MipiH,MipiL)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--  

in float                   : vio, vcore, v18,MipiH,MipiL
in_out integer_test        : devid_it, dnutid_it
in_out array of float_test : Vin_lp_A_data0_N_ft,Vin_lp_A_data0_P_ft,Vin_lp_A_data1_N_ft,Vin_lp_A_data1_P_ft,Vin_lp_A_clk_N_ft,Vin_lp_A_clk_P_ft
in_out array of float_test : Vin_lp_A_data2_N_ft,Vin_lp_A_data2_P_ft,Vin_lp_A_data3_N_ft,Vin_lp_A_data3_P_ft

in_out array of float_test : Vin_lp_B_data0_N_ft,Vin_lp_B_data0_P_ft,Vin_lp_B_data1_N_ft,Vin_lp_B_data1_P_ft,Vin_lp_B_clk_N_ft,Vin_lp_B_clk_P_ft
in_out array of float_test : Vin_lp_B_data2_N_ft,Vin_lp_B_data2_P_ft,Vin_lp_B_data3_N_ft,Vin_lp_B_data3_P_ft
in_out array of float_test : Vin_Lp_Hyst

in boolean                 : POWERUP,POWERDOWN

local

word list[16]     : active_sites
word              : sites, idx, site
integer           : idxs, i
float             : Vconf0, Vconf1, inc
multisite lword   : lowword, upperword, data, des_read, des_read0, reg_val15, reg_val, reg_val0, reg_val1
multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val15

multisite lword   : hizdel_reg_val, oreg_reg_val

multisite float   : Vin_lp_port_A_data2_N[2], Vin_lp_port_A_data2_P[2],Vin_lp_port_A_data3_N[2], Vin_lp_port_A_data3_P[2]                                                     ---port A phy0
multisite float   : Vin_lp_port_B_data0_N[2], Vin_lp_port_B_data0_P[2],Vin_lp_port_B_data1_N[2], Vin_lp_port_B_data1_P[2] ,Vin_lp_port_B_clk_N[2], Vin_lp_port_B_clk_P[2]     ---port B phy 2

multisite float   : Vin_lp_port_A_data0_N[2], Vin_lp_port_A_data0_P[2],Vin_lp_port_A_data1_N[2], Vin_lp_port_A_data1_P[2],Vin_lp_port_A_clk_N[2], Vin_lp_port_A_clk_P[2]        ---port A phy1
multisite float   : Vin_lp_port_B_data2_N[2], Vin_lp_port_B_data2_P[2],Vin_lp_port_B_data3_N[2], Vin_lp_port_B_data3_P[2]                                                     ---port B phy3
multisite float   :  DA2N_LP_LOW[1]

multisite float   : Delta_Vin_lp_port_A_data0_N,Delta_Vin_lp_port_A_data2_P,Delta_Vin_lp_port_A_data3_N, Delta_Vin_lp_port_A_data3_P ---port A phy0
multisite float   : Delta_Vin_lp_port_B_data0_N, Delta_Vin_lp_port_B_data0_P,Delta_Vin_lp_port_B_data1_N, Delta_Vin_lp_port_B_data1_P ,Delta_Vin_lp_port_B_clk_N, Delta_Vin_lp_port_B_clk_P    ---port B phy 2
multisite float   : Vin_lp_hys[20]
multisite boolean  : pfvalue,pfvalue1
end_local


body
    get_expr("OpVar_Char", CHAR)
    active_sites = get_active_sites
    sites = word(len(active_sites))  
    --POWER_CONNECT    -- need this for reseting device
    --make sure RSVD pin float (HVVI disconnect)
--    CHAR = TRUE
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!

-----Dut power up function
 
   DutPowerUp(vio, v18, vcore, "UART", "TP_GMSL2",POWERUP)

    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)
   
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val[site]  = integer(lowword[site])        
    end_for 


-----Setup commnunication speed for DES
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(0ms)
    
----Power up DNUT
    
    powerup_dnut_vdd_vterm (1.2V,1.2V) ---turn on VDD and VTERM for DNUT

  --fpga_Set_DNUT_Pins("FPGA1", CFG2, CFG1, CFG0, PWDN, latch)
    fpga_Set_DNUT_Pins("FPGA1", 0 ,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               

---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY   ----FPGA to control communication instead of dps
    close digital cbit FB_RELAY ----connect feedback loop. Connect DNUT CSI pins to DUT CSI pins
    wait(6ms)

    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read expect data = 0x90   
    --wait(200us)
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val0[site]  = integer(reg_val0[site]) 
    end_for 
    


   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x86)          -- Force to send out MIPI clocks from DES HS92 0x84
--    reg_val22  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)    -- verify   
   wait(1ms)    -- needed, to initialize mipi blocks to go out of sleep mode 

   -- turn off MIPI clocks from DES
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)            
    reg_val  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)
   -- loop back relays on LB opened
    open digital cbit FB_RELAY                                          ---- disonnect DNUT CSI pins to DUT CSI pins   
   wait(4ms)    --

---Enter testmode 6
   SetTestMode(6, False, "SER_UART_Write")

---this procedure from Mu Li, it is a bit different then HS78
    RegWrite(SER_ID, 16#330, 1, 16#00, 16#06, "SER_UART_Write")         ---- select 2x2
  --RegRead(SER_ID, 16#330, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms) 

    RegWrite(SER_ID, 16#38, 1, 16#00, 16#80, "SER_UART_Write")          ---- PIN_DEV_EN_0 is set, LP mode 
  --RegRead(SER_ID, 16#38, 1, upperword, lowword,"SER_UART_Read")       -- verify write above
  --wait(0ms
-------setup measure phy2; portB CLK, DO and D1
    RegWrite(SER_ID, 16#337, 1, 16#00, 16#3, "SER_UART_Write")          ---- CNTLL1_TESTmuxSelect 
  --RegRead(SER_ID, 16#337, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms

    RegWrite(SER_ID, 16#336, 1, 16#00, 16#3, "SER_UART_Write")          ---- CNTLL0_TESTmuxSelect 
  --RegRead(SER_ID, 16#336, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms
  -- Setup DEBUG_MODE  
  RegWrite(SER_ID, 16#3E, 1, 16#40, 16#40, "SER_UART_Write")        -- DEBUG_MODE
  wait(1ms)
  --RegRead(SER_ID, 16#3E, 1, upperword, lowword,"SER_UART_Read")   -- verify write above
  --wait(0ms)     
  
-----------Setup PHY0 and PHY2 Data Lane LP low
-----Use ppmu to measure  can be changed to pattern later 
-----Connect CSI pins to ppmu
    disconnect digital pin SER_CSI_PINS from dcl
    connect digital pin SER_CSI_PINS to ppmu

-------- -----connect check pins to ppmu for now   
--     disconnect digital pin SER_GPIO0_MS_LOCK + SER_GPIO12_MS1_SDOR  from dcl
--     connect digital pin SER_GPIO0_MS_LOCK + SER_GPIO12_MS1_SDOR to ppmu
--     
--     set digital ppmu SER_DA2N to fv 0v vmax 0v  measure i max 1ma
--     set digital ppmu SER_GPIO0_MS_LOCK to fi 0.1ua imax 0.1uA  measure v max 3.0v
--    
--     measure digital ppmu SER_GPIO0_MS_LOCK voltage  vmax 3.0v average 20 delay 5us into DA2N_LP_LOW
--         wait(0)
-- 
--    set digital ppmu SER_CKBN to fv 1.1v vmax 1v  measure i max 1ma
--     set digital ppmu SER_GPIO15_LMN2_SS2_RO to fi 0.1ua imax 0.1uA  measure v max 3.0v
-- 
-- measure digital ppmu  SER_GPIO12_MS1_SDOR voltage  vmax 3.0v average 20 delay 5us into DA2N_LP_LOW
---------------
  -- turn off all MFPs pin of interest, function search later will turn on one compare at at time
     set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK + SER_GPIO3_RCLKOUT + SER_GPO4_CFG0  + SER_GPO5_CFG1 modes to comparator disable all fails    
     set digital pin SER_GPIO8_SCK + SER_GPIO9_SD + SER_GPIO10_CNTL0_WSOR_SDA2 + SER_GPIO11_CNTL1_SCKOR_SCL2 + SER_GPIO12_MS1_SDOR + SER_GPIO15_LMN2_SS2_RO modes to comparator disable all fails  
  wait(3ms)  
    set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK + SER_GPIO3_RCLKOUT levels to vol vio/2.0 voh vio/2.0 iol 0mA ioh 0mA vref 0V
--      set digital pin SER_GPIO8_SCK + SER_GPIO9_SD + SER_GPIO10_CNTL0_WSOR_SDA2 + SER_GPIO11_CNTL1_SCKOR_SCL2 + SER_GPIO12_MS1_SDOR + SER_GPIO15_LMN2_SS2_RO levels to vol vio/2.0 voh vio/2.0 iol 0mA ioh 0mA vref 0V
--      set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK + SER_GPIO3_RCLKOUT + SER_GPO4_CFG0 + SER_GPO5_CFG1 levels to vol vio/2.0 voh vio/2.0 iol 0mA ioh 0mA vref 0V
------Check port A phy0 D2 and D3

    if CHAR then
        Vin_lp_port_A_data2_N = Mipi_LP_linear_Search(SER_DA2N, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO0_MS_LOCK)
        Vin_lp_port_A_data2_P = Mipi_LP_linear_Search(SER_DA2P, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO1_LFLTB_ERRB )
        Vin_lp_port_A_data3_N = Mipi_LP_linear_Search(SER_DA3N, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO2_GPO_SCLK )
        Vin_lp_port_A_data3_P = Mipi_LP_linear_Search(SER_DA3P, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO3_RCLKOUT )

------Check port B phy2 D0, D1 and CLK

        Vin_lp_port_B_data0_N = Mipi_LP_linear_Search(SER_DB0N, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO8_SCK)
        Vin_lp_port_B_data0_P = Mipi_LP_linear_Search(SER_DB0P, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW",SER_GPIO9_SD )

        Vin_lp_port_B_data1_N = Mipi_LP_linear_Search(SER_DB1N, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO10_CNTL0_WSOR_SDA2)
        Vin_lp_port_B_data1_P = Mipi_LP_linear_Search(SER_DB1P, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO11_CNTL1_SCKOR_SCL2  )

        Vin_lp_port_B_clk_N = Mipi_LP_linear_Search(SER_CKBN, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO12_MS1_SDOR )
        Vin_lp_port_B_clk_P = Mipi_LP_linear_Search(SER_CKBP, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO15_LMN2_SS2_RO  )

    else
        set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK + SER_GPIO3_RCLKOUT modes to comparator enable all fails    
        set digital pin SER_GPIO8_SCK + SER_GPIO9_SD + SER_GPIO10_CNTL0_WSOR_SDA2 + SER_GPIO11_CNTL1_SCKOR_SCL2 + SER_GPIO12_MS1_SDOR + SER_GPIO15_LMN2_SS2_RO modes to comparator enable all fails      
        set digital ppmu SER_DA2N +SER_DA2P + SER_DA3N + SER_DA3P  + SER_DB0N + SER_DB0P  + SER_DB1N + SER_DB1P + SER_CKBN +SER_CKBP to fv MipiH vmax 2v  measure i max 20ma
        wait(1ms)
        execute digital pattern "Mipi_LP_Vin" at label "DATA1_HIGH" run to end into pfvalue
        set digital ppmu SER_DA2N +SER_DA2P + SER_DA3N + SER_DA3P  + SER_DB0N + SER_DB0P  + SER_DB1N + SER_DB1P + SER_CKBN +SER_CKBP to fv MipiL vmax 2v  measure i max 20ma
        wait(1ms)
        execute digital pattern "Mipi_LP_Vin" at label "DATA1_LOW"  run to end into pfvalue1
        set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK + SER_GPIO3_RCLKOUT modes to comparator disable all fails    
        set digital pin SER_GPIO8_SCK + SER_GPIO9_SD + SER_GPIO10_CNTL0_WSOR_SDA2 + SER_GPIO11_CNTL1_SCKOR_SCL2 + SER_GPIO12_MS1_SDOR + SER_GPIO15_LMN2_SS2_RO modes to comparator disable all fails      


-----prepare for dlog   
        for idx = 1  to sites do
            site = active_sites[idx]
            if pfvalue[site] then 
                Vin_lp_port_A_data2_N[site,1] = MipiH
                Vin_lp_port_A_data2_P[site,1] = MipiH
                Vin_lp_port_A_data3_N[site,1] = MipiH
                Vin_lp_port_A_data3_P[site,1] = MipiH
                Vin_lp_port_B_data0_N [site,1] = MipiH
                Vin_lp_port_B_data0_P[site,1] = MipiH
                Vin_lp_port_B_data1_N[site,1] = MipiH
                Vin_lp_port_B_data1_P[site,1] = MipiH
                Vin_lp_port_B_clk_N[site,1] = MipiH
                Vin_lp_port_B_clk_P[site,1] = MipiH      
            else
                Vin_lp_port_A_data2_N[site,1] = 999.0mV
                Vin_lp_port_A_data2_P[site,1] = 999.0mV 
                Vin_lp_port_A_data3_N[site,1] =  999.0mV
                Vin_lp_port_A_data3_P[site,1] = 999.0mV 
                Vin_lp_port_B_data0_N [site,1] = 999.0mV 
                Vin_lp_port_B_data0_P[site,1] = 999.0mV 
                Vin_lp_port_B_data1_N[site,1] = 999.0mV 
                Vin_lp_port_B_data1_P[site,1] = 999.0mV 
                Vin_lp_port_B_clk_N[site,1] = 999.0mV 
                Vin_lp_port_B_clk_P[site,1] =  999.0mV                  
            end_if
            if pfvalue1[site] then 
                Vin_lp_port_A_data2_N[site,2] = MipiL
                Vin_lp_port_A_data2_P[site,2] = MipiL
                Vin_lp_port_A_data3_N[site,2] = MipiL
                Vin_lp_port_A_data3_P[site,2] = MipiL
                Vin_lp_port_B_data0_N [site,2] = MipiL
                Vin_lp_port_B_data0_P[site,2] = MipiL
                Vin_lp_port_B_data1_N[site,2] = MipiL
                Vin_lp_port_B_data1_P[site,2] = MipiL
                Vin_lp_port_B_clk_N[site,2] = MipiL
                Vin_lp_port_B_clk_P[site,2] = MipiL     
            else
                Vin_lp_port_A_data2_N[site,2] = -999.0mV
                Vin_lp_port_A_data2_P[site,2] = -999.0mV 
                Vin_lp_port_A_data3_N[site,2] =  -999.0mV
                Vin_lp_port_A_data3_P[site,2] = -999.0mV 
                Vin_lp_port_B_data0_N [site,2] = -999.0mV 
                Vin_lp_port_B_data0_P[site,2] = -999.0mV 
                Vin_lp_port_B_data1_N[site,2] = -999.0mV 
                Vin_lp_port_B_data1_P[site,2] = -999.0mV 
                Vin_lp_port_B_clk_N[site,2] = -999.0mV 
                Vin_lp_port_B_clk_P[site,2] =  -999.0mV                  
            end_if

         end_for
    end_if
----Switch internal mux for Phy1 and Phy3

   RegWrite(SER_ID, 16#337, 1, 16#00, 16#13, "SER_UART_Write")          ---- CNTLL1_TESTmuxSelect 
  --RegRead(SER_ID, 16#337, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms
    RegWrite(SER_ID, 16#336, 1, 16#00, 16#13, "SER_UART_Write")          ---- CNTLL0_TESTmuxSelect 
  --RegRead(SER_ID, 16#336, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms

------Check port A phy1 D0, D1 and clk
    if CHAR then
        Vin_lp_port_A_data0_N = Mipi_LP_linear_Search(SER_DA0N, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO0_MS_LOCK)
        Vin_lp_port_A_data0_P = Mipi_LP_linear_Search(SER_DA0P, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO1_LFLTB_ERRB )
        Vin_lp_port_A_data1_N = Mipi_LP_linear_Search(SER_DA1N, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO2_GPO_SCLK )
        Vin_lp_port_A_data1_P = Mipi_LP_linear_Search(SER_DA1P, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO3_RCLKOUT )
        Vin_lp_port_A_clk_N = Mipi_LP_linear_Search(SER_CKAN, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPO4_CFG0 )
        Vin_lp_port_A_clk_P = Mipi_LP_linear_Search(SER_CKAP, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPO5_CFG1  )
------Check port B phy3 D0, D1

        Vin_lp_port_B_data2_N = Mipi_LP_linear_Search(SER_DB2N, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO8_SCK)
        Vin_lp_port_B_data2_P = Mipi_LP_linear_Search(SER_DB2P, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW",SER_GPIO9_SD )

        Vin_lp_port_B_data3_N = Mipi_LP_linear_Search(SER_DB3N, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO10_CNTL0_WSOR_SDA2)
        Vin_lp_port_B_data3_P = Mipi_LP_linear_Search(SER_DB3P, 570mV, (vcore-0.1), "Mipi_LP_Vin", "DATA1_HIGH", "DATA1_LOW", SER_GPIO11_CNTL1_SCKOR_SCL2  )
     else
        set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK + SER_GPIO3_RCLKOUT + SER_GPO4_CFG0 + SER_GPO5_CFG1  modes to comparator enable all fails    
        set digital pin SER_GPIO8_SCK + SER_GPIO9_SD + SER_GPIO10_CNTL0_WSOR_SDA2 + SER_GPIO11_CNTL1_SCKOR_SCL2  modes to comparator enable all fails      
        set digital ppmu SER_DA0N +SER_DA0P + SER_DA1N + SER_DA1P  + SER_DB2N + SER_DB2P  + SER_DB3N + SER_DB3P + SER_CKAN +SER_CKAP to fv MipiH vmax 2v  measure i max 20ma
        wait(1ms)
        execute digital pattern "Mipi_LP_Vin" at label "DATA1_HIGH" run to end into pfvalue
 
        set digital ppmu SER_DA0N +SER_DA0P + SER_DA1N + SER_DA1P  + SER_DB2N + SER_DB2P  + SER_DB3N + SER_DB3P + SER_CKAN +SER_CKAP to fv MipiL vmax 2v  measure i max 20ma
        wait(1ms)
        execute digital pattern "Mipi_LP_Vin" at label "DATA1_LOW" run to end into pfvalue1
        set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK + SER_GPIO3_RCLKOUT + SER_GPO4_CFG0 + SER_GPO5_CFG1 modes to comparator disable all fails    
        set digital pin SER_GPIO8_SCK + SER_GPIO9_SD + SER_GPIO10_CNTL0_WSOR_SDA2 + SER_GPIO11_CNTL1_SCKOR_SCL2 modes to comparator disable all fails      
-----prepare for dlog   
        for idx = 1  to sites do
            site = active_sites[idx]
            if pfvalue[site] then 
                Vin_lp_port_A_data0_N[site,1] = MipiH
                Vin_lp_port_A_data0_P[site,1] = MipiH
                Vin_lp_port_A_data1_N[site,1] = MipiH
                Vin_lp_port_A_data1_P[site,1] = MipiH
                Vin_lp_port_B_data2_N [site,1] = MipiH
                Vin_lp_port_B_data2_P[site,1] = MipiH
                Vin_lp_port_B_data3_N[site,1] = MipiH
                Vin_lp_port_B_data3_P[site,1] = MipiH
                Vin_lp_port_A_clk_N[site,1] = MipiH
                Vin_lp_port_A_clk_P[site,1] = MipiH      
            else
                Vin_lp_port_A_data0_N[site,1] = 999.0mV
                Vin_lp_port_A_data0_P[site,1] = 999.0mV 
                Vin_lp_port_A_data1_N[site,1] =  999.0mV
                Vin_lp_port_A_data1_P[site,1] = 999.0mV 
                Vin_lp_port_B_data2_N [site,1] = 999.0mV 
                Vin_lp_port_B_data2_P[site,1] = 999.0mV 
                Vin_lp_port_B_data3_N[site,1] = 999.0mV 
                Vin_lp_port_B_data3_P[site,1] = 999.0mV 
                Vin_lp_port_A_clk_N[site,1] = 999.0mV 
                Vin_lp_port_A_clk_P[site,1] =  999.0mV                  
            end_if
            if pfvalue1[site] then 
                Vin_lp_port_A_data0_N[site,2] = MipiL
                Vin_lp_port_A_data0_P[site,2] = MipiL
                Vin_lp_port_A_data1_N[site,2] = MipiL
                Vin_lp_port_A_data1_P[site,2] = MipiL
                Vin_lp_port_B_data2_N [site,2] = MipiL
                Vin_lp_port_B_data2_P[site,2] = MipiL
                Vin_lp_port_B_data3_N[site,2] = MipiL
                Vin_lp_port_B_data3_P[site,2] = MipiL
                Vin_lp_port_A_clk_N[site,2] = MipiL
                Vin_lp_port_A_clk_P[site,2] = MipiL     
            else
                Vin_lp_port_A_data0_N[site,2] = -999.0mV
                Vin_lp_port_A_data0_P[site,2] = -999.0mV 
                Vin_lp_port_A_data1_N[site,2] =  -999.0mV
                Vin_lp_port_A_data1_P[site,2] = -999.0mV 
                Vin_lp_port_B_data2_N [site,2] = -999.0mV 
                Vin_lp_port_B_data2_P[site,2] = -999.0mV 
                Vin_lp_port_B_data3_N[site,2] = -999.0mV 
                Vin_lp_port_B_data3_P[site,2] = -999.0mV 
                Vin_lp_port_A_clk_N[site,2] = -999.0mV 
                Vin_lp_port_A_clk_P[site,2] =  -999.0mV                  
            end_if

         end_for



     end_if

wait(0ms) 

----Added on 2/28/2018; Umut requests to datalog differnces between high and low measurement( hyst)

    if CHAR then
        for idx = 1 to sites do
            site = active_sites[idx]
            Vin_lp_hys[site,1] = Vin_lp_port_A_data0_N[site,1]-Vin_lp_port_A_data0_N[site,2]
            Vin_lp_hys[site,2] = Vin_lp_port_A_data0_P[site,1]-Vin_lp_port_A_data0_P[site,2]
            Vin_lp_hys[site,3] = Vin_lp_port_A_data1_N[site,1]-Vin_lp_port_A_data1_N[site,2]
            Vin_lp_hys[site,4] = Vin_lp_port_A_data1_P[site,1]-Vin_lp_port_A_data1_P[site,2]
            Vin_lp_hys[site,5] = Vin_lp_port_A_data2_N[site,1]-Vin_lp_port_A_data2_N[site,2]
            Vin_lp_hys[site,6] = Vin_lp_port_A_data2_P[site,1]-Vin_lp_port_A_data2_P[site,2]
            Vin_lp_hys[site,7] = Vin_lp_port_A_data3_N[site,1]-Vin_lp_port_A_data3_N[site,2]
            Vin_lp_hys[site,8] = Vin_lp_port_A_data3_P[site,1]-Vin_lp_port_A_data3_P[site,2]    
            Vin_lp_hys[site,9] = Vin_lp_port_A_clk_N[site,1] - Vin_lp_port_A_clk_N[site,2]
            Vin_lp_hys[site,10] = Vin_lp_port_A_clk_P[site,1]-  Vin_lp_port_A_clk_P[site,2]         

            Vin_lp_hys[site,11] = Vin_lp_port_B_data0_N[site,1]-Vin_lp_port_B_data0_N[site,2]
            Vin_lp_hys[site,12] = Vin_lp_port_B_data0_P[site,1]-Vin_lp_port_B_data0_P[site,2]
            Vin_lp_hys[site,13] = Vin_lp_port_B_data1_N[site,1]-Vin_lp_port_B_data1_N[site,2]
            Vin_lp_hys[site,14] = Vin_lp_port_B_data1_P[site,1]-Vin_lp_port_B_data1_P[site,2]
            Vin_lp_hys[site,15] = Vin_lp_port_B_data2_N[site,1]-Vin_lp_port_B_data2_N[site,2]
            Vin_lp_hys[site,16] = Vin_lp_port_B_data2_P[site,1]-Vin_lp_port_B_data2_P[site,2]
            Vin_lp_hys[site,17] = Vin_lp_port_B_data3_N[site,1]-Vin_lp_port_B_data3_N[site,2]
            Vin_lp_hys[site,18] = Vin_lp_port_B_data3_P[site,1]-Vin_lp_port_B_data3_P[site,2]    
            Vin_lp_hys[site,19] = Vin_lp_port_B_clk_N[site,1] - Vin_lp_port_B_clk_N[site,2]
            Vin_lp_hys[site,20] = Vin_lp_port_B_clk_P[site,1]-  Vin_lp_port_B_clk_P[site,2]              
  
        end_for
    else
        Vin_lp_hys = 80mV
    end_if

-------------- Power Down ---------------------------
    if (POWERDOWN)   then
        fpga_Set_DNUT_Pins("FPGA1", 0 ,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)
    end_if    
---Open relay to connect FPGA to control TX/RX on DNUT
    open cbit  DNUT_RXTX_RELAY
    open digital cbit FB_RELAY 
     powerdown_device(POWERDOWN)
  test_value ireg_val with devid_it
  test_value ireg_val0 with dnutid_it
    
  test_value Vin_lp_port_A_data0_N with Vin_lp_A_data0_N_ft  
  test_value Vin_lp_port_A_data0_P with Vin_lp_A_data0_P_ft  
  test_value Vin_lp_port_A_data1_N with Vin_lp_A_data1_N_ft  
  test_value Vin_lp_port_A_data1_P with Vin_lp_A_data1_P_ft  

  test_value Vin_lp_port_A_clk_N with Vin_lp_A_clk_N_ft  
  test_value Vin_lp_port_A_clk_P with Vin_lp_A_clk_P_ft 

  test_value Vin_lp_port_A_data2_N with Vin_lp_A_data2_N_ft  
  test_value Vin_lp_port_A_data2_P with Vin_lp_A_data2_P_ft  
  test_value Vin_lp_port_A_data3_N with Vin_lp_A_data3_N_ft  
  test_value Vin_lp_port_A_data3_P with Vin_lp_A_data3_P_ft 
----Port B
 test_value Vin_lp_port_B_data0_N with Vin_lp_B_data0_N_ft  
  test_value Vin_lp_port_B_data0_P with Vin_lp_B_data0_P_ft  
  test_value Vin_lp_port_B_data1_N with Vin_lp_B_data1_N_ft  
  test_value Vin_lp_port_B_data1_P with Vin_lp_B_data1_P_ft  

  test_value Vin_lp_port_B_clk_N with Vin_lp_B_clk_N_ft  
  test_value Vin_lp_port_B_clk_P with Vin_lp_B_clk_P_ft 

  test_value Vin_lp_port_B_data2_N with Vin_lp_B_data2_N_ft  
  test_value Vin_lp_port_B_data2_P with Vin_lp_B_data2_P_ft  
  test_value Vin_lp_port_B_data3_N with Vin_lp_B_data3_N_ft  
  test_value Vin_lp_port_B_data3_P with Vin_lp_B_data3_P_ft 

  test_value Vin_lp_hys with Vin_Lp_Hyst


end_body
procedure Mipi_HS_Vin_Char(vcore,vio,v18,devid_it,dnutid_it,Vcom_L_lim,Vcom_H_lim,Vcom_L_ft,Vcom_H_ft,Vin_hs_A_clk_ft,Vin_hs_A_data0_ft,Vin_hs_A_data1_ft,Vin_hs_A_data2_ft,Vin_hs_A_data3_ft,Vin_hs_B_clk_ft,Vin_hs_B_data0_ft,Vin_hs_B_data1_ft,Vin_hs_B_data2_ft,Vin_hs_B_data3_ft,Vin_hs_A_clk_H_ft,Vin_hs_A_data0_H_ft,Vin_hs_A_data1_H_ft,Vin_hs_A_data2_H_ft,Vin_hs_A_data3_H_ft,Vin_hs_B_clk_H_ft,Vin_hs_B_data0_H_ft,Vin_hs_B_data1_H_ft,Vin_hs_B_data2_H_ft,Vin_hs_B_data3_H_ft,POWERUP,POWERDOWN)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--  

in float                   : vio, vcore, v18, Vcom_L_lim, Vcom_H_lim
in_out integer_test        : devid_it, dnutid_it

in_out array of float_test : Vin_hs_A_clk_ft,Vin_hs_A_data0_ft,Vin_hs_A_data1_ft,Vin_hs_A_data2_ft,Vin_hs_A_data3_ft, Vcom_L_ft, Vcom_H_ft 
in_out array of float_test : Vin_hs_B_clk_ft,Vin_hs_B_data0_ft,Vin_hs_B_data1_ft,Vin_hs_B_data2_ft,Vin_hs_B_data3_ft
in_out array of float_test : Vin_hs_A_clk_H_ft,Vin_hs_A_data0_H_ft,Vin_hs_A_data1_H_ft,Vin_hs_A_data2_H_ft,Vin_hs_A_data3_H_ft 
in_out array of float_test : Vin_hs_B_clk_H_ft,Vin_hs_B_data0_H_ft,Vin_hs_B_data1_H_ft,Vin_hs_B_data2_H_ft,Vin_hs_B_data3_H_ft
in boolean                 : POWERUP,POWERDOWN



--in_out array of float_test : Vil_clk_ft, Vih_clk_ft
--in_out array of float_test : Vil_data1_ft, Vih_data1_ft, Vil_data2_ft, Vih_data2_ft, Vil_data3_ft, Vih_data3_ft, Vil_data4_ft, Vih_data4_ft, Vcom_L_ft, Vcom_H_ft


local

word list[16]     : active_sites
word              : sites, idx, site
integer           : idxs, i
float             : Vconf0, Vconf1, inc
multisite lword   : lowword, upperword, data, des_read, des_read0, reg_val15, reg_val, reg_val0, reg_val1
multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val15


multisite boolean : result_L, result_H
multisite float   : Vcom_L[1], Vcom_H[1]
multisite float   : Vin_hs_A_data0[2], Vin_hs_A_data1[2], Vin_hs_A_data2[2], Vin_hs_A_data3[2], Vin_hs_A_clk[2]
multisite float   : Vin_hs_B_data0[2], Vin_hs_B_data1[2], Vin_hs_B_data2[2], Vin_hs_B_data3[2], Vin_hs_B_clk[2]

multisite float   : Vin_hs_A_data0_H[2], Vin_hs_A_data1_H[2], Vin_hs_A_data2_H[2], Vin_hs_A_data3_H[2], Vin_hs_A_clk_H[2]
multisite float   : Vin_hs_B_data0_H[2], Vin_hs_B_data1_H[2], Vin_hs_B_data2_H[2], Vin_hs_B_data3_H[2], Vin_hs_B_clk_H[2]

multisite lword   : hizdel_reg_val, oreg_reg_val

multisite float   :  DA2N_LP_LOW[1]

multisite float   :  csi_i_mease[10],csi_res[10]

float             : timerun
end_local


body

--    get_expr("OpVar_Char", CHAR)
    active_sites = get_active_sites
    sites = word(len(active_sites))  
    --POWER_CONNECT    -- need this for reseting device
    --make sure RSVD pin float (HVVI disconnect)
--    CHAR = TRUE
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!

-----Dut power up function
   DutPowerUp(vio, v18, vcore, "UART", "TP",POWERUP)

 --   RegRead(SER_ID, 0x18, 1, upperword, lowword,"SER_UART_Read")
--     RegWrite(SER_ID, 0x18, 1, 0xE0, 0xe0, "SER_UART_Write") 
    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)
--    RegRead(SER_ID, 16#06, 1, upperword, lowword,"SER_UART_Read")   
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val[site]  = integer(lowword[site])        
    end_for 


-----Setup commnunication speed for DES
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(0ms)

----Power up DNUT
    
    powerup_dnut_vdd_vterm (1.2V,1.2V) ---turn on VDD and VTERM for DNUT

  --fpga_Set_DNUT_Pins("FPGA1", CFG2, CFG1, CFG0, PWDN, latch)
    fpga_Set_DNUT_Pins("FPGA1", 0 ,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               

---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY   ----FPGA to control communication instead of dps
    close digital cbit FB_RELAY ----connect feedback loop. Connect DNUT CSI pins to DUT CSI pins
    wait(6ms)

    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read expect data = 0x90   
    --wait(200us)
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val0[site]  = integer(reg_val0[site]) 
    end_for 

--------------Turn on loop back to get CSI out of sleep mode

   ------------------------------****************************----------------------------------

   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x84)          -- Force to send out MIPI clocks from DES HS78 0x84
   -- reg_val22  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)    -- verify   
   wait(1ms)    -- needed, to initialize mipi blocks to go out of sleep mode 

   -- turn off MIPI clocks from DES
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)            
   -- reg_val23  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)
   -- loop back relays on LB opened
    open digital cbit FB_RELAY                                          ---- disonnect DNUT CSI pins to DUT CSI pins   
   wait(4ms)    --

---Enter testmode 6
   SetTestMode(6, False, "SER_UART_Write")

---this procedure from Mu Li, it is a bit different then HS78
    RegWrite(SER_ID, 16#330, 1, 16#00, 16#06, "SER_UART_Write")         ---- select 2x2
  --RegRead(SER_ID, 16#330, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms) 

    RegWrite(SER_ID, 16#38, 1, 16#00, 16#80, "SER_UART_Write")          ---- PIN_DEV_EN_0 is set, LP mode 
  --RegRead(SER_ID, 16#38, 1, upperword, lowword,"SER_UART_Read")       -- verify write above
  --wait(0ms
-------setup measure phy2; portB CLK, DO and D1
    RegWrite(SER_ID, 16#337, 1, 16#00, 16#3, "SER_UART_Write")          ---- CNTLL1_TESTmuxSelect 
  --RegRead(SER_ID, 16#337, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms

    RegWrite(SER_ID, 16#336, 1, 16#00, 16#3, "SER_UART_Write")          ---- CNTLL0_TESTmuxSelect 
  --RegRead(SER_ID, 16#336, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms
  -- Setup DEBUG_MODE  
  RegWrite(SER_ID, 16#3E, 1, 16#40, 16#40, "SER_UART_Write")        -- DEBUG_MODE
  wait(1ms)
  --RegRead(SER_ID, 16#3E, 1, upperword, lowword,"SER_UART_Read")   -- verify write above
  --wait(0ms)     
  
-------------HS mode
    RegWrite(SER_ID, 16#38, 1, 16#00, 16#00, "SER_UART_Write")          ---- PIN_DEV_EN_0 is 0, HS mode 
  --RegRead(SER_ID, 16#38, 1, upperword, lowword,"SER_UART_Read")       -- verify write above
  --wait(0ms)
    RegWrite(SER_ID, 16#39, 1, 16#00, 16#01, "SER_UART_Write")          ---- PIN_DEV_EN_1 bit 0 = 1 HS mode 
  --RegRead(SER_ID, 16#39, 1, upperword, lowword,"SER_UART_Read")       -- verify write above
  --wait(0ms)
-------setup measure phy2; portB CLK, DO and D1
    RegWrite(SER_ID, 16#337, 1, 16#00, 16#4, "SER_UART_Write")          ---- CNTLL1_TESTmuxSelect -- LP mode=03, HS mode=04
  --RegRead(SER_ID, 16#337, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms

    RegWrite(SER_ID, 16#336, 1, 16#00, 16#4, "SER_UART_Write")          ---- CNTLL0_TESTmuxSelect -- LP mode=03, HS mode=04
  --RegRead(SER_ID, 16#336, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms)




-----------Setup PHY0 and PHY2 Data Lane HS low
-----Use ppmu to measure  can be changed to pattern later 
-----Connect CSI pins to ppmu
    disconnect digital pin SER_CSI_PINS from dcl
    connect digital pin SER_CSI_PINS to ppmu

------------ turn off all MFPs pin of interest, function search later will turn on one compare at at time
     set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK + SER_GPIO3_RCLKOUT + SER_GPO4_CFG0 + SER_GPO5_CFG1 modes to comparator disable all fails    
     set digital pin SER_GPIO8_SCK + SER_GPIO9_SD + SER_GPIO10_CNTL0_WSOR_SDA2 + SER_GPIO11_CNTL1_SCKOR_SCL2 + SER_GPIO12_MS1_SDOR + SER_GPIO15_LMN2_SS2_RO modes to comparator disable all fails  
     wait(3ms)  

-- ------Check port A phy0 D2 and D3
-- ---Debug
-- --       disconnect digital pin SER_GPIO0_MS_LOCK + SER_GPIO12_MS1_SDOR  from dcl
-- --      connect digital pin SER_GPIO0_MS_LOCK + SER_GPIO12_MS1_SDOR to ppmu
-- --     set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK + SER_GPIO3_RCLKOUT levels to vol vio/2.0 voh vio/2.0 iol 0mA ioh 0mA vref 0V
-- 
--  --       set digital ppmu SER_DA2P to fv 342mV vmax 1v  measure i max 20ma
-- --        set digital ppmu SER_DA2N to fv 318mV vmax 1v  measure i max 20ma
-- -- 
-- --     measure digital ppmu SER_GPIO0_MS_LOCK voltage  vmax 3.0v average 20 delay 5us into DA2N_LP_LOW
--  --   Vin_hs_data0 = Mipi_HS_linear_Search_ppmu(SER_DA2P,SER_DA2N , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO0_MS_LOCK,vio )

    
 ---End_debug   
    if CHAR then
---Measure Phy0 and phy2

    start_timer
----Phy0
        Vin_hs_A_data2 = Mipi_HS_linear_Search(SER_DA2P,SER_DA2N , Vcom_L_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi", SER_GPIO0_MS_LOCK )
        Vin_hs_A_data3 = Mipi_HS_linear_Search(SER_DA3P,SER_DA3N , Vcom_L_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO1_LFLTB_ERRB )

----Phy2    
        Vin_hs_B_data0  = Mipi_HS_linear_Search(SER_DB0P,SER_DB0N , Vcom_L_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO8_SCK )
        Vin_hs_B_data1  = Mipi_HS_linear_Search(SER_DB1P,SER_DB1N , Vcom_L_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO9_SD)    
        Vin_hs_B_clk    = Mipi_HS_linear_Search(SER_CKBP,SER_CKBN , Vcom_L_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO10_CNTL0_WSOR_SDA2) 

-----Measure with VCM high = 330mV
--------Phy0 VCM high = 330mV
        Vin_hs_A_data2_H = Mipi_HS_linear_Search(SER_DA2P,SER_DA2N , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi", SER_GPIO0_MS_LOCK )
        Vin_hs_A_data3_H = Mipi_HS_linear_Search(SER_DA3P,SER_DA3N , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO1_LFLTB_ERRB )

----Phy2  VCM high = 330mV  
        Vin_hs_B_data0_H  = Mipi_HS_linear_Search(SER_DB0P,SER_DB0N , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO8_SCK )
        Vin_hs_B_data1_H  = Mipi_HS_linear_Search(SER_DB1P,SER_DB1N , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO9_SD)    
        Vin_hs_B_clk_H    = Mipi_HS_linear_Search(SER_CKBP,SER_CKBN , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO10_CNTL0_WSOR_SDA2) 

    else  ----Go and no go
    
    end_if
----Swith to Phy1 and Phy3

    RegWrite(SER_ID, 16#337, 1, 16#00, 16#14, "SER_UART_Write")          ---- CNTLL1_TESTmuxSelect -- LP mode=03, HS mode=04
  --RegRead(SER_ID, 16#337, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms

    RegWrite(SER_ID, 16#336, 1, 16#00, 16#14, "SER_UART_Write")          ---- CNTLL0_TESTmuxSelect -- LP mode=03, HS mode=04
  --RegRead(SER_ID, 16#336, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
---Measurements  
----Phy1 VCM = 70mV
   Vin_hs_A_data0  = Mipi_HS_linear_Search(SER_DA0P,SER_DA0N , Vcom_L_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi", SER_GPIO0_MS_LOCK )
   Vin_hs_A_data1  = Mipi_HS_linear_Search(SER_DA1P,SER_DA1N , Vcom_L_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO1_LFLTB_ERRB )
   Vin_hs_A_clk    = Mipi_HS_linear_Search(SER_CKAP,SER_CKAN , Vcom_L_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO2_GPO_SCLK) 

----Phy3VCM = 70mV
    Vin_hs_B_data2 = Mipi_HS_linear_Search(SER_DB2P,SER_DB2N , Vcom_L_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi", SER_GPIO8_SCK )
    Vin_hs_B_data3 = Mipi_HS_linear_Search(SER_DB3P,SER_DB3N , Vcom_L_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi", SER_GPIO9_SD)

----measure with VCM = 330mV 
----Phy1 VCM = 330mV
   Vin_hs_A_data0_H  = Mipi_HS_linear_Search(SER_DA0P,SER_DA0N , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi", SER_GPIO0_MS_LOCK )
   Vin_hs_A_data1_H  = Mipi_HS_linear_Search(SER_DA1P,SER_DA1N , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO1_LFLTB_ERRB )
   Vin_hs_A_clk_H    = Mipi_HS_linear_Search(SER_CKAP,SER_CKAN , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi",SER_GPIO2_GPO_SCLK) 

----Phy3 VCM = 330mV
    Vin_hs_B_data2_H = Mipi_HS_linear_Search(SER_DB2P,SER_DB2N , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi", SER_GPIO8_SCK )
    Vin_hs_B_data3_H = Mipi_HS_linear_Search(SER_DB3P,SER_DB3N , Vcom_H_lim, 0.5mV, "Mipi_HS_Vin", "P_hi_N_low", "P_low_N_hi", SER_GPIO9_SD)


timerun = stop_timer
    wait(0)


-----Measure termination res of CSI ports: 

--        set digital ppmu SER_DA0P + SER_DA1P + SER_DA2P + SER_DA3P  + SER_CKAP + SER_DB0P + SER_DB1P + SER_DB2P + SER_DB3P  + SER_CKBP to fv 300mV vmax 1v  measure i max 20ma
--        set digital ppmu SER_DA0N + SER_DA1N + SER_DA2N + SER_DA3N  + SER_CKAN  + SER_DB0N + SER_DB1N + SER_DB2N + SER_DB3N  + SER_CKBN to fv 0mV vmax 1v  measure i max 20ma
--     wait(3mS)
--      measure digital ppmu SER_DA0P + SER_DA1P + SER_DA2P + SER_DA3P  + SER_CKAP + SER_DB0P + SER_DB1P + SER_DB2P + SER_DB3P  + SER_CKBP current imax 5ma average 20 delay 5us into  csi_i_mease
-- 
--     csi_res = 300.0e-3/csi_i_mease

-------------- Power Down ---------------------------
      powerdown_device(POWERDOWN)  
      if POWERDOWN then 
        powerup_dnut_vdd_vterm (0.0V,0.0V) ---turn off VDD and VTERM for DNUT
        wait(1ms)    
      end_if
---Open relay to connect FPGA to control TX/RX on DNUT
    open cbit  DNUT_RXTX_RELAY
    disconnect digital pin SER_CSI_PINS from ppmu
    connect digital pin SER_CSI_PINS to dcl
------Datalog 
-------------- Datalog Results ----------------
  test_value ireg_val with devid_it
  test_value ireg_val0 with dnutid_it
  
  test_value Vcom_L_lim with Vcom_L_ft          -- common mode Low 
  test_value Vcom_H_lim with Vcom_H_ft          -- common mode High 
  
---Port A low Vcm  
  test_value Vin_hs_A_clk   with Vin_hs_A_clk_ft    
  test_value Vin_hs_A_data0 with Vin_hs_A_data0_ft  
  test_value Vin_hs_A_data1 with Vin_hs_A_data1_ft  
  test_value Vin_hs_A_data2 with Vin_hs_A_data2_ft  
  test_value Vin_hs_A_data3 with Vin_hs_A_data3_ft   
 ---Port B low Vcm   
  test_value Vin_hs_B_clk   with Vin_hs_B_clk_ft    
  test_value Vin_hs_B_data0 with Vin_hs_B_data0_ft  
  test_value Vin_hs_B_data1 with Vin_hs_B_data1_ft  
  test_value Vin_hs_B_data2 with Vin_hs_B_data2_ft  
  test_value Vin_hs_B_data3 with Vin_hs_B_data3_ft   

---Port A high Vcm
  test_value Vin_hs_A_clk_H   with Vin_hs_A_clk_H_ft    
  test_value Vin_hs_A_data0_H with Vin_hs_A_data0_H_ft  
  test_value Vin_hs_A_data1_H with Vin_hs_A_data1_H_ft  
  test_value Vin_hs_A_data2_H with Vin_hs_A_data2_H_ft  
  test_value Vin_hs_A_data3_H with Vin_hs_A_data3_H_ft  
---Port B high Vcm
  test_value Vin_hs_B_clk_H   with Vin_hs_B_clk_H_ft    
  test_value Vin_hs_B_data0_H with Vin_hs_B_data0_H_ft  
  test_value Vin_hs_B_data1_H with Vin_hs_B_data1_H_ft  
  test_value Vin_hs_B_data2_H with Vin_hs_B_data2_H_ft  
  test_value Vin_hs_B_data3_H with Vin_hs_B_data3_H_ft  






end_body
procedure Mipi_HS_Vin_FT(vcore,vio,v18,devid_it,dnutid_it,Vcom_L_lim,Vcom_H_lim,Vdiff_Hs_lim,V_Ron,HS_SiVil,HS_SiVih,Vil_data1_ft,Vil_data2_ft,Vil_data3_ft,Vil_data4_ft,Vih_data1_ft,Vih_data2_ft,Vih_data3_ft,Vih_data4_ft,Vcom_L_ft,Vcom_H_ft,Ron_hs_cml_neg_ft,Ron_hs_cml_pos_ft,Ron_hs_cmh_neg_ft,Ron_hs_cmh_pos_ft,POWERUP,POWERDOWN,RESWORD,SE_VIL,SE_VIH,SE_VIL_FT,SE_VIH_FT)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--  

in float                   : vio, vcore, v18, Vcom_L_lim, Vcom_H_lim, Vdiff_Hs_lim, V_Ron,HS_SiVil,HS_SiVih
in_out integer_test        : devid_it, dnutid_it,RESWORD
--in_out array of float_test : Vil_clk_ft, Vih_clk_ft
in_out array of float_test : Vil_data1_ft, Vih_data1_ft, Vil_data2_ft, Vih_data2_ft, Vil_data3_ft, Vih_data3_ft, Vil_data4_ft, Vih_data4_ft, Vcom_L_ft, Vcom_H_ft
in_out array of float_test : Ron_hs_cml_neg_ft, Ron_hs_cml_pos_ft, Ron_hs_cmh_neg_ft, Ron_hs_cmh_pos_ft,SE_VIL,SE_VIH,SE_VIL_FT,SE_VIH_FT
in boolean                 : POWERUP,POWERDOWN

local

word list[16]     : active_sites
word              : sites, idx, site
multisite integer : reg_rslt_uart[8], reg_rslt_i2c[8]
integer           : idxs, i
float             : Vconf0, Vconf1, inc, Vil1_com_L, Vih1_com_L, Vil1_com_H, Vih1_com_H
multisite lword   : lowword, upperword, data, des_read, des_read0, reg_val15, reg_val, reg_val0, reg_val1
multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val15,resword

float             :SE_HS_Vil_P,SE_HS_Vil_N,SE_HS_Vih_P,SE_HS_Vih_N
multisite boolean : result_L, result_H
multisite boolean : result_L_Vil, result_H_Vil, result_L_Vih, result_H_Vih
multisite boolean : result_L1_Vil, result_H1_Vil, result_L1_Vih, result_H1_Vih

multisite float   : Vil_data1[1], Vih_data1[1], Vil_data2[1], Vih_data2[1], Vil_data3[1], Vih_data3[1], Vil_data4[1], Vih_data4[1], Vcom_L[1], Vcom_H[1]
multisite lword   : hizdel_reg_val, oreg_reg_val

multisite float   : icont1[10], icont2[10], Ron_hs_cml_neg[10], Ron_hs_cmh_neg[10], Ron_hs_cml_pos[10], Ron_hs_cmh_pos[10]
multisite float   :Se_Vih[1],Se_Vil[1]

float             : Vil1_com_L_R, Vih1_com_L_R, Vil1_com_H_R, Vih1_com_H_R

end_local


body

    active_sites = get_active_sites
    sites = word(len(active_sites))  
    current_active_sites = get_active_sites
    --POWER_CONNECT    -- need this for reseting device
    --make sure RSVD pin float (HVVI disconnect)
--    CHAR = TRUE
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!


-----Dut power up function
   DutPowerUp(vio, v18, vcore, "UART", "TP",POWERUP)

   
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)
 
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val[site]  = integer(lowword[site])        
    end_for 

--------Read Resword  or Term_Pres per Umut request  2/2018

    RegRead(SER_ID, SR_CTRL6, 1, upperword, lowword,"SER_UART_Read") 
     for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      resword[site]  = integer(lowword[site])        
    end_for    
    

-----Setup commnunication speed for DES
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(0ms)

----Power up DNUT
--    powerup_dnut_vdd_vterm (0.0V,0.0V) ---turn on VDD and VTERM for DNUT
    powerup_dnut_vdd_vterm (1.2V,1.2V) ---turn on VDD and VTERM for DNUT

  --fpga_Set_DNUT_Pins("FPGA1", CFG2, CFG1, CFG0, PWDN, latch)
     
  fpga_Set_DNUT_Pins("FPGA1", 0 ,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               

---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY   ----FPGA to control communication instead of dps
    close digital cbit FB_RELAY ----connect feedback loop. Connect DNUT CSI pins to DUT CSI pins
    wait(6ms)

    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read expect data = 0x90   
    --wait(200us)
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val0[site]  = integer(reg_val0[site]) 
    end_for 

--------------Turn on loop back to get CSI out of sleep mode

   ------------------------------****************************----------------------------------

   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x84)          -- Force to send out MIPI clocks from DES HS78 0x84

    --reg_val22  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)    -- verify   
   wait(1ms)    -- needed, to initialize mipi blocks to go out of sleep mode 

   -- turn off MIPI clocks from DES
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)            
   -- reg_val23  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)
   -- loop back relays on LB opened
    open digital cbit FB_RELAY                                          ---- disonnect DNUT CSI pins to DUT CSI pins   
   wait(4ms)    --

---Enter testmode 6
   SetTestMode(6, False, "SER_UART_Write")

---this procedure from Mu Li, it is a bit different then HS78
    RegWrite(SER_ID, 16#330, 1, 16#00, 16#06, "SER_UART_Write")         ---- select 2x4

    RegWrite(SER_ID, 16#38, 1, 16#00, 16#80, "SER_UART_Write")          ---- PIN_DEV_EN_0 is set, LP mode 
 
-------setup measure phy2; portB CLK, DO and D1
    RegWrite(SER_ID, 16#337, 1, 16#00, 16#3, "SER_UART_Write")          ---- CNTLL1_TESTmuxSelect 

  --RegRead(SER_ID, 16#337, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms

    RegWrite(SER_ID, 16#336, 1, 16#00, 16#3, "SER_UART_Write")          ---- CNTLL0_TESTmuxSelect 
  --RegRead(SER_ID, 16#336, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms
  -- Setup DEBUG_MODE  
  RegWrite(SER_ID, 16#3E, 1, 16#40, 16#40, "SER_UART_Write")        -- DEBUG_MODE
  wait(1ms)
  --RegRead(SER_ID, 16#3E, 1, upperword, lowword,"SER_UART_Read")   -- verify write above
  --wait(0ms)     
  
-------------HS mode
    RegWrite(SER_ID, 16#38, 1, 16#00, 16#00, "SER_UART_Write")          ---- PIN_DEV_EN_0 is 0, HS mode 
  --RegRead(SER_ID, 16#38, 1, upperword, lowword,"SER_UART_Read")       -- verify write above
  --wait(0ms)
    RegWrite(SER_ID, 16#39, 1, 16#00, 16#01, "SER_UART_Write")          ---- PIN_DEV_EN_1 bit 0 = 1 HS mode 
  --RegRead(SER_ID, 16#39, 1, upperword, lowword,"SER_UART_Read")       -- verify write above
  --wait(0ms)
-------setup measure phy2; portB CLK, DO and D1
    RegWrite(SER_ID, 16#337, 1, 16#00, 16#4, "SER_UART_Write")          ---- CNTLL1_TESTmuxSelect -- LP mode=03, HS mode=04
  --RegRead(SER_ID, 16#337, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms

    RegWrite(SER_ID, 16#336, 1, 16#00, 16#4, "SER_UART_Write")          ---- CNTLL0_TESTmuxSelect -- LP mode=03, HS mode=04
  --RegRead(SER_ID, 16#336, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms)

-----Initial value for easy use
  Vil1_com_L = Vcom_L_lim - (Vdiff_Hs_lim/2.0)
  Vih1_com_L = Vcom_L_lim + (Vdiff_Hs_lim/2.0)
  Vil1_com_H = Vcom_H_lim - (Vdiff_Hs_lim/2.0)
  Vih1_com_H = Vcom_H_lim + (Vdiff_Hs_lim/2.0)  

-----------Setup PHY0 and PHY2 Data Lanes HS output low
-----Use ppmu to measure  can be changed to pattern later 
-----Connect CSI pins to ppmu
    disconnect digital pin SER_CSI_PINS from dcl
    connect digital pin SER_CSI_PINS to ppmu

------------ turn off all MFPs pin of interest, function search later will turn on one compare at at time
     set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK + SER_GPIO3_RCLKOUT + SER_GPO4_CFG0 + SER_GPO5_CFG1 modes to comparator disable all fails    
     set digital pin SER_GPIO8_SCK + SER_GPIO9_SD + SER_GPIO10_CNTL0_WSOR_SDA2 + SER_GPIO11_CNTL1_SCKOR_SCL2 + SER_GPIO12_MS1_SDOR + SER_GPIO15_LMN2_SS2_RO modes to comparator disable all fails  

---turn on only intest pins for set 1: DA2,DA3,CKB,DB0,DB1 and DB2
     set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO8_SCK + SER_GPIO9_SD + SER_GPIO10_CNTL0_WSOR_SDA2  modes to comparator enable all fails 
 
     set digital ppmu SER_DA2P + SER_DA3P + SER_DB0P + SER_DB1P + SER_CKBP  to fv Vil1_com_L  vmax 2v  measure i max 20ma             --------------- Set P < N expect low
     set digital ppmu SER_DA2N + SER_DA3N + SER_DB0N + SER_DB1N + SER_CKBN to  fv Vih1_com_L vmax 2v  measure i max 20ma
     wait(1ms) 
     execute digital pattern "Mipi_HS_Vin" at label "P_low_N_hi_set1" run to end into result_L  

     for idx = 1 to sites do
         site = active_sites[idx]     
         if result_L[site] then
            Vil_data1[site,1] = -(Vdiff_Hs_lim)
         else
            Vil_data1[site,1] = -1.0
         endif              
      end_for 

---Measure high low Vcm
     set digital ppmu SER_DA2P + SER_DA3P + SER_DB0P + SER_DB1P + SER_CKBP  to fv Vih1_com_L  vmax 2v  measure i max 20ma             --------------- Set P > N reset output logic 
     set digital ppmu SER_DA2N + SER_DA3N + SER_DB0N + SER_DB1N + SER_CKBN to  fv Vil1_com_L vmax 2v  measure i max 20ma
    wait(1ms)
     execute digital pattern "Mipi_HS_Vin" at label "P_hi_N_low_set1" run to end into result_H  

     for idx = 1 to sites do
         site = active_sites[idx]     
         if result_H[site] then
            Vih_data1[site,1] = (Vdiff_Hs_lim)
         else
            Vih_data1[site,1] = 1.0
         endif   
     end_for       
---Test set 1 with high Vcm  for low value

     set digital ppmu SER_DA2P + SER_DA3P + SER_DB0P + SER_DB1P + SER_CKBP  to fv Vil1_com_H  vmax 2v  measure i max 20ma             --------------- Set P < N expect low High Vcm
     set digital ppmu SER_DA2N + SER_DA3N + SER_DB0N + SER_DB1N + SER_CKBN to  fv Vih1_com_H vmax 2v  measure i max 20ma
     wait(1ms) 
     execute digital pattern "Mipi_HS_Vin" at label "P_low_N_hi_set1" run to end into result_L  

     for idx = 1 to sites do
         site = current_active_sites[idx]     
         if result_L[site] then
            Vil_data2[site,1] = -(Vdiff_Hs_lim)
         else
            Vil_data2[site,1] = -1.0
         endif              
      end_for   

---Test set 1 with high Vcm  for hi value

     set digital ppmu SER_DA2P + SER_DA3P + SER_DB0P + SER_DB1P + SER_CKBP  to fv Vih1_com_H  vmax 2v  measure i max 20ma             --------------- Set P > N expect hi High Vcm
     set digital ppmu SER_DA2N + SER_DA3N + SER_DB0N + SER_DB1N + SER_CKBN to  fv Vil1_com_H vmax 2v  measure i max 20ma
     wait(1ms) 
     execute digital pattern "Mipi_HS_Vin" at label "P_hi_N_low_set1" run to end into result_H  

     for idx = 1 to sites do
         site = current_active_sites[idx]     
         if result_H[site] then
            Vih_data2[site,1] = (Vdiff_Hs_lim)
         else
            Vih_data2[site,1] = -1.0
         endif              
      end_for   


-----Test singled end ViL ViH for high speed required by DE 7/2018 MT

    SE_HS_Vil_N = HS_SiVil                
    SE_HS_Vil_P = 70mV *2.0 - HS_SiVil

----- Setup Vil with P> N expect high
    set digital ppmu SER_DA2P + SER_DA3P + SER_DB0P + SER_DB1P + SER_CKBP  to fv SE_HS_Vil_P  vmax 2v  measure i max 20ma             --------------- Set P > N expect high
    set digital ppmu SER_DA2N + SER_DA3N + SER_DB0N + SER_DB1N + SER_CKBN to  fv SE_HS_Vil_N vmax 2v  measure i max 20ma
    wait(30uS)
    execute digital pattern "Mipi_HS_Vin" at label "P_hi_N_low_set1" run to end into result_H_Vil  
 ----- Setup Vil with N> P expect low
    set digital ppmu SER_DA2P + SER_DA3P + SER_DB0P + SER_DB1P + SER_CKBP  to fv SE_HS_Vil_N  vmax 2v  measure i max 20ma             --------------- Set N > P expect low 
    set digital ppmu SER_DA2N + SER_DA3N + SER_DB0N + SER_DB1N + SER_CKBN to  fv SE_HS_Vil_P vmax 2v  measure i max 20ma
    wait(30uS)
     execute digital pattern "Mipi_HS_Vin" at label "P_low_N_hi_set1" run to end into result_L_Vil
----now test Vih single ended
    SE_HS_Vih_P = HS_SiVih                
    SE_HS_Vih_N = 330mV *2.0 - HS_SiVih
----- Setup ViH with P> N expect high
    set digital ppmu SER_DA2P + SER_DA3P + SER_DB0P + SER_DB1P + SER_CKBP  to fv SE_HS_Vih_P  vmax 2v  measure i max 20ma             --------------- Set P > N expect high
    set digital ppmu SER_DA2N + SER_DA3N + SER_DB0N + SER_DB1N + SER_CKBN to  fv SE_HS_Vih_N vmax 2v  measure i max 20ma
    wait(30uS)
    execute digital pattern "Mipi_HS_Vin" at label "P_hi_N_low_set1" run to end into result_H_Vih  
 ----- Setup ViH with N> P expect low
    set digital ppmu SER_DA2P + SER_DA3P + SER_DB0P + SER_DB1P + SER_CKBP  to fv SE_HS_Vih_N  vmax 2v  measure i max 20ma             --------------- Set N > P expect low 
    set digital ppmu SER_DA2N + SER_DA3N + SER_DB0N + SER_DB1N + SER_CKBN to  fv SE_HS_Vih_P vmax 2v  measure i max 20ma
    wait(30uS)
     execute digital pattern "Mipi_HS_Vin" at label "P_low_N_hi_set1" run to end into result_L_Vih







-------------------------------






---Switch to set 2 -----
----Swith to Phy1 and Phy3

    RegWrite(SER_ID, 16#337, 1, 16#00, 16#14, "SER_UART_Write")          ---- CNTLL1_TESTmuxSelect -- LP mode=03, HS mode=04
  --RegRead(SER_ID, 16#337, 1, upperword, lowword,"SER_UART_Read")      -- verify write above
  --wait(0ms

    RegWrite(SER_ID, 16#336, 1, 16#00, 16#14, "SER_UART_Write")          ---- CNTLL0_TESTmuxSelect -- LP mode=03, HS mode=04
  --RegRead(SER_ID, 16#336, 1, upperword, lowword,"SER_UART_Read")      -- verify write above

----Turn off compare pins for set 1  and turn on for set 2 
     set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO8_SCK + SER_GPIO9_SD + SER_GPIO10_CNTL0_WSOR_SDA2  modes to comparator disable all fails
     set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB + SER_GPIO2_GPO_SCLK +  SER_GPIO8_SCK + SER_GPIO9_SD  modes to comparator enable all fails

     set digital ppmu SER_DA0P + SER_DA1P + SER_DB2P + SER_DB3P + SER_CKAP  to fv Vil1_com_H  vmax 2v  measure i max 20ma             --------------- Set P < N expect low High Vcm
     set digital ppmu SER_DA0N + SER_DA1N + SER_DB2N + SER_DB3N + SER_CKAN to  fv Vih1_com_H vmax 2v  measure i max 20ma
     wait(1ms) 
     execute digital pattern "Mipi_HS_Vin" at label "P_low_N_hi_set2" run to end into result_L  

     for idx = 1 to sites do
         site = current_active_sites[idx]     
         if result_L[site] then
            Vil_data4[site,1] = -(Vdiff_Hs_lim)
         else
            Vil_data4[site,1] = -1.0
         endif              
      end_for   

------Set 2 high Vcm test output hi

     set digital ppmu SER_DA0P + SER_DA1P + SER_DB2P + SER_DB3P + SER_CKAP  to fv Vih1_com_H  vmax 2v  measure i max 20ma             --------------- Set P > N expect 1 High Vcm
     set digital ppmu SER_DA0N + SER_DA1N + SER_DB2N + SER_DB3N + SER_CKAN to  fv Vil1_com_H vmax 2v  measure i max 20ma
     wait(1ms) 
     execute digital pattern "Mipi_HS_Vin" at label "P_hi_N_low_set2" run to end into result_L  

     for idx = 1 to sites do
         site = current_active_sites[idx]     
         if result_H[site] then
            Vih_data4[site,1] = (Vdiff_Hs_lim)
         else
            Vih_data4[site,1] = 1.0
         endif              
      end_for  

----Change to low Vcm

     set digital ppmu SER_DA0P + SER_DA1P + SER_DB2P + SER_DB3P + SER_CKAP  to fv Vil1_com_L  vmax 2v  measure i max 20ma             --------------- Set N > P expect low low Vcm
     set digital ppmu SER_DA0N + SER_DA1N + SER_DB2N + SER_DB3N + SER_CKAN to  fv Vih1_com_L vmax 2v  measure i max 20ma
     wait(1ms)
     execute digital pattern "Mipi_HS_Vin" at label "P_low_N_hi_set2" run to end into result_L  

     for idx = 1 to sites do
         site = current_active_sites[idx]     
         if result_L[site] then
            Vil_data3[site,1] = -(Vdiff_Hs_lim)
         else
            Vil_data3[site,1] = -1.0
         endif              
      end_for   
---test for 1 at low Vcm
     set digital ppmu SER_DA0P + SER_DA1P + SER_DB2P + SER_DB3P + SER_CKAP  to fv Vih1_com_L  vmax 2v  measure i max 20ma             --------------- Set N < P expect hi low Vcm
     set digital ppmu SER_DA0N + SER_DA1N + SER_DB2N + SER_DB3N + SER_CKAN to  fv Vil1_com_L vmax 2v  measure i max 20ma
     wait(1ms)
     execute digital pattern "Mipi_HS_Vin" at label "P_hi_N_low_set2" run to end into result_H  

     for idx = 1 to sites do
         site = current_active_sites[idx]     
         if result_H[site] then
            Vih_data3[site,1] = (Vdiff_Hs_lim)
         else
            Vih_data3[site,1] = 1.0
         endif              
      end_for   


-----Test singled end ViL ViH for high speed required by DE 7/2018 MT

    SE_HS_Vil_N = HS_SiVil                
    SE_HS_Vil_P = 70mV *2.0 - HS_SiVil
----- Setup Vil with P> N expect high
    set digital ppmu SER_DA0P + SER_DA1P + SER_DB2P + SER_DB3P + SER_CKAP to fv SE_HS_Vil_P  vmax 2v  measure i max 20ma             --------------- Set P > N expect high group 2
    set digital ppmu SER_DA0N + SER_DA1N + SER_DB2N + SER_DB3N + SER_CKAN to fv SE_HS_Vil_N vmax 2v  measure i max 20ma
    wait(30uS)
    execute digital pattern "Mipi_HS_Vin" at label "P_hi_N_low_set2" run to end into result_H1_Vil  
 ----- Setup Vil with N> P expect low
    set digital ppmu SER_DA0P + SER_DA1P + SER_DB2P + SER_DB3P + SER_CKAP  to fv SE_HS_Vil_N  vmax 2v  measure i max 20ma             --------------- Set N > P expect low group 2
    set digital ppmu SER_DA0N + SER_DA1N + SER_DB2N + SER_DB3N + SER_CKAN to  fv SE_HS_Vil_P vmax 2v  measure i max 20ma
    wait(30uS)
     execute digital pattern "Mipi_HS_Vin" at label "P_low_N_hi_set2" run to end into result_L1_Vil
----now test Vih single ended
    SE_HS_Vih_P = HS_SiVih                
    SE_HS_Vih_N = 330mV *2.0 - HS_SiVih
 --    SE_HS_Vih_N = HS_SiVih                
--     SE_HS_Vih_P = 330mV *2.0 - HS_SiVih
----- Setup ViH with P> N expect high
    set digital ppmu SER_DA0P + SER_DA1P + SER_DB2P + SER_DB3P + SER_CKAP to fv SE_HS_Vih_P  vmax 2v  measure i max 20ma             --------------- Set P > N expect high
    set digital ppmu SER_DA0N + SER_DA1N + SER_DB2N + SER_DB3N + SER_CKAN to  fv SE_HS_Vih_N vmax 2v  measure i max 20ma
    wait(30uS)
    execute digital pattern "Mipi_HS_Vin" at label "P_hi_N_low_set2" run to end into result_H1_Vih  
 ----- Setup ViH with N> P expect low
    set digital ppmu SER_DA0P + SER_DA1P + SER_DB2P + SER_DB3P + SER_CKAP  to fv SE_HS_Vih_N  vmax 2v  measure i max 20ma             --------------- Set N > P expect low 
    set digital ppmu SER_DA0N + SER_DA1N + SER_DB2N + SER_DB3N + SER_CKAN to  fv SE_HS_Vih_P vmax 2v  measure i max 20ma
    wait(30uS)
     execute digital pattern "Mipi_HS_Vin" at label "P_low_N_hi_set2" run to end into result_L1_Vih
---- For datalog
     for idx = 1 to sites do
         site = current_active_sites[idx]     
         if result_H_Vil[site]  and result_H1_Vil[site] and result_H_Vih[site]  and result_H1_Vih[site] then
            Se_Vih[site,1] = 1.0         
         else
            Se_Vih[site,1] = 0.0
         endif              
         if result_L_Vil[site]  and result_L1_Vil[site] and result_L_Vih[site]  and result_L1_Vih[site] then
            Se_Vil[site,1] = 1.0         
         else
            Se_Vil[site,1] = 0.0
         endif 
      end_for   



-------------------------------
----Reset differential voltage for measure R
--V_Ron
  Vil1_com_L_R = Vcom_L_lim - (V_Ron/2.0)
  Vih1_com_L_R = Vcom_L_lim + (V_Ron/2.0)
  Vil1_com_H_R = Vcom_H_lim - (V_Ron/2.0)
  Vih1_com_H_R = Vcom_H_lim + (V_Ron/2.0)  




-----Done with threshold measure termination res
     set digital ppmu SER_DA0P + SER_DA1P + SER_DA2P + SER_DA3P  + SER_CKAP + SER_DB0P + SER_DB1P + SER_DB2P + SER_DB3P  + SER_CKBP to fv Vih1_com_H_R vmax 2v  measure i max 2ma
     set digital ppmu SER_DA0N + SER_DA1N + SER_DA2N + SER_DA3N  + SER_CKAN  + SER_DB0N + SER_DB1N + SER_DB2N + SER_DB3N  + SER_CKBN to fv Vil1_com_H_R  vmax 1v  measure i max 20ma
    wait(1mS)
     measure digital ppmu SER_DA0P + SER_DA1P + SER_DA2P + SER_DA3P  + SER_CKAP + SER_DB0P + SER_DB1P + SER_DB2P + SER_DB3P  + SER_CKBP current imax 2ma average 20 delay 5us into  icont1
--    RegRead(SER_ID, SR_CTRL6, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device


     for idx = 1 to sites do
         site = current_active_sites[idx]              
            Ron_hs_cmh_pos[site,1] = V_Ron/icont1[site,1]
            Ron_hs_cmh_pos[site,2] = V_Ron/icont1[site,2]
            Ron_hs_cmh_pos[site,3] = V_Ron/icont1[site,3]                   
            Ron_hs_cmh_pos[site,4] = V_Ron/icont1[site,4]
            Ron_hs_cmh_pos[site,5] = V_Ron/icont1[site,5]
            Ron_hs_cmh_pos[site,6] = V_Ron/icont1[site,6]                   
            Ron_hs_cmh_pos[site,7] = V_Ron/icont1[site,7]
            Ron_hs_cmh_pos[site,8] = V_Ron/icont1[site,8]
            Ron_hs_cmh_pos[site,9] = V_Ron/icont1[site,9]                   
            Ron_hs_cmh_pos[site,10] = V_Ron/icont1[site,10]
     end_for

------Measure Ron with N higher than P in Vcm H

    set digital ppmu SER_DA0P + SER_DA1P + SER_DA2P + SER_DA3P  + SER_CKAP + SER_DB0P + SER_DB1P + SER_DB2P + SER_DB3P  + SER_CKBP to fv Vil1_com_H_R vmax 2v  measure i max 20ma
     set digital ppmu SER_DA0N + SER_DA1N + SER_DA2N + SER_DA3N  + SER_CKAN  + SER_DB0N + SER_DB1N + SER_DB2N + SER_DB3N  + SER_CKBN to fv Vih1_com_H_R  vmax 1v  measure i max 20ma
    wait(1mS)
     measure digital ppmu SER_DA0N + SER_DA1N + SER_DA2N + SER_DA3N  + SER_CKAN  + SER_DB0N + SER_DB1N + SER_DB2N + SER_DB3N  + SER_CKBN current imax 2ma average 20 delay 5us into  icont1

     for idx = 1 to sites do
         site = current_active_sites[idx]              
            Ron_hs_cmh_neg[site,1] = V_Ron/icont1[site,1]
            Ron_hs_cmh_neg[site,2] = V_Ron/icont1[site,2]
            Ron_hs_cmh_neg[site,3] = V_Ron/icont1[site,3]                   
            Ron_hs_cmh_neg[site,4] = V_Ron/icont1[site,4]
            Ron_hs_cmh_neg[site,5] = V_Ron/icont1[site,5]
            Ron_hs_cmh_neg[site,6] = V_Ron/icont1[site,6]                   
            Ron_hs_cmh_neg[site,7] = V_Ron/icont1[site,7]
            Ron_hs_cmh_neg[site,8] = V_Ron/icont1[site,8]
            Ron_hs_cmh_neg[site,9] = V_Ron/icont1[site,9]                   
            Ron_hs_cmh_neg[site,10] = V_Ron/icont1[site,10]
     end_for

------Measure Ron with N higher than P in Vcm L
    set digital ppmu SER_DA0P + SER_DA1P + SER_DA2P + SER_DA3P  + SER_CKAP + SER_DB0P + SER_DB1P + SER_DB2P + SER_DB3P  + SER_CKBP to fv Vil1_com_L_R vmax 2v  measure i max 20ma
     set digital ppmu SER_DA0N + SER_DA1N + SER_DA2N + SER_DA3N  + SER_CKAN  + SER_DB0N + SER_DB1N + SER_DB2N + SER_DB3N  + SER_CKBN to fv Vih1_com_L_R  vmax 1v  measure i max 20ma
    wait(1mS)
     measure digital ppmu SER_DA0N + SER_DA1N + SER_DA2N + SER_DA3N  + SER_CKAN  + SER_DB0N + SER_DB1N + SER_DB2N + SER_DB3N  + SER_CKBN current imax 2ma average 20 delay 5us into  icont1

     for idx = 1 to sites do
         site = current_active_sites[idx]              
            Ron_hs_cml_neg[site,1] = V_Ron/icont1[site,1]
            Ron_hs_cml_neg[site,2] = V_Ron/icont1[site,2]
            Ron_hs_cml_neg[site,3] = V_Ron/icont1[site,3]                   
            Ron_hs_cml_neg[site,4] = V_Ron/icont1[site,4]
            Ron_hs_cml_neg[site,5] = V_Ron/icont1[site,5]
            Ron_hs_cml_neg[site,6] = V_Ron/icont1[site,6]                   
            Ron_hs_cml_neg[site,7] = V_Ron/icont1[site,7]
            Ron_hs_cml_neg[site,8] = V_Ron/icont1[site,8]
            Ron_hs_cml_neg[site,9] = V_Ron/icont1[site,9]                   
            Ron_hs_cml_neg[site,10] = V_Ron/icont1[site,10]
     end_for
------Measure Ron with P higher than N in Vcm L
     set digital ppmu SER_DA0P + SER_DA1P + SER_DA2P + SER_DA3P  + SER_CKAP + SER_DB0P + SER_DB1P + SER_DB2P + SER_DB3P  + SER_CKBP to fv Vih1_com_L_R vmax 2v  measure i max 20ma
     set digital ppmu SER_DA0N + SER_DA1N + SER_DA2N + SER_DA3N  + SER_CKAN  + SER_DB0N + SER_DB1N + SER_DB2N + SER_DB3N  + SER_CKBN to fv Vil1_com_L_R  vmax 1v  measure i max 20ma
    wait(1mS)
     measure digital ppmu SER_DA0P + SER_DA1P + SER_DA2P + SER_DA3P  + SER_CKAP + SER_DB0P + SER_DB1P + SER_DB2P + SER_DB3P  + SER_CKBP current imax 2ma average 20 delay 5us into  icont1

     for idx = 1 to sites do
         site = current_active_sites[idx]              
            Ron_hs_cml_pos[site,1] = V_Ron/icont1[site,1]
            Ron_hs_cml_pos[site,2] = V_Ron/icont1[site,2]
            Ron_hs_cml_pos[site,3] = V_Ron/icont1[site,3]                   
            Ron_hs_cml_pos[site,4] = V_Ron/icont1[site,4]
            Ron_hs_cml_pos[site,5] = V_Ron/icont1[site,5]
            Ron_hs_cml_pos[site,6] = V_Ron/icont1[site,6]                   
            Ron_hs_cml_pos[site,7] = V_Ron/icont1[site,7]
            Ron_hs_cml_pos[site,8] = V_Ron/icont1[site,8]
            Ron_hs_cml_pos[site,9] = V_Ron/icont1[site,9]                   
            Ron_hs_cml_pos[site,10] = V_Ron/icont1[site,10]
     end_for

-------------- Power Down ---------------------------
    if POWERDOWN then
       fpga_Set_DNUT_Pins("FPGA1", 0 ,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)

---Open relay to connect FPGA to control TX/RX on DNUT
        open cbit  DNUT_RXTX_RELAY
        disconnect digital pin SER_CSI_PINS from ppmu
--        connect digital pin SER_CSI_PINS to dcl  
        powerup_dnut_vdd_vterm (0.0V,0.0V) ---turn off VDD and VTERM for DNUT
        wait(1ms)
        powerdown_device(POWERDOWN)  

    end_if

---for datalog threhold values
  Vcom_L = Vcom_L_lim
  Vcom_H = Vcom_H_lim
-------------- Datalog Results ----------------
  test_value ireg_val with devid_it
  test_value ireg_val0 with dnutid_it
    
  test_value Vil_data1 with Vil_data1_ft    -- common mode low  neg diff ( N>P) set 1
  test_value Vil_data2 with Vil_data2_ft    -- common mode high neg diff ( N>P) set 1
  test_value Vil_data3 with Vil_data3_ft    -- common mode low  neg diff ( N>P) set 2
  test_value Vil_data4 with Vil_data4_ft    -- common mode high neg diff ( N>P) set 2  
  
  test_value Vih_data1 with Vih_data1_ft    -- common mode low  pos diff ( P>N) set 1
  test_value Vih_data2 with Vih_data2_ft    -- common mode high pos diff ( P>N) set 1
  test_value Vih_data3 with Vih_data3_ft    -- common mode low  pos diff ( P>N) set 2
  test_value Vih_data4 with Vih_data4_ft    -- common mode high pos diff ( P>N) set 2  

  test_value Vcom_L with Vcom_L_ft          -- common mode Low
  test_value Vcom_H with Vcom_H_ft          -- common mode High
     
  test_value Ron_hs_cml_neg with Ron_hs_cml_neg_ft    -- Ron at common mode Low ( N>P)
  test_value Ron_hs_cml_pos with Ron_hs_cml_pos_ft    -- Ron at common mode Low ( P>N)
  test_value Ron_hs_cmh_neg with Ron_hs_cmh_neg_ft    -- Ron at common mode Low ( N>P)
  test_value Ron_hs_cmh_pos with Ron_hs_cmh_pos_ft    -- Ron at common mode high ( P>N) 
   
  test_value resword with RESWORD

  test_value Se_Vil with SE_VIL    -- common mode low  neg diff ( N>P) set 1
  test_value Se_Vih with SE_VIH
  test_value msfloat(HS_SiVil) with SE_VIL_FT          -- common mode Low
  test_value msfloat(HS_SiVih) with SE_VIH_FT      -- common mode High


end_body
procedure FeedBack_LoopTest(vcore, vio, v18, devid_it, dnutid_it, ser_lock_it, des_lock_it, bad_pat_it, good_pat_it,POWERUP,POWERDOWN,TP_COAX,TX_SPD,RX_SPD,MIPI_SPD,CSI_MODE,NUMB_LANES,Link_Lock_dly,FW_SPD,RW_SPD,CSI_SPD,NUMBER_LANES)

--------------------------------------------------------------------------------
in float            : vcore, vio, v18
in_out integer_test : devid_it, dnutid_it, bad_pat_it, good_pat_it, ser_lock_it, des_lock_it,NUMBER_LANES
in boolean          : POWERUP,POWERDOWN
in string[20]       : TP_COAX,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,MIPI_SPD,Link_Lock_dly
in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,RW_SPD,CSI_SPD


local



  multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

 multisite lword    : RLMSA3_A,RLMSA3_B, RLMSA2_A,RLMSA2_B, RLM89_A,RLM89_B, RLM88_A, RLM88_B, RLM8A_A,RLM8A_B
 multisite lword    : DES_RLMSA3_A, DES_RLMSA3_B, DES_RLMSA2_A,DES_RLMSA2_B, DES_RLM89_A,DES_RLM89_B, DES_RLM88_A, DES_RLM88_B, DES_RLM8A_A,DES_RLM8A_B

 multisite lword    : RLMSC_A,RLMSC_B, RLMSD_A,RLMSD_B, RLMSE_A,RLMSE_B, RLMSF_A,RLMSF_B, RLMS10_A,RLMS10_B, RLMS11_A,RLMS11_B, RLMS13_A,RLMS13_B, RLMS2E_A,RLMS2E_B
 multisite lword    : DES_RLMSC_A,DES_RLMSC_B, DES_RLMSD_A,DES_RLMSD_B, DES_RLMSE_A,DES_RLMSE_B, DES_RLMSF_A,DES_RLMSF_B, DES_RLMS10_A,DES_RLMS10_B, DES_RLMS11_A,DES_RLMS11_B,DES_RLMS13_A,DES_RLMS13_B, DES_RLMS2E_A,DES_RLMS2E_B
 multisite lword    :  array1[26], array2[26]
    string[20]      :  infile[4],tempp
end_local


body
  

    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
   DutPowerUp(vio, v18, vcore, "UART", "COAX_GMSL2",POWERUP)

    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val[site]  = integer(lowword[site]) 
    end_for 
 
---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY

--  CRYSTAL running now, we should have LOCK on DES site???
--  Answer is NO on rev1 device (bug), but should be fixed on rev2 device  
    
    hizdel_reg_val = fpga_read_register("FPGA1", HIZDEL_REG)       -- should read back decimal 6000 if FPGA working OK
    wait(0ms)
    
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(0ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
    powerup_dnut_vdd_vterm(1.2,1.2)

    
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
    fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
    wait(6ms)
    
    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg
    wait(0ms)
      
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read    
    wait(200us)
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val0[site]  = integer(reg_val0[site]) 
    end_for     
    
 ---------close CSI feedback loop
    close cbit  FB_RELAY


--    SetupGmslLinkSpeed(TX_SPD,RX_SPD,TP_COAX)

----Set SER and DES for coax or tp mode
    if TP_COAX = "TP" then
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
    else
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
    end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

       if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
       elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

      if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
      elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
      elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
     end_if 
    ser_link_speed_code = ser_rx_speed + ser_tx_speed
    des_link_speed_code = des_rx_speed + des_tx_speed
-----TP only work up to 3GHz
    if TP_COAX = "TP" and TX_SPD >3GHz then
        
        ----put print statement on screen to notify engineer ---- do this later
        ser_link_speed_code   = 0   ---fail part
        des_link_speed_code   = 0
    end_if 
----Program link rate

    RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed



-----Write to reg10 to update link speed setting 
   wait(60ms)    
    -- write Reg0x10 to update to COAX mode
    RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#30, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89
    wait(1ms)        

--    RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)
-----No need to repeat at DES
--     fpga_UART_Write("FPGA1","DES", DESA_ID, 16#10, 1, 0x30)
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x10, 1)      -- self adjust back to 0x01
--     wait(0ms)
     
--------------Check for lock, error bit
----Currently, HS89 rev 1.5G error bit always on.
----at fwd_speed = 6.0G, REV_SPEED = 0.75 then no error.
----at fwd_speed = 3.0G, REV_SPEED = 0.375 then no error.
---------------------------------------------------------------------------------------------------------------------------------------------

   wait(Link_Lock_dly)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!

   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
   wait(0ms)



  for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val1[site]  = integer(lowword[site])
      ireg_val15[site] = integer(reg_val15[site])      
   end_for    



 
 
   -------------------------DO NOT DELETE, DEBUGGING-------------------------
   -- try to read across the link to SER from DNUT using FPGA, FPGA timeout for read back is hardcode to 128uS
   des_read =  fpga_UART_Read("FPGA1", "DES", SER_ID, 0x00, 1)      -- SER_ID read from DNUT UART mode, expect 0x80
   wait(0ms)

----------Now let do loopback test
  -- setup SER/DES for loopback test here
   
  --RegWrite(DevId, RegAddr, ByteCnt, DataUpperWord, DataLowerWord, PatternName)
------MIPI loopback  parameters and error setting for SER

   RegWrite( SER_ID, SR_REG2, 1,0x00, 0x63, "SER_UART_Write")                                             ----Enable video Y and X
   RegWrite( SER_ID, SR_FRONTTOP_0, 1,0x00, 0x7C, "SER_UART_Write")                                        ----Setup CSI port and pipe lines X,Y,Z,U0 reg =0x308
   RegWrite( SER_ID, SR_FRONTTOP_9 , 1,0x00, 0x42, "SER_UART_Write")                                       ----Setup pipeline Y and Z reg =0x311,

  RegWrite(SER_ID, SR_MIPI_LPB0 , 1, 16#00, 16#08, "SER_UART_Write")                                      -- 16#0370    PRBS patterns ????
  RegWrite(SER_ID, SR_MIPI_LPB1, 1, 16#00, 16#02, "SER_UART_Write")                                       --  16#0371   2 lines per frame for loop back test

------Test bench does not have LSB
  RegWrite(SER_ID, SR_MIPI_LPB2, 1, 16#00, 16#02, "SER_UART_Write")                                       -- 16#0372    Pixel count lsb byte for MIPI loop back test current set to 2?
  RegWrite(SER_ID, SR_MIPI_LPB3, 1, 16#00, 16#02, "SER_UART_Write")                                       -- 16#0373    Pixel count Msb byte for MIPI loop back test current set to 2?

  
 ------- Set MIPI_RX registers number of lanes 2x4 mode
  number_of_lane = (NUMB_LANES -1) | ((NUMB_LANES -1) <<4)                                                 ----- Convert number of lanes from pass parameter to code for writing into reg 
--  des_numb_lane = (NUMB_LANES -1) | ((NUMB_LANES -1) <<6)
  des_numb_lane = ((NUMB_LANES -1) <<6)
   if (CSI_MODE = "2X4") or (CSI_MODE = "2x4") then   
        ser_csi_mode = 0x06                                                                              ------2x4 mode   
    elseif (CSI_MODE = "2X4") or( CSI_MODE = "2x4") then
        des_csi_mode = 0x03                                                                             ------2x2 mode
    end_if  
  
  RegWrite(SER_ID, SR_MIPI_RX0, 1, 16#00, 16#86, "SER_UART_Write")                                       ------ 16#0330    2X4 A and B ports, hs89 need to use DSI
  RegWrite(SER_ID, SR_MIPI_RX1, 1, 16#00, number_of_lane, "SER_UART_Write")                              ------ 16#0331      lanes for cntrl0 and cntrl1 Use this reg to changing number of lane
  RegWrite(SER_ID, SR_MIPI_RX2, 1, 16#00, 16#4E, "SER_UART_Write")                                       ------- 16#0332    Phy1/phy0 lane map 
  RegWrite(SER_ID, SR_MIPI_RX3, 1, 16#00, 16#E4, "SER_UART_Write")                                       ------- 16#0333    Phy2/phy3 lane map 

---------------------Now setup DES------
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_RX0_1, 1, 16#01)                                          ------- 16#51  Receive packet with Select stream ID
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_RX0_2, 1, 16#02)                                          ------- 16#52  Receive packet with Select stream ID

----# Turn off unused phys (disable phy 2/3)		
--   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY2, 1, 16#60)                                      ------- 16#332  turn off phy2 and phy3 ???? may be for HS78 viet's product because it has only 1 port 2x4
                                                                                                         ---For HS89 no need    
---# CSI configuration
   if (CSI_MODE = "2X4") or (CSI_MODE = "2x4") then   
        des_csi_mode = 0x04                                                                              ------2x4 mode   
    elseif (CSI_MODE = "1X4") or( CSI_MODE = "1x4") then
        des_csi_mode = 0x02                                                                             ------1x4 mode
    end_if
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY0, 1,des_csi_mode )                               ------- 16#330  PORT CONFIG 2X4,1X4... and forced CSI clock

----### number of CSI lanes mapping

   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY3, 1,0x4E )                               ------- 16#333  Lane map
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY4, 1,0xE4 )                               ------- 16#334  lane map
   
----### number of CSI lanes 

   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX10_44A, 1,des_numb_lane )                               ------- 16#44A  number of lane CNTL1
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX10_48A, 1,des_numb_lane )                               ------- 16#44A  number of lane CNTL2


----### CSI clk speed 
    mipi_speed = lword(MIPI_SPD / 100.0e6)| 0x20
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP25, 1, mipi_speed)                                ------- 16#320  CSI speed
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP28, 1, mipi_speed)                                ------- 16#323  CSI speed

----### enable CSI clk

   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY0, 1, (des_csi_mode | 0x80))                               ------- 16#330  PORT CONFIG 2X4,1X4... and forced CSI clock 
 
--     RegRead(SER_ID,16#10A , 1, upperword, lowword,"SER_UART_Read")    --       
--     RegRead(SER_ID, 16#112, 1, upperword, lowword,"SER_UART_Read")    --   
--     RegRead(SER_ID,16#102 , 1, upperword, lowword,"SER_UART_Read")    --       
--     RegRead(SER_ID,16#11A , 1, upperword, lowword,"SER_UART_Read")    --
    wait(0)
 ------######loop back test-----

   RegWrite(SER_ID, SR_MIPI_LPB0 , 1, 16#00, 16#6F, "SER_UART_Write")                                      -- 16#0370    select bad pattern
   wait(100ms)
--  RegRead(SER_ID, 16#0370, 1, upperword, lowword,"SER_UART_Read")                                         -- verify write above
  --wait(0ms)
 
  RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, lowword,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
  wait(200us)
--  RegRead(SER_ID, 16#010A, 1, upperword, lowword,"SER_UART_Read")   

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val_ser_bad[site]  = integer(lowword[site])    
    end_for 
  

  RegWrite(SER_ID,SR_MIPI_LPB0 , 1, 16#00, 16#6B, "SER_UART_Write")                                       -- select GOOD pattern  (PRBS)
  wait(100ms) 
    
  RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, lowword,"SER_UART_Read")                                       --16#0374 should see NO BIT high, meaning PASS THE TEST   
  wait(200us)   

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val_ser_good[site]  = integer(lowword[site])
    end_for 

  
 --  for idx=1 to sites do
--        site = current_active_sites[idx]
--        if (ireg_val_ser_bad[site] >15) AND (ireg_val_ser_good[site] < 1) then 
--            LBDONE[site] = 1
--        else
--            LBDONE[site] = 0
--        endif
--   endfor  
      

   -- turn off MIPI clocks from DES
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)            
   -- reg_val23  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)
   -- loop back relays on LB opened
--   fpga_cbit_control("FPGA1", 2#0000)      -- control FPGA cbits 2#0000  (cb4, cb3, cb2, cb1)   
     open cbit CB2_SLDC                 --OVI_RELAYS 
     open cbit COAXB_M_RELAY            --OVI_RELAYS
     open cbit  FB_RELAY
-------------- Power Down ---------------------------
    if (POWERDOWN) then

        set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
        powerdown_device(POWERDOWN)
      end_if 
 open cbit  FB_RELAY
 open cbit  DNUT_RXTX_RELAY
    test_value ireg_val  with devid_it 
    test_value ireg_val0 with dnutid_it
    test_value ireg_val1 with ser_lock_it
    test_value ireg_val15 with des_lock_it        
    test_value ireg_val_ser_bad  with bad_pat_it 
    test_value ireg_val_ser_good with good_pat_it          
--    test_value LBDONE  with lbdone

    test_value TX_SPD with FW_SPD     
    test_value RX_SPD with RW_SPD  
    test_value MIPI_SPD with CSI_SPD
    test_value number_of_lanes_test with NUMBER_LANES


 end_body



procedure TEST_WCICC_LinkPrbs(vcore, vio, v18, devid_it, dnutid_it, ser_lock_it, des_lock_it, bad_pat_it, good_pat_it,POWERUP,POWERDOWN,TP_COAX,TX_SPD,RX_SPD,Link_Lock_dly)

--------------------------------------------------------------------------------
in float            : vcore, vio, v18
in_out integer_test : devid_it, dnutid_it, bad_pat_it, good_pat_it, ser_lock_it, des_lock_it---,NUMBER_LANES
in boolean          : POWERUP,POWERDOWN
in string[20]       : TP_COAX----,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,Link_Lock_dly
--in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
--in_out float_test   : FW_SPD,RW_SPD
local



  multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer     : LBDONE
  float                 : Vconf0, Vconf1
  multisite lword       : lowword, upperword, des_read0, des_read1, des_read2, des_read

  multisite lword       : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer     : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word                  : sites, idx, site ,i 
  integer               : idxs
  
  multisite lword       : hizdel_reg_val, oreg_reg_val
  lword                 : data
  
  multisite lword       : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword               : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword               : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    multisite lword     : fpga_write_data, fpga_read_data , ser_read_data , des_read_data
    integer             : DEBUG = 0
    multisite float      : my_float, dig_dlog[16], icc_dlog[4]
    multisite boolean    : msbool        
    multisite float                             : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1]

end_local


body
  

    LBDONE = 0  -- need initialize to fail first
--    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
  
-----Dut power up function
   DutPowerUp(vio, v18, vcore, "UART", "COAX_GMSL2",POWERUP)

    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val[site]  = integer(lowword[site]) 
    end_for 
 
---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY

--  CRYSTAL running now, we should have LOCK on DES site???
--  Answer is NO on rev1 device (bug), but should be fixed on rev2 device  
    
    hizdel_reg_val = fpga_read_register("FPGA1", HIZDEL_REG)       -- should read back decimal 6000 if FPGA working OK
    wait(0ms)
    
    fpga_set_UART_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(5ms)

    open hcovi XRES_RELAY cbits
--  Power up DES (HS92/MAX96912E)   
--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
    powerup_dnut_vdd_vterm(1.2,1.2)

    
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
    fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
    wait(6ms)
    
    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg
    wait(0ms)
      
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read    
    wait(200us)
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val0[site]  = integer(reg_val0[site]) 
    end_for     
    
 ---------close CSI feedback loop
---    close cbit  FB_RELAY         link PRBS does not need CSI loop back connection

----Set SER and DES for coax or tp mode
    if TP_COAX = "TP" then
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
    else
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
    end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

       if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
       elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

      if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
      elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
      elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
     end_if 
    ser_link_speed_code = ser_rx_speed + ser_tx_speed
    des_link_speed_code = des_rx_speed + des_tx_speed
-----TP only work up to 3GHz
    if TP_COAX = "TP" and TX_SPD >3GHz then
        
        ----put print statement on screen to notify engineer ---- do this later
        ser_link_speed_code   = 0   ---fail part
        des_link_speed_code   = 0
    end_if 
----Program link rate

    RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed

-----Write to reg10 to update link speed setting 
    wait(10us)
    -- write Reg0x10 to update to COAX mode
    RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#30, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89
    wait(1ms)        
    RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)
-----No need to repeat at DES
--     fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0 , 1, 0x20)
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x10, 1)      -- self adjust back to 0x01
--     wait(0ms)
     
--------------Check for lock, error bit
----Currently, HS89 rev 1.5G error bit always on.
----at fwd_speed = 6.0G, REV_SPEED = 0.75 then no error.
----at fwd_speed = 3.0G, REV_SPEED = 0.375 then no error.
---------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------
    -- Verify Inital Link via CTRL3 register
    --------------------------------
    -- CTRL3: looking for CMU_LOCKED at first, but then also TXDP_EN, RXDP_LOCK, and LOCKED (and not ERROR)
  wait(Link_Lock_dly)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
   WaitForRegister( Link_Lock_dly  , SR_CTRL3 , 0xCA , 0xCE , "SERDES" , TRUE , ser_read_data , des_read_data , DEBUG )
--   wait(Link_Lock_dly)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!

   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
   wait(0ms)
   
   for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val1[site]  = integer(lowword[site])
      ireg_val15[site] = integer(reg_val15[site])      
   end_for    

    my_float = float( (ser_read_data&0xCE) % 0xCA )
wait(0ms)
    -- read back DUT LOCK pin via digital pin state
----- MT needs to check these results later
     set digital pin SER_GPIO0_MS_LOCK levels to vol 1.5v voh 1.5v iol 1mA ioh 1mA vref vio

    read digital pin SER_GPIO0_MS_LOCK state compare to high dlog disable into msbool 
    -- datalog#1:  ..., bit[15:8]=(0x7,DUT.LOCK), ...
    my_float = my_float + 256.*(1.0 - float(msbool))
     scatter_1d( my_float , dig_dlog , 1 )
    my_float = 0.0   
-----------to here    

    --------------------------------------------------------------------
    -- Manual Link
    --------------------------------------------------------------------
    if DEBUG>0 then
        println(stdout, "@n", "Start following the test_link_prbs.sv sequence from icmanage (modified by back-and-forth with Ezgi)")
    end_if
    -- http://icmanage1.maxim-ic.com:8080/@md=d&cd=//depot/icm/proj/hs89/hs89a/digital/chip/verification/ASC/tests/&rg=s&c=bS2@//depot/icm/proj/hs89/hs89a/digital/chip/verification/ASC/tests/test_link_prbs.sv?ac=98&rev1=5&mu=362079
    -- edited by Ezgi's recommendations, and debug

    if DEBUG>0 then
        println(stdout, "@n", "Soft reset enable for both sides")
    end_if


    fpga_UART_Write( "FPGA1" , "DES",  SER_ID , SR_CTRL0 , 1 , 2#010_1_0_0_00 )                          -- RESET | AUTO | LINK_CFG:00(Dual)
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_CTRL0 , 1 , 2#010_1_0_0_00 )                          -- RESET | AUTO | LINK_CFG:00(Dual)
    
    if DEBUG>0 then
        println(stdout, "@n", "DISABLE GPIOs")
    end_if
--     -- per .sv, SER GPIO_TX_EN_# = 1'b0 for # = 1,3,5,...19,21
--     -- per .sv, DES GPIO_TX_EN_# = 1'b0 for # = 0,2,4,...18
--     -- However, the .log said "already 0" for most; ser #7 write 0 claimed
--     --  " Write packet: DEV=80, ADDR=709, N=1, DATA=81
--     --      * DEV is obvious hex80,
--     --      * ADDR=dec709=x02C5 (GPIO_7.GPIO_B),
--     --      * DATA=0x81 ?
--     --          in previous cases, data was in hex, so assume 0x81
--     --          PULL UPDN SEL[1:0]  = b10 => ???
--     --          OUT_TYPE            = b0 => ???
--     --          GPIO_TX_ID[4:0]     = 5'b0_0001 = GPIO ID for pin while transmitting
--     --      but that doesn't make much sense; it's 0x02C4 (GPIO_7.GPIO_A) that has the "GPIO_TX_EN" bit
--     --          RES_CFG             = b1 = strength
--     --          TX_PRIO             = b0 = priority
--     --          TX_COMP_EN          = b0 = compensation for jitter minimization
--     --          GPIO_OUT            = b0 = drive value if gpio_rx_en=0 (below)
--     --          GPIO_IN             = b0 = pin input level
--     --          GPIO_RX_EN          = b0 = out source control
--     --          GPIO_TX_EN          = b0 = tx source control                *** this is the bit it claims to be setting
--     --          GPIO_OUT_DIS        = b1 = disable output driver
--     -- For DES, it does _0, _6, _8
--     --  " Write packet: DEV=90, ADDR=688, N=1, DATA=81
--     --      688 = x02B0 = GPIO_0.GPIO_A
--     --  " Write packet: DEV=90, ADDR=706, N=1, DATA=81
--     --      706 = x02C2 = GPIO_6.GPIO_A
--     --  " Write packet: DEV=90, ADDR=712, N=1, DATA=81
--     --      712 = x02C8 = GPIO_8.GPIO_A
--     --  => all three of those make sense
--     --
--     -- I am going to assume it really means GPIO_A for both serializer and deserializer
--     -- 
--     -- ezgi: changed many of the values for SER and DES (originally changed addresses, too, but fixed that in subsequent update)
--     --
--     -- some experimenting found that only DNUT:GPIO7_7_GPIO_A was necessary: when reading back default values, it was set to 0x8B, which sets
--     --  the tx_en bit; need to clear that.
-- --     fpga_I2C_Write( "FPGA1" , "DES", SER_ID , REG89SER_GPIO1_1_GPIO_A      , 1 , 0x81 )
-- --     fpga_I2C_Write( "FPGA1" , "DES", SER_ID , REG89SER_GPIO3_3_GPIO_A      , 1 , 0x81 )
-- --     fpga_I2C_Write( "FPGA1" , "DES", SER_ID , REG89SER_GPIO5_5_GPIO_A      , 1 , 0x81 )
   

    for i = 0 to 20 do    
     RegRead(SER_ID, SR_GPIO_A_0 +i*3, 1, upperword, lowword,"SER_UART_Read")
                                                 
        RegWrite(SER_ID, SR_GPIO_A_0 +i*3 , 1, 16#00, 0x81, "SER_UART_Write")                               --Prog to disable GPIOs                                -----  REG89SER_GPIO7_7_GPIO_A     
        if i < 20 then
            fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_GPIO_A_0 + lword(i*3) , 1 , 0x81 )              --Prog to disable GPIOs ; Des only has 19 GIPO ports
        end_if     
    end_for

-----------Set Ser
    RegWrite(SER_ID, SR_RLMSA7_A , 1, 16#00, 0x81, "SER_UART_Write")                                       -----      Set Man_CNTRL_EN; PHY Control enable; reg = 0x14A7
    RegWrite(SER_ID, SR_RLMSA7_B , 1, 16#00, 0x81, "SER_UART_Write")                                       -----      Set Man_CNTRL_EN; PHY Control enable reg = 0x15A7
    RegWrite(SER_ID, SR_CTRL7 , 1, 16#00, 0x80, "SER_UART_Write")                                          -----      Enable forward link            reg = 0x17                      
  
-----------Set DES
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  DR_RLMSA7_A  , 1 , 0x81 )                                       -----      Set Man_CNTRL_EN; PHY Control enable; reg = 0x14A7
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  DR_RLMSA7_B  , 1 , 0x81 )                                     -----      Set Man_CNTRL_EN; PHY Control enable reg = 0x15A7 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  DR_CTRL7     , 1 , 0x80 )                                       -----      Enable forward link            reg = 0x17               
----------Auto link    ---------here
    RegWrite(SER_ID, SR_CTRL0 , 1, 16#00, 0x10, "SER_UART_Write")                                           -----    RESET=0 | AUTO:1 | LINK_CFG:00(Dual)
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_CTRL0    , 1 , 0x10 )                        ------ RESET=0 | AUTO:1 | LINK_CFG:00(Dual)

    if DEBUG>0 then
        println(stdout, "@n", "SER side PHY_EN_A=1, PHY_EN_B=1")
    end_if
--     -- SetReg(ser, '{'{`FW_PHY_EN_A, 1'h1}});  Write packet: DEV=80, ADDR=23, N=1, DATA=a0     0x17 CTRL7
--     -- SetReg(ser, '{'{`FW_PHY_EN_B, 1'h1}});  Write packet: DEV=80, ADDR=23, N=1, DATA=e0     0x17 CTRL7
--     -- merge into one write of 0xE0 (don't really need to enable A and B separately)
    RegWrite(SER_ID, SR_CTRL7 , 1, 16#00, 0xE0, "SER_UART_Write")                                         ------ FW_CTRL_EN=1 | PHY_B_EN=1 | PHY_A_EN=1 | FW_LINK_MODE=00

    if DEBUG>0 then
        println(stdout, "@n", "DES side PHY_EN_A=1, PHY_EN_B=1")
    end_if           
    -- SetReg(des, '{'{`FW_PHY_EN_A, 1'h1}});  Write packet: DEV=90, ADDR=23, N=1, DATA=a0     0x17 CTRL7
    -- SetReg(des, '{'{`FW_PHY_EN_B, 1'h1}});  Write packet: DEV=90, ADDR=23, N=1, DATA=e0     0x17 CTRL7
    -- merge into one write of 0xE0 (don't really need to enable A and B separately)
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_CTRL7    , 1 , 0xE0 )                              ------- FW_CTRL_EN=1 | PHY_B_EN=1 | PHY_A_EN=1 | FW_LINK_MODE=00 

 
      --------------------------------------------------------------------
    -- Manual Calibration
    --------------------------------------------------------------------
    if DEBUG>0 then
        println(stdout, "@n", "Performing Calibration Before Uni-directional Link is established")
        println(stdout, "@n", "Manually calibrate SER side")
    end_if
--     -- SetReg(ser, '{'{`MAN_CALIB_A, 1'h1}});  Write packet: DEV=80, ADDR=5287, N=1, DATA=c1
--     -- SetReg(ser, '{'{`MAN_CALIB_B, 1'h1}});  Write packet: DEV=80, ADDR=5543, N=1, DATA=c1
    RegWrite(SER_ID, SR_RLMSA7_A , 1, 16#00, 0xC1 , "SER_UART_Write")                               ------- MAN_CTRL_EN | MAN_CALIB | PRE_HSK_PD
    RegWrite(SER_ID, SR_RLMSA7_B , 1, 16#00, 0xC1 , "SER_UART_Write")                               --------- MAN_CTRL_EN | MAN_CALIB | PRE_HSK_PD
---Readback value of RLMS88 check for calbit                         
    WaitForRegister(  250ms , SR_RLMS88_A , 0x20 , 0x20 , "SER" , FALSE , ser_read_data , des_read_data , DEBUG )
--    RegRead(SER_ID, SR_RLMS88_A, 1, upperword, lowword,"SER_UART_Read")                                     ----------- for SER CALBIT DONE  BIT 5 IS HIGH
  
    -- datalog#2:  bit[2] = DNUT.A_RLMS88.cal_done
    my_float = my_float + float(2#0100) * (1.0 - float( (ser_read_data>>5) & 0x1 ) )
------Check linkB
   WaitForRegister(  250ms , SR_RLMS88_B , 0x20 , 0x20 , "SER" , FALSE , ser_read_data , des_read_data , DEBUG )
   my_float = my_float + float(2#0100) * (1.0 - float( (ser_read_data>>5) & 0x1 ) )
  
--------Setup for des manual cal and check calbit done. done = high  
     -- SetReg(des, '{'{`MAN_CALIB_A, 1'h1}});   Write packet: DEV=90, ADDR=5287, N=1, DATA=c1
    -- SetReg(des, '{'{`MAN_CALIB_B, 1'h1}});   Write packet: DEV=90, ADDR=5543, N=1, DATA=c1
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMSA7_A    , 1 , 0xC1 )                                           -- MAN_CTRL_EN | MAN_CALIB | PRE_HSK_PD
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMSA7_B    , 1 , 0xC1 )                                           -- MAN_CTRL_EN | MAN_CALIB | PRE_HSK_PD

    WaitForRegister(  250ms , DR_RLMS88_A , 0x20 , 0x20 , "DES" , TRUE , ser_read_data , des_read_data , DEBUG ) 
    -- datalog#2:  bit[0] = DUT.A_RLMS88.cal_done
    my_float = my_float + float(2#0001) * (1.0 - float( (des_read_data>>5) & 0x1 ) )  
    WaitForRegister(  250ms , DR_RLMS88_B , 0x20 , 0x20 , "DES" , TRUE , ser_read_data , des_read_data , DEBUG )
    -- datalog#2:  bit[1] = DUT.B_RLMS88.cal_done
    my_float = my_float + float(2#0010) * (1.0 - float( (RdWordLower>>5) & 0x1 ) )
  
    scatter_1d( my_float , dig_dlog , 2 )
    my_float = 0.0 
  
-- --     --------------------------------------------------------------------
-- --     -- Enable Transmit and Receive on both ends of the link (BiDirectional Link)
-- --     --  then wait for rxdp_lock on both devices (to indicate receiving from link
-- --     --------------------------------------------------------------------
-- --      -- SetReg(ser, '{'{`MAN_TX_EN_A, 1'h1}});  Write packet: DEV=80, ADDR=5287, N=1, DATA=e1
-- --     -- SetReg(ser, '{'{`MAN_TX_EN_B, 1'h1}});  Write packet: DEV=80, ADDR=5543, N=1, DATA=e1
-- --     -- SetReg(ser, '{'{`FW_START_TX, 1'h1}});  Write packet: DEV=80, ADDR=23, N=1, DATA=f0
    RegWrite(SER_ID, SR_RLMSA7_A , 1, 16#00, 0xE1 , "SER_UART_Write")                                       -- MAN_CTRL_EN | MAN_CALIB | MAN_TX_EN | PRE_HSK_PD
    RegWrite(SER_ID, SR_RLMSA7_B , 1, 16#00, 0xE1 , "SER_UART_Write")                                       -- MAN_CTRL_EN | MAN_CALIB | MAN_TX_EN | PRE_HSK_PD
    RegWrite(SER_ID, SR_CTRL7 , 1, 16#00, 0xF0 , "SER_UART_Write")                                         -- FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX=1 | FW_LINK_MODE=b00
-------SETUP DES
-- --     -- SetReg(des, '{'{`MAN_TX_EN_A, 1'h1}});  Write packet: DEV=90, ADDR=5287, N=1, DATA=e1
-- --     -- SetReg(des, '{'{`MAN_TX_EN_B, 1'h1}});  Write packet: DEV=90, ADDR=5543, N=1, DATA=e1
-- --     -- SetReg(des, '{'{`FW_START_TX, 1'h1}});  Write packet: DEV=90, ADDR=23, N=1, DATA=f0
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_RLMSA7_A  , 1 , 0xE1 )                    -- MAN_CTRL_EN | MAN_CALIB | MAN_TX_EN | PRE_HSK_PD
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_RLMSA7_B  , 1 , 0xE1 )                    -- MAN_CTRL_EN | MAN_CALIB | MAN_TX_EN | PRE_HSK_PD
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_CTRL7     , 1 , 0xF0 )                    -- FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX=1 | FW_LINK_MODE=b00

----    -- SetReg(ser, '{'{`MAN_RX_EN_A, 1'h1}});  Write packet: DEV=80, ADDR=5287, N=1, DATA=f1
    RegWrite(SER_ID, SR_RLMSA7_A , 1, 16#00, 0xF1 , "SER_UART_Write")

----    -- SetReg(des, '{'{`MAN_RX_EN_A, 1'h1}});  Write packet: DEV=90, ADDR=5287, N=1, DATA=f1
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_RLMSA7_A    , 1 , 0xF1 ) 

---    -- SetReg(ser, '{'{`MAN_RX_EN_B, 1'h1}});  Write packet: DEV=80, ADDR=...., N=1, DATA=f1
    RegWrite(SER_ID, SR_RLMSA7_B , 1, 16#00, 0xF1 , "SER_UART_Write")    


----    -- SetReg(des, '{'{`MAN_RX_EN_B, 1'h1}});  Write packet: DEV=90, ADDR=5287, N=1, DATA=f1
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_RLMSA7_B    , 1 , 0xF1 ) 

-------CHECK FOR RX data path LOCK
    WaitForRegister_mod(  250ms , SR_CTRL3 , 0x40 , 0x40 , "SERDES" , false, true , ser_read_data , des_read_data , DEBUG) 


    wait(0)


    --------------------------------------------------------------------
    -- Finish stepping thru manual linking sequence
    --------------------------------------------------------------------

    if DEBUG>0 then
        println(stdout, "@n", "2017-Jun-22: write Reg0x20 => 0x1F, Reg 0x21 => 0x5F on both SERDES before starting manual handshake")
    end_if
    
    RegWrite(SER_ID, SR_INTR8, 2, 16#5F, 0x1F , "SER_UART_Write")                         -- INTR8 is LSB, INTR9 is MSB
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_INTR8     , 1 , 0x1F )             -- INTR8 is LSB, INTR9 is MSB
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_INTR9     , 1 , 0x5F )             -- INTR8 is LSB, INTR9 is MSB

    if DEBUG>0 then
        println(stdout, "@n", "SERDES side TXDP_EN=1")
    end_if
----     -- SetReg(ser, '{'{`FW_TXDP_EN, 1'h1}});   Write packet: DEV=80, ADDR=23, N=1, DATA=f8
----     -- SetReg(des, '{'{`FW_TXDP_EN, 1'h1}});   Write packet: DEV=90, ADDR=23, N=1, DATA=f8
    RegWrite(SER_ID, SR_CTRL7, 1, 16#00, 0xF8 , "SER_UART_Write")                               --FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX | FW_TXDP_EN | FW_LINK_MODE=b00
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_CTRL7   , 1 , 0xF8 )                       -- FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX | FW_TXDP_EN | FW_LINK_MODE=b00
    wait(1ms)

----    -- SetReg(ser, '{'{`FW_LOCK, 1'h1}});  Write packet: DEV=80, ADDR=23, N=1, DATA=fc
----    -- SetReg(des, '{'{`FW_LOCK, 1'h1}});  Write packet: DEV=90, ADDR=23, N=1, DATA=fc
    RegWrite(SER_ID, SR_CTRL7, 1, 16#00, 0xFC , "SER_UART_Write")                               -- FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX | FW_TXDP_EN | FW_LOCK | FW_LINK_MODE=b00
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_CTRL7     , 1 , 0xFC )                     -- FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX | FW_TXDP_EN | FW_LOCK | FW_LINK_MODE=b00

    reg_val15 = fpga_UART_Read( "FPGA1" , "DES" , DESA_ID , DR_CTRL7     , 1 )        -----Have problem here. Read back DNUT data = F4. expect FC. If turned of bit 3 of SER then read back 0xF8 for DNUT
    RegRead(SER_ID, SR_CTRL7, 1,upperword, lowword, "SER_UART_Read")  
    if DEBUG>0 then
        println(stdout, "@n", "Wait for LOCK")
    end_if
    WaitForRegister_mod(  250ms , SR_CTRL3 , 0xCA , 0xCA , "SERDES" , false,true , ser_read_data , des_read_data , DEBUG )
    -- datalog#3:  MANUALCAL_LINK_FAIL[15:8] = DNUT.CTRL3 mismatch, [7:0] = DUT.CTRL3 mismatch
    my_float = my_float + float( ( (ser_read_data&0xCA) % 0xCA ) << 8 ) + float( ( (des_read_data&0xCA) % 0xCA ) << 0 )
 
    if DEBUG>0 then
        println(stdout, "@n", "Final Lock Verified before starting PRBSGEN" )
    end_if

    --------------------------------------------------------------------
    -- datalog#3:  MANUALCAL_LINK_FAIL: ... = { [15:8]=DNUT.CTRL3, [7:0]=DUT.CTRL3 }
    --------------------------------------------------------------------
    scatter_1d( my_float , dig_dlog , 3 )
    my_float = 0.0
   --------------------------------
    -- start Link PRBS after manual link
    --------------------------------

    if DEBUG>0 then
        println(stdout, "@n", "SERDES side LINK PRBSGEN" )
    end_if
    --      wr GMSL.TX1.LINK_PRBS_GEN=1 (0x29.bit7)
    RegWrite(SER_ID, SR_TX1_0, 1, 16#00, 0x80 , "SER_UART_Write")                
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_TX1  , 1 , 0x80 )
 

    if DEBUG>0 then
        println(stdout, "@n", "SERDES side LINK PRBSCHK" )
    end_if
    --      wr GMSL.RX1.LINK_PRBS_CHK=1 (0x2D.bit7)

    RegWrite(SER_ID, SR_RX1, 1, 16#00, 0x80 , "SER_UART_Write")   
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RX1_GMSL , 1 , 0x80 )
    
    --------------------------------------------------------------------
    -- clear dec_err values from prbs initialization
    --------------------------------------------------------------------
    if DEBUG>0 then
        println(stdout, "@n", "Clear error registers to clean errors that happen while turning on the prbs")
    end_if
    --      rd TCTRL.CNT0-1 DEC_ERR_A/B (0x22-0x23) -- Clear error registers to clean errors that happen while turning on the PRBS
    RegRead(SER_ID, SR_CNT0, 2,upperword, lowword, "SER_UART_Read")                                 -- CNT0 goes into low byte, CNT1 into next byte
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_CNT0      , 2 )             -- CNT0 goes into low byte, CNT1 into next byte


    --------------------------------------------------------------------
    -- wait for PRBS SYNC
    -- datalog#4:  PRBSSYNC_FAIL: ... = { [15:8]=DNUT.GMSL_RX3, [7:0]=DUT.GMSL_RX3 }
    --------------------------------------------------------------------
    if DEBUG>0 then
        println(stdout, "@n", "wait for PRBS SYNC")
    end_if
    if DEBUG>0 then
        println(stdout, "@n", "clear latched faillock_* bit on first read; subsequent read should be valid")
    end_if
    --      rd GMSL.RX3.PRBS_SYNCED* (0x2F)
    WaitForRegister_mod(  50ms , SR_RX3 , 0x88 , 0x88 , "SERDES" ,false, TRUE , ser_read_data , des_read_data , DEBUG )
    my_float = my_float + float( ( (ser_read_data&0x88) % 0x88 ) << 8 )
    my_float = my_float + float( ( (des_read_data&0x88) % 0x88 )      )
    scatter_1d( my_float , dig_dlog , 4 )
    my_float = 0.0


   --------------------------------------------------------------------
    -- Propagate error thru link, to verify link is _truly_ there, and not just claiming prbssync
    --------------------------------------------------------------------
    if DEBUG>0 then
        println(stdout, "@n", "SERDES side ERRG_SETTINGS: 128 = 0x80 errors for SER TX, and 16 = 0x10 errors for DES TX")
    end_if
--    --      wr SER GMSL.TX2.{ERRG_CNT:0x2, ERRG_RATE:0x0 => 8'b10_00_000_0 = 0x80 } (0x2A)      -- 0:continuous, 1:16, **2:128**, 3:1024
--    --      wr DES GMSL.TX2.{ERRG_CNT:0x1, ERRG_RATE:0x0 => 8'b01_00_000_0 = 0x40 } (0x2A)      -- 0:continuous, **1:16**, 2:128, 3:1024
--    -- explanation: we are _intentionally_ generating a burst of errors
    RegWrite(SER_ID, SR_TX2_0, 1, 16#00, 0x80 , "SER_UART_Write")   
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_TX2            , 1 , 0x40 )

--    --      wr GMSL.TX1.{LINK_PRBS_GEN | ERRG_EN_A | ERRG_EN_B} => 8'b1_0_11_00_0_0 = 0xB0 (addr 0x29)
    RegWrite(SER_ID, SR_TX1_0, 1, 16#00, 0xB0 , "SER_UART_Write")
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_TX1 , 1 , 0xB0 )
    -- wait long enough for 16 err at 1 err per ~5120 samples, slow reverse channel (0.1875GHz), plus setup overhead time
    wait(3ms)

    --------------------------------------------------------------------
    -- datalog#5-8:  A_FWD, B_FWD, A_REV, B_REV error counts
    --      per simulation file, ok as long as +-20% from expected target (128 or 16)
    --------------------------------------------------------------------
    if DEBUG>0 then
        println(stdout, "@n", "DEC_ERR_A/B: Check for real errors this time: should get 0x10 on the SER end (from DES TX), and 0x80 on the DES end (from SER TX)")
    end_if
    --  design simulation allowed 0.8*# to 1.2*#, rather than exactly #
    --      rd TCTRL.CNT0-1 DEC_ERR_A/B (0x22-0x23) -- Check for real errors this time
    -- fwd: expect 0x80 (128) errors on forward channel
        -- read 2 bytes in one transaction to save a little testtime
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_CNT0  , 2 )                    -- CNT0 goes into low byte, CNT1 into next byte
    my_float = float( (RdWordLower&0x00FF)      )
    scatter_1d( my_float , dig_dlog , 5 )
    my_float = float( (RdWordLower&0xFF00) >> 8 )
    scatter_1d( my_float , dig_dlog , 6 )
    -- rev: expect 0x10 (16) errors on reverse channel
    RegRead(SER_ID, SR_CNT0, 2,upperword, RdWordLower, "SER_UART_Read")                                 -- CNT0 goes into low byte, CNT1 into next byte
--    RdWordLower = fpga_I2C_Read( "FPGA1" , "DES" , SER_ID  , REG89SER_TCTRL_CNT0           , 2 )   -- CNT0 goes into low byte, CNT1 into next byte
    my_float = float( (RdWordLower&0x00FF)      )
    scatter_1d( my_float , dig_dlog , 7 )
    my_float = float( (RdWordLower&0xFF00) >> 8 )
    scatter_1d( my_float , dig_dlog , 8 )


-----Need check Error pins for DUT and DNUT currently, DUT error failed. DNUT need FPGA mod to measure error pin

---Need code righ here
-----

    --------------------------------------------------------------------
-----------
 
    --------------------------------------------------------------------
    -- Worst-Case Supply Current
    --------------------------------------------------------------------
    measure hcovi i on SER_VDD for 170 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 170 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 170 samples every 10us averaged into i_vddio_meas

    scatter_1d( gather_1d(i_vdd_meas  ,1) , icc_dlog , 1 )
    scatter_1d( gather_1d(i_vdd18_meas,1) , icc_dlog , 2 )
    scatter_1d( gather_1d(i_vddio_meas,1) , icc_dlog , 3 )

    if DEBUG>1 then
        println(stdout)
        println(stdout, "I(VDD)  ":-24,     i_vdd_meas  [1:4]!fu=mA:12:1 )
        println(stdout, "I(VDD18)":-24,     i_vdd18_meas[1:4]!fu=mA:12:1 )
        println(stdout, "I(VDDIO)":-24,     i_vddio_meas[1:4]!fu=mA:12:1 )
        println(stdout, "I(VTERM)":-24,     i_vterm_meas[1:4]!fu=mA:12:1 )

    end_if
 
 
 
 
 
 
 
 
   -------------------------DO NOT DELETE, DEBUGGING-------------------------
   -- try to read across the link to SER from DNUT using FPGA, FPGA timeout for read back is hardcode to 128uS
   --des_read =  fpga_UART_Read("FPGA1", "DES", SER_ID, 0x00, 1)      -- SER_ID read from DNUT UART mode, expect 0x80
   wait(0ms)





   -- turn off MIPI clocks from DES
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)            
   -- reg_val23  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)
   -- loop back relays on LB opened
--   fpga_cbit_control("FPGA1", 2#0000)      -- control FPGA cbits 2#0000  (cb4, cb3, cb2, cb1)   
     open cbit CB2_SLDC                 --OVI_RELAYS 
     open cbit COAXB_M_RELAY            --OVI_RELAYS
     open cbit  FB_RELAY
-------------- Power Down ---------------------------
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
  --set  digital  pin ALL_PATTERN_PINS fx1 driver  preset low       
  wait(500us)
  
        powerdown_device(POWERDOWN)

 open cbit  FB_RELAY
 open cbit  DNUT_RXTX_RELAY
    test_value ireg_val  with devid_it 
    test_value ireg_val0 with dnutid_it
    test_value ireg_val1 with ser_lock_it
    test_value ireg_val15 with des_lock_it        
    test_value ireg_val_ser_bad  with bad_pat_it 
    test_value ireg_val_ser_good with good_pat_it          
--    test_value LBDONE  with lbdone
-- 
--     test_value TX_SPD with FW_SPD     
--     test_value RX_SPD with RW_SPD  
--     test_value MIPI_SPD with CSI_SPD
--     test_value number_of_lanes_test with NUMBER_LANES
 end_body



procedure TEST_WCICC_VideoPrbs(vcore, vio, v18, SerLockErr, DesLockErr, PclkADet, PclkBDet,VPrbs_PreErr,DesYVLock,DesZVLock,VPrbsErrFlagInject,VPrbsYErrCnt,VPrbsZErrCnt, DecAErr,DecBErr,IVDDIO, IVDD, IVDD18,POWERDOWN,TX_SPD,RX_SPD,Link_Lock_dly,MIPI_SPD)
--------------------------------------------------------------------------------

in float            : vcore, vio, v18
in_out integer_test : SerLockErr, DesLockErr,PclkADet, PclkBDet,VPrbs_PreErr,DesYVLock,DesZVLock ,VPrbsErrFlagInject,VPrbsYErrCnt, VPrbsZErrCnt, DecAErr,DecBErr---,NUMBER_LANES
in boolean          : POWERDOWN
--in string[20]       : TP_COAX----,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,Link_Lock_dly
--in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
in_out float_test   : IVDDIO, IVDD, IVDD18
in float            : MIPI_SPD

local
 multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer     : LBDONE
  float                 : Vconf0, Vconf1
  multisite lword       : lowword, upperword, des_read0, des_read1, des_read2, des_read

  multisite lword       : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer     : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word                  : sites, idx, site ,i 
  integer               : idxs
  
  multisite lword       : hizdel_reg_val, oreg_reg_val
  lword                 : data
  string[15]           : Part_Num
  
  multisite lword       : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword               : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword               : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    multisite lword     : fpga_write_data, fpga_read_data , ser_read_data , des_read_data
    integer             : DEBUG = 0
    multisite float      : my_float, dig_dlog[16], icc_dlog[4]
    multisite boolean    : msbool        
    multisite float                             : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1]
    lword                                       : expect_ctrl3 = 0xCA
    multisite float                             :  vprbs_err, dbg_dlog[16]

   multisite integer     : PclkA_Det, PclkB_Det,PreErrFlag,DesZDataLock ,DesYDataLock,VPrbsErrFlagInj,VPrbsYErr_Cnt,VPrbsZErr_Cnt,DEC_ERR_A, DEC_ERR_B
    pin                  : mfp1
end_local


body
     active_sites = get_active_sites
     sites = word(len(active_sites))
     
     get_expr("OpVar_ProductUnderTest", Part_Num)

-----Dut power up function
-----This function has be run after FeedBack_LinkLock_LoopTest function to have correct number of gmsl links and lock.
    Set_SER_Voltages(vio, vcore, v18)    
    wait(2ms)

---------close CSI feedback loop
    close cbit  FB_RELAY

   wait(5ms)  

   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
   wait(0ms)


  --------------------------------
    -- Verify Inital Link via CTRL3 register
    --------------------------------
    -- CTRL3: looking for CMU_LOCKED at first, but then also TXDP_EN, RXDP_LOCK, and LOCKED (and not ERROR)
     wait(Link_Lock_dly)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!

   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
   wait(0ms)
    
   for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val1[site]  = integer(lowword[site])
      ireg_val15[site] = integer(reg_val15[site])      
   end_for    

------Provide CSI clock  and loop back in order to test video prbs
--    RegWrite(SER_ID, SR_MIPI_RX0, 1, 16#00, 0x86 , "SER_UART_Write") 

------------Setup Ser video mode
------- Depend on what mode 2x4 or 2x2 to set video pipe line correctly
-- VID_TX_EN_X,Y,Z,U=1. Video transmit enalbe for X, Y, Z, U   
--    if  ( video_mode = '2x4') then
        RegWrite(SER_ID, SR_REG2, 1, 16#00, 0x63 , "SER_UART_Write")     --- Y and Z pipe line 
    RegWrite(SER_ID,SR_FRONTTOP_9 , 1, 16#00, 0x42 , "SER_UART_Write")      ---Video pipline Z port B, Video pipline Y port A
    RegWrite(SER_ID,SR_FRONTTOP_0 , 1, 16#00, 0x7C , "SER_UART_Write")      ---Eanble Line info fram, Video portA, Portb, pipelineZ and U portB, Pipeline X and Y port A
------Phy config 2x4
    RegWrite(SER_ID,0x370 , 1, 16#00, 0x61 , "SER_UART_Write")
    RegWrite(SER_ID,SR_MIPI_RX0 , 1, 16#00, 0x86 , "SER_UART_Write")      -- 2x4 AB
     
 if Part_Num = "MAX96755H" or Part_Num = "MAX96757H" then
     MIPI_SPD = 600.0e6
 end_if
 
---------Setup Des Video Mode
    mipi_speed = lword(MIPI_SPD / 100.0e6)| 0x20

    fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x330, 1, 0x84)       -- 
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_BACKTOP22 , 1,  mipi_speed )----29
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_BACKTOP25 , 1,  mipi_speed )----29
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_BACKTOP28 , 1,  mipi_speed) ----29
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_BACKTOP31 , 1,  mipi_speed )----29
    fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x330, 1, 0x84)       -- 
-----************ Check Ser PCLK
 
    RegRead(SER_ID,16#10A , 1, upperword,lowword,"SER_UART_Read")           --        read PCLK detection for pipeline Y portA; X is not used
    PclkA_Det = ( integer(lowword) & 0x80)  >> 7                                    ---For data log  

    for idx = 1 to sites do
        site = active_sites[idx]
        if PclkA_Det[site] <>1 then
            wait(0)
        end_if
    end_for    
    RegRead(SER_ID, 16#112, 1, upperword,lowword ,"SER_UART_Read")          --        read PCLK detection for pineline Z portA; u is not used     
    PclkB_Det =      ( integer(lowword) & 0x80)  >> 7                             ---For data log     

-------
    wait(0)
    --------------------------------------------------------------------
    -- Try Forward VideoPRBS
    --------------------------------------------------------------------

    --      wr VTX_Z.VTX29.vid_prbs_en_z=1

    RegWrite(SER_ID, SR_VTX_Z_VTX29 , 1, 16#00, 0x80 , "SER_UART_Write") 
    RegWrite(SER_ID, SR_VTX_Y_VTX29 , 1, 16#00, 0x80 , "SER_UART_Write")          ----MT
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_VRX_Z_VPRBS     , 1 , 0x10 )   ---0x10
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_VRX_Y_VPRBS     , 1 , 0x10 )    ----MT

    --  `MSG("Enable PRBS error reflection on ERRB pin (DES)");
    if DEBUG>0 then
        println(stdout, "@n", "Enable PRBS error reflection on ERRB pin (DES)" )
    end_if
    --      wr TCTRL.INTR6.vprbs_err_oen=1 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_INTR6        , 1 ,0x04 )

    -- `MSG("Running PRBS");
    wait(1ms)

    ----------------
    -- `MSG("Checking ERRORB pin to indicate No Errors correctly")
    ----------------    
     ----------------
    -- `MSG("Checking ERRORB pin to indicate No Errors correctly")
    ----------------
    my_float = 0.0
    if DEBUG>0 then
        println(stdout, "@n", "Checking ERRORB pins to indicate No Errors correctly")
    end_if
    -- check ERRB and LOCK pins (expect HIGH)
    -- DUT (HS89)  
   
      -- read back DUT LOCK pin via digital pin state
----- MT needs to check these results later

    set digital pin SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB levels to vol 1.5v voh 1.5v iol 1mA ioh 1mA vref vio
    read digital pin SER_GPIO0_MS_LOCK state compare to high dlog disable into msbool 
    my_float = my_float + 1.0 * float(not msbool)   
    read digital pin SER_GPIO1_LFLTB_ERRB state compare to high dlog disable into msbool 
    reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
 RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA    

-----Need modified FPGA in order to check error and lock on dnut
        scatter_1d( my_float , dbg_dlog , 2 )       -- ERRB state: 1*DUT LOCK LOW + 2*DUT ERRB LOW + 4*DNUT(3-LOCK|ERRB)
        
    ----------------
    -- `MSG("Checking registers to indicate No Errors correctly")
    ----------------
    my_float = 0.0
    if DEBUG>0 then
        println(stdout, "@n", "Checking registers to indicate No Errors correctly")
    end_if

    -- VPRBS_FAIL_Z
--    RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA 
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_VRX_Z_VPRBS      , 1 )
    DesZDataLock  = integer(RdWordLower) & 0x01                                                           ---Check for video data valid lock on channel Z

    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_VRX_Y_VPRBS      , 1 )
    DesYDataLock  =integer( RdWordLower) & 0x01                                                           ---Check for video data valid lock on channel Y
-- if(( DesYDataLock[active_sites[1]] <>1) OR ( DesZDataLock[active_sites[1]] <>1)) then
--     wait(0)
-- end_if

    -- VPRBS_ERR_FLAG & LCRC_ERR_FLAG: merged into one read, since they are bits in the same register
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_INTR7      , 1 )
    PreErrFlag = integer(RdWordLower)

    --  ReadReg(des, '{`VPRBS_ERR_Z}, rData);
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_VRX_Z_PRBS_ERR , 1 )   ----VPrbs Error Count 
    --  ReadReg(des, '{`VPRBS_ERR_Z}, rData);
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_VRX_Y_PRBS_ERR , 1 )  ----VPrbs Error Count
--    vprbs_err = float( RdWordLower & 0xFF )


----------Send Error package
    RegRead(SER_ID,SR_CNT0 , 1, upperword, lowword,"SER_UART_Read")    --     read error at linkA
    RegRead(SER_ID,SR_CNT1 , 1, upperword, lowword,"SER_UART_Read")    --     read error at linkB
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_CNT0 , 1 )
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_CNT1 , 1 )

-----Inject 128 =0x80 error

    RegWrite(SER_ID, SR_TX2_0 , 1, 16#00, 0x80 , "SER_UART_Write")          ----MT    0x2A 
    RegWrite(SER_ID, SR_TX1_0 , 1, 16#00, 0x30 , "SER_UART_Write")          ----MT     0x29 Error generate for link A and B
    wait(10ms)   ----50mS

----Read VPrbs error flag it should be high 
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_INTR7 , 1 )     -------- INTR7 = 0x1F. Bit 2 is PRBS_ERROR_FLAG
    VPrbsErrFlagInj = (integer(RdWordLower) & 0x04) >> 2            ------VPrbsErrFlagInj

---error count VPRBS_ERROR
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , 0x1FB , 1 )
    VPrbsYErr_Cnt = integer(RdWordLower)
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , 0x21B , 1 )
    VPrbsZErr_Cnt = integer(RdWordLower)

    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , 0x1B , 1 )

    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_CNT0 , 1 )             --     read error at linkA DR_CNT0 = 0x22
    DEC_ERR_A = integer(RdWordLower)
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_CNT1 , 1 )             --     read error at linkB,  DR_CNT1 = 0x23
    DEC_ERR_B = integer(RdWordLower)


    --------------------------------------------------------------------
    -- Worst-Case Supply Current
    --------------------------------------------------------------------
---Reduce Vddio current for accuracy measurement
--    set hcovi SER_VDDIO to fv vio   vmax 4V  measure i max 2ma clamp imax 10mA imin -10mA
    wait(5ms)

    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas

---Reduce Vddio current for accuracy measurement
    set hcovi SER_VDDIO to fv vio   vmax 4V  measure i max 10ma clamp imax 600mA imin -600mA    ---- change range from 2mA meas to 10mA otherwise, it fails SPIPT at hot ---MT 3/2019
    wait(5ms)----needed
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas



    --------------------------------------------------------------------
    -- cleanup
    --------------------------------------------------------------------    fpga_I2C_Write( "FPGA1" , "DUT" , DES_ID , REG92DES_VRX_Z_VPRBS        , 1 , 0x00 )
 --Disable VPRBS
    RegWrite(SER_ID, SR_VTX_Z_VTX29 , 1, 16#00, 0x00 , "SER_UART_Write") 
    RegWrite(SER_ID, SR_VTX_Y_VTX29 , 1, 16#00, 0x00 , "SER_UART_Write") 
--   RegWrite(DES_ID, 0x21C , 1, 0, 0x00, "des_uart_write")          
   fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x1FC, 1, 0x00)         ---Disable pipelineY prbs checker 
   fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x21C, 1, 0x00)         ---Disable pipelineZ prbs checker 

--     -- remove pullups from LOCK and ERRB pins
--     set digital pin  SER_GPIO0_MS_LOCK + SER_GPIO1_LFLTB_ERRB  levels to iol 0mA ioh 0uA  -- remove pullup

-------------- Power Down ---------------------------

    set hcovi SER_VDDIO to fv vio   vmax 4V clamp imax 600mA imin -600mA

    wait(500us)
  

      open cbit  FB_RELAY
      open cbit  DNUT_RXTX_RELAY
      wait(4ms)
      powerdown_device(POWERDOWN)
      if (POWERDOWN) then
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)
      end_if
 ----- Datalog out
 
    test_value  ireg_val1 with  SerLockErr
    test_value  ireg_val15   with  DesLockErr
    test_value  (PclkA_Det)   with PclkADet
    test_value  (PclkB_Det)   with PclkBDet 
    test_value  PreErrFlag    with VPrbs_PreErr
    test_value  DesYDataLock    with DesYVLock
    test_value  DesZDataLock   with DesZVLock
---Datalog after error injection 
    test_value  VPrbsErrFlagInj   with VPrbsErrFlagInject
    test_value  VPrbsYErr_Cnt   with VPrbsYErrCnt
    test_value  VPrbsZErr_Cnt   with VPrbsZErrCnt
    test_value  DEC_ERR_A  with   DecAErr
    test_value  DEC_ERR_B  with    DecBErr
---supply datalog 
    test_value i_vddio_meas  with  IVDDIO
    test_value i_vdd_meas  with   IVDD
    test_value i_vdd18_meas  with   IVDD18
 end_body
procedure TEST_WCICC_LinkPrbs_new(vcore, vio, v18, ser_lock_it, des_lock_it, SerCalDoneA_ft, SerCalDoneB_ft, DesCalDoneA_ft, DesCalDoneB_ft, SerRxdpLock_ft, DesRxdpLock_ft, SerPrbsSync_ft, DesPrbsSync_ft, SerPrbsLock_ft, DesPrbsLock_ft, SerErrbit_ft, DesErrbit_ft, SerErrCntA_ft, SerErrCntB_ft, DesErrCntA_ft, DesErrCntB_ft, PreVerr_ft, Verr_ft, ClearVerr_ft,POWERUP,POWERDOWN,TP_COAX,TX_SPD,RX_SPD,Link_Lock_dly)

--------------------------------------------------------------------------------
in float            : vcore, vio, v18
in_out integer_test :  ser_lock_it, des_lock_it
in boolean          : POWERUP,POWERDOWN
in string[20]       : TP_COAX                         -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,Link_Lock_dly
in_out integer_test : SerCalDoneA_ft, SerCalDoneB_ft, DesCalDoneA_ft, DesCalDoneB_ft, SerRxdpLock_ft, DesRxdpLock_ft, SerPrbsSync_ft, DesPrbsSync_ft, SerPrbsLock_ft, DesPrbsLock_ft, SerErrbit_ft, DesErrbit_ft, SerErrCntA_ft, SerErrCntB_ft, DesErrCntA_ft, DesErrCntB_ft
in_out float_test   : PreVerr_ft, Verr_ft, ClearVerr_ft
local



  multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer     : LBDONE
  float                 : Vconf0, Vconf1
  multisite lword       : lowword, upperword--, des_read0, des_read1, des_read2, des_read

  multisite lword       : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
--  multisite integer     : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word                  : sites, idx, site ,i 
  integer               : idxs
  
  multisite lword       : hizdel_reg_val, oreg_reg_val
  lword                 : data
  
  multisite lword       : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword               : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword               : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    multisite lword     : fpga_write_data, fpga_read_data , ser_read_data , des_read_data
    integer             : DEBUG = 0
    multisite float      : my_float, dig_dlog[16], icc_dlog[4]
    multisite boolean    : msbool        
    multisite float     : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , PreVerr[1], Verr[1], ClearVerr[1]

    multisite integer   : SerCalDoneA, SerCalDoneB, DesCalDoneA, DesCalDoneB, SerRxdpLock, DesRxdpLock, SerPrbsLock, DesPrbsLock, SerPrbsSync, DesPrbsSync
    multisite integer   : SerErrCntA, SerErrCntB, DesErrCntA, DesErrCntB, SerErrbit, DesErrbit
    multisite integer : SerLock, DesLock
   boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount,count

end_local


body
  


--    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  
   loopcont  = true
   SiteCheck  = false 

    --POWER_CONNECT    -- need this for reseting device
  
-----Dut power up function
   DutPowerUp(vio, v18, vcore, "UART", "COAX_GMSL2",POWERUP)
  
---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY
  
    fpga_set_UART_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
     wait(5ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
--      fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
--      wait(20ms)
     powerup_dnut_vdd_vterm(1.05,1.2)
     wait(5ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
     fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
    wait(6ms)    
--    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg

----Set SER and DES for coax or tp mode
    if TP_COAX = "TP" then
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
    else
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
    end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

       if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
       elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

      if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
      elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
      elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
     end_if 
    ser_link_speed_code = ser_rx_speed + ser_tx_speed
    des_link_speed_code = des_rx_speed + des_tx_speed

-- ----Program link rate
-- -------------------need to turn on DIS_REM_CC  bit for both SER and DES otherwise, after Handshake, can not commincation with DES.( Right after turn on FW_LOCK bit( code write 0xFC to CRTL7) 
-- ------------------ Ezgi has verified this on bench too.  Only need to turn on DIS_REM_CC if using UART mode; I2C mode is ok. Man Tran
    RegWrite(SER_ID, SR_REG1, 1, 16#00, (ser_link_speed_code | 0x10), "SER_UART_Write")             ---- SER GMSL link speed; 
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,(des_link_speed_code | 0x10) )             ---- DES GMSL link speed
 
     wait(2mS)    
     fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0 , 1,0x20) 
     RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#30, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89

---------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------
    -- Verify Inital Link via CTRL3 register
    --------------------------------
    -- CTRL3: looking for CMU_LOCKED at first, but then also TXDP_EN, RXDP_LOCK, and LOCKED (and not ERROR)

--   WaitForRegister_mod( Link_Lock_dly  , SR_CTRL3 , 0xCA , 0xCA , "SERDES" , false, true , ser_read_data , des_read_data , DEBUG )
   wait(Link_Lock_dly)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!

   wait(Link_Lock_dly)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!

   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
-- reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   

    while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  (lowword[site] = 0xde  OR lowword[site] =0xda  OR lowword[site] =0xCa OR lowword[site] =0xCE OR lowword[site] =0xEa OR lowword[site]=0xEE) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true     
                end_if
                if sitecount = sites then
                    loopcont = false
                end_if     
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
            if loopcont  then
                wait(1ms)
                RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
            end_if
            
        end_for            
 
    end_while






   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_CTRL3, 1)   -- DES lock bit, 0xCA expected   
   wait(0ms)
   
   for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      SerLock[site]  = integer(lowword[site])
      DesLock[site] = integer(reg_val[site])      
   end_for    

    --------------------------------------------------------------------
    -- Manual Link
    --------------------------------------------------------------------
    if DEBUG>0 then
        println(stdout, "@n", "Start following the test_link_prbs.sv sequence from icmanage (modified by back-and-forth with Ezgi)")
    end_if
    -- http://icmanage1.maxim-ic.com:8080/@md=d&cd=//depot/icm/proj/hs89/hs89a/digital/chip/verification/ASC/tests/&rg=s&c=bS2@//depot/icm/proj/hs89/hs89a/digital/chip/verification/ASC/tests/test_link_prbs.sv?ac=98&rev1=5&mu=362079
    -- edited by Ezgi's recommendations, and debug

    if DEBUG>0 then
        println(stdout, "@n", "Soft reset enable for both sides")
    end_if


-----Debug here

--     RegWrite(SER_ID, SR_INTR8, 1, 16#00, 0x1f , "SER_UART_Write") ----  0x20
--     RegWrite(SER_ID,  SR_INTR9, 1, 16#00, 0x51 , "SER_UART_Write") ---- 0x21
--     fpga_UART_Write( "FPGA1" , "DES",  DESA_ID ,  DR_INTR8 , 1  , 0x1F ) ---- 0x20
--     fpga_UART_Write( "FPGA1" , "DES",  DESA_ID , DR_INTR9 , 1  , 0x51 ) ---- 0x21

----


      RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 0x50 , "SER_UART_Write")
     fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_CTRL0 , 1 , 0x50 )                            -- RESET | AUTO | LINK_CFG:00(Dual)
    
---Disable GPIO


    RegWrite(SER_ID, 0x2c1 , 1, 16#00, 0x81, "SER_UART_Write")    
    RegWrite(SER_ID, 0x2c7 , 1, 16#00, 0x89, "SER_UART_Write")    
    RegWrite(SER_ID, 0x2cd , 1, 16#00, 0x81, "SER_UART_Write")    
    RegWrite(SER_ID, 0x2d3 , 1, 16#00, 0x81, "SER_UART_Write")    
    RegWrite(SER_ID, 0x2d9 , 1, 16#00, 0x81, "SER_UART_Write")    ---------------89
    RegWrite(SER_ID, 0x2dF , 1, 16#00, 0x81, "SER_UART_Write")    ---------------89
    RegWrite(SER_ID, 0x2e5 , 1, 16#00, 0x81, "SER_UART_Write")    ---------------89
    RegWrite(SER_ID, 0x2eb , 1, 16#00, 0x81, "SER_UART_Write")    ---------------89
    RegWrite(SER_ID, 0x2f1 , 1, 16#00, 0x81, "SER_UART_Write")    ---------------89
    RegWrite(SER_ID, 0x2f7 , 1, 16#00, 0x81, "SER_UART_Write")    ---------------89
    RegWrite(SER_ID, 0x2fd , 1, 16#00, 0x81, "SER_UART_Write")    

    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  0x2b0  , 1 , 0x81 ) 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  0x2b6  , 1 , 0x81 ) 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  0x2bc  , 1 , 0x81 ) 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  0x2c2  , 1 , 0x81 ) 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  0x2c8  , 1 , 0x89 ) 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  0x2ce  , 1 , 0x89 ) 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  0x2d4  , 1 , 0x81 ) 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  0x2da  , 1 , 0x11 ) 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  0x2e0  , 1 , 0x19 ) 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  0x2e6  , 1 , 0x19 ) 




-----------Set Ser
    RegWrite(SER_ID, SR_RLMSA7_A , 1, 16#00, 0x81, "SER_UART_Write")                                       -----      Set Man_CNTRL_EN; PHY Control enable; reg = 0x14A7
    RegWrite(SER_ID, SR_RLMSA7_B , 1, 16#00, 0x81, "SER_UART_Write")                                       -----      Set Man_CNTRL_EN; PHY Control enable reg = 0x15A7
    RegWrite(SER_ID, SR_CTRL7 , 1, 16#00, 0x80, "SER_UART_Write")                                          -----      Enable forward link            reg = 0x17                      
  
-----------Set DES
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  DR_RLMSA7_A  , 1 , 0x81 )                                       -----      Set Man_CNTRL_EN; PHY Control enable; reg = 0x14A7
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  DR_RLMSA7_B  , 1 , 0x81 )                                     -----      Set Man_CNTRL_EN; PHY Control enable reg = 0x15A7 
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID ,  DR_CTRL7     , 1 , 0x80 )                                       -----      Enable forward link            reg = 0x17               
----------Auto link    ---------here
    RegWrite(SER_ID, SR_CTRL0 , 1, 16#00, 0x10, "SER_UART_Write")                                           -----    RESET=0 | AUTO:1 | LINK_CFG:00(Dual)
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_CTRL0    , 1 , 0x10 )                        ------ RESET=0 | AUTO:1 | LINK_CFG:00(Dual)

--SER:PHY_EN_A=1, PHY_EN_B=1
    RegWrite(SER_ID, SR_CTRL7 , 1, 16#00, 0xE0, "SER_UART_Write")                                         ------ FW_CTRL_EN=1 | PHY_B_EN=1 | PHY_A_EN=1 | FW_LINK_MODE=00
--DES: PHY_EN_A=1, PHY_EN_B=1
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_CTRL7    , 1 , 0xE0 )                              ------- FW_CTRL_EN=1 | PHY_B_EN=1 | PHY_A_EN=1 | FW_LINK_MODE=00 

 
      --------------------------------------------------------------------
    -- Manual Calibration
    --------------------------------------------------------------------
    if DEBUG>0 then
        println(stdout, "@n", "Performing Calibration Before Uni-directional Link is established")
        println(stdout, "@n", "Manually calibrate SER side")
    end_if
--     -- SetReg(ser, '{'{`MAN_CALIB_A, 1'h1}});  Write packet: DEV=80, ADDR=5287, N=1, DATA=c1
--     -- SetReg(ser, '{'{`MAN_CALIB_B, 1'h1}});  Write packet: DEV=80, ADDR=5543, N=1, DATA=c1
 --Manually calibrate SER
    RegWrite(SER_ID, SR_RLMSA7_A , 1, 16#00, 0xC1 , "SER_UART_Write")                               ------- MAN_CTRL_EN | MAN_CALIB | PRE_HSK_PD
    RegWrite(SER_ID, SR_RLMSA7_B , 1, 16#00, 0xC1 , "SER_UART_Write")                               --------- MAN_CTRL_EN | MAN_CALIB | PRE_HSK_PD
---Readback value of RLMS88 check for calbit                         
 --Wait for SER calibration to complete (A&B), CalDone bit is 1
    wait(20mS)
--    WaitForRegister(  250ms , SR_RLMS88_A , 0x20 , 0x20 , "SER" , FALSE , ser_read_data , des_read_data , DEBUG )
    RegRead(SER_ID, SR_RLMS88_A, 1, upperword, lowword,"SER_UART_Read")                                     ----------- for SER CALBIT DONE  BIT 5 IS HIGH
    SerCalDoneA = integer( lowword&0x20)

------Check linkB
--   WaitForRegister(  250ms , SR_RLMS88_B , 0x20 , 0x20 , "SER" , FALSE , ser_read_data , des_read_data , DEBUG )
    RegRead(SER_ID, SR_RLMS88_B, 1, upperword, lowword,"SER_UART_Read")                                     ----------- for SER CALBIT DONE  BIT 5 IS HIGH
    SerCalDoneB = integer( lowword&0x20)     


--------Setup for des manual cal and check calbit done. done = high  
     -- SetReg(des, '{'{`MAN_CALIB_A, 1'h1}});   Write packet: DEV=90, ADDR=5287, N=1, DATA=c1
    -- SetReg(des, '{'{`MAN_CALIB_B, 1'h1}});   Write packet: DEV=90, ADDR=5543, N=1, DATA=c1
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMSA7_A    , 1 , 0xC1 )                                           -- MAN_CTRL_EN | MAN_CALIB | PRE_HSK_PD
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMSA7_B    , 1 , 0xC1 )                                           -- MAN_CTRL_EN | MAN_CALIB | PRE_HSK_PD
    wait(50ms)
--    WaitForRegister(  250ms , DR_RLMS88_A , 0x20 , 0x20 , "DES" , TRUE , ser_read_data , des_read_data , DEBUG ) 
    LowerRdWord = fpga_UART_Read( "FPGA1" , "DES" , DESA_ID  , DR_RLMS88_A , 1 )
    DesCalDoneA = integer(LowerRdWord &0x20)

--    WaitForRegister(  250ms , DR_RLMS88_B , 0x20 , 0x20 , "DES" , TRUE , ser_read_data , des_read_data , DEBUG )
    LowerRdWord = fpga_UART_Read( "FPGA1" , "DES" , DESA_ID  , DR_RLMS88_B , 1 )
    DesCalDoneB = integer(LowerRdWord &0x20)
  
-- --     --------------------------------------------------------------------
-- --     -- Enable Transmit and Receive on both ends of the link (BiDirectional Link)
-- --     --  then wait for rxdp_lock on both devices (to indicate receiving from link
-- --     --------------------------------------------------------------------
-- --      -- SetReg(ser, '{'{`MAN_TX_EN_A, 1'h1}});  Write packet: DEV=80, ADDR=5287, N=1, DATA=e1
-- --     -- SetReg(ser, '{'{`MAN_TX_EN_B, 1'h1}});  Write packet: DEV=80, ADDR=5543, N=1, DATA=e1
-- --     -- SetReg(ser, '{'{`FW_START_TX, 1'h1}});  Write packet: DEV=80, ADDR=23, N=1, DATA=f0
--SERDES RXEN=1
    RegWrite(SER_ID, SR_RLMSA7_A , 1, 16#00, 0xE1 , "SER_UART_Write")                                       -- MAN_CTRL_EN | MAN_CALIB | MAN_TX_EN | PRE_HSK_PD
    RegWrite(SER_ID, SR_RLMSA7_B , 1, 16#00, 0xE1 , "SER_UART_Write")                                       -- MAN_CTRL_EN | MAN_CALIB | MAN_TX_EN | PRE_HSK_PD
    RegWrite(SER_ID, SR_CTRL7 , 1, 16#00, 0xF0 , "SER_UART_Write")                                         -- FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX=1 | FW_LINK_MODE=b00
-------SETUP DES
-- --     -- SetReg(des, '{'{`MAN_TX_EN_A, 1'h1}});  Write packet: DEV=90, ADDR=5287, N=1, DATA=e1
-- --     -- SetReg(des, '{'{`MAN_TX_EN_B, 1'h1}});  Write packet: DEV=90, ADDR=5543, N=1, DATA=e1
-- --     -- SetReg(des, '{'{`FW_START_TX, 1'h1}});  Write packet: DEV=90, ADDR=23, N=1, DATA=f0
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_RLMSA7_A  , 1 , 0xE1 )                    -- MAN_CTRL_EN | MAN_CALIB | MAN_TX_EN | PRE_HSK_PD
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_RLMSA7_B  , 1 , 0xE1 )                    -- MAN_CTRL_EN | MAN_CALIB | MAN_TX_EN | PRE_HSK_PD
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_CTRL7     , 1 , 0xF0 )                    -- FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX=1 | FW_LINK_MODE=b00

----    -- SetReg(ser, '{'{`MAN_RX_EN_A, 1'h1}});  Write packet: DEV=80, ADDR=5287, N=1, DATA=f1
    RegWrite(SER_ID, SR_RLMSA7_A , 1, 16#00, 0xF1 , "SER_UART_Write")

----    -- SetReg(des, '{'{`MAN_RX_EN_A, 1'h1}});  Write packet: DEV=90, ADDR=5287, N=1, DATA=f1
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_RLMSA7_A    , 1 , 0xF1 ) 

---    -- SetReg(ser, '{'{`MAN_RX_EN_B, 1'h1}});  Write packet: DEV=80, ADDR=...., N=1, DATA=f1
    RegWrite(SER_ID, SR_RLMSA7_B , 1, 16#00, 0xF1 , "SER_UART_Write")    


----    -- SetReg(des, '{'{`MAN_RX_EN_B, 1'h1}});  Write packet: DEV=90, ADDR=5287, N=1, DATA=f1
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_RLMSA7_B    , 1 , 0xF1 ) 
    wait(1ms)
-------CHECK FOR RX data path LOCK
--    WaitForRegister_mod(  250ms , SR_CTRL3 , 0x40 , 0x40 , "SERDES" , false, true , ser_read_data , des_read_data , DEBUG) 
    RegRead(SER_ID, SR_CTRL3, 1, upperword, lowword,"SER_UART_Read")  
    SerRxdpLock = integer(LowerRdWord &0x40)
    LowerRdWord = fpga_UART_Read( "FPGA1" , "DES" , DESA_ID  , DR_CTRL3 , 1 )  --expect 0x40
    DesRxdpLock = integer(LowerRdWord &0x40)
    --------------------------------------------------------------------
    -- Finish stepping thru manual linking sequence
    --------------------------------------------------------------------

 --    if DEBUG>0 then
--         println(stdout, "@n", "2017-Jun-22: write Reg0x20 => 0x1F, Reg 0x21 => 0x5F on both SERDES before starting manual handshake")
--     end_if
    
    RegWrite(SER_ID, SR_INTR8, 2, 16#5F, 0x1F , "SER_UART_Write")                         -- INTR8 is LSB, INTR9 is MSB
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_INTR8     , 1 , 0x1F )             -- INTR8 is LSB, INTR9 is MSB
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_INTR9     , 1 , 0x5F )             -- INTR8 is LSB, INTR9 is MSB

 --    if DEBUG>0 then
--         println(stdout, "@n", "SERDES side TXDP_EN=1")
--     end_if
----     -- SetReg(ser, '{'{`FW_TXDP_EN, 1'h1}});   Write packet: DEV=80, ADDR=23, N=1, DATA=f8
----     -- SetReg(des, '{'{`FW_TXDP_EN, 1'h1}});   Write packet: DEV=90, ADDR=23, N=1, DATA=f8
    RegWrite(SER_ID, SR_CTRL7, 1, 16#00, 0xF8 , "SER_UART_Write")                               --FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX | FW_TXDP_EN | FW_LINK_MODE=b00
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_CTRL7   , 1 , 0xF8 )                       -- FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX | FW_TXDP_EN | FW_LINK_MODE=b00
    wait(1ms)

----    -- SetReg(ser, '{'{`FW_LOCK, 1'h1}});  Write packet: DEV=80, ADDR=23, N=1, DATA=fc
----    -- SetReg(des, '{'{`FW_LOCK, 1'h1}});  Write packet: DEV=90, ADDR=23, N=1, DATA=fc
    RegWrite(SER_ID, SR_CTRL7, 1, 16#00, 0xFC , "SER_UART_Write")                               -- FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX | FW_TXDP_EN | FW_LOCK | FW_LINK_MODE=b00
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_CTRL7     , 1 , 0xFC )                     -- FW_CTRL_EN=1 | PHY_B_EN | PHY_A_EN | FW_START_TX | FW_TXDP_EN | FW_LOCK | FW_LINK_MODE=b00
 --   fpga_UART_Write( "FPGA1" , "DES" , SER_ID , DR_CTRL7     , 1 , 0xFC )
    
    reg_val = fpga_UART_Read( "FPGA1" , "DES" , DESA_ID , DR_CTRL3     , 1 )        -----Have problem here. Can't not commnunication to DES any more. Need turn on DIS_REM_CC bit for DES and SER before handshake MT
    RegRead(SER_ID, SR_CTRL3, 1,upperword, lowword, "SER_UART_Read")          ---expect 0xCA
    for idx = 1 to sites do
        site = active_sites[idx]
        SerPrbsLock[site] = integer(lowword[site])
        DesPrbsLock[site] = integer(reg_val[site])
   endfor

--    WaitForRegister_mod(  250ms , SR_CTRL3 , 0xCA , 0xCA , "SERDES" ,false,true , ser_read_data , des_read_data , DEBUG )
    --------------------------------
    -- start Link PRBS after manual link
    --------------------------------
--SERDES LINK PRBSGEN
    RegWrite(SER_ID, SR_TX1_0, 1, 16#00, 0x80 , "SER_UART_Write")                
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_TX1_GMSL  , 1 , 0x80 )
 
--SERDES PRBSCHK
    RegWrite(SER_ID, SR_RX1, 1, 16#00, 0x80 , "SER_UART_Write")   
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RX1_GMSL , 1 , 0x80 )
    
    --------------------------------------------------------------------
    -- clear dec_err values from prbs initialization
    --------------------------------------------------------------------
    if DEBUG>0 then
        println(stdout, "@n", "Clear error registers to clean errors that happen while turning on the prbs")
    end_if
    --      rd TCTRL.CNT0-1 DEC_ERR_A/B (0x22-0x23) -- Clear error registers to clean errors that happen while turning on the PRBS
    RegRead(SER_ID, SR_CNT0, 2,upperword, lowword, "SER_UART_Read")                            -- CNT0 goes into low byte, CNT1 into next byte
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_CNT0      , 2 )             -- CNT0 goes into low byte, CNT1 into next byte


    --------------------------------------------------------------------
    -- wait for PRBS SYNC
    -- datalog#4:  PRBSSYNC_FAIL: ... = { [15:8]=DNUT.GMSL_RX3, [7:0]=DUT.GMSL_RX3 }
    --------------------------------------------------------------------

--    WaitForRegister_mod(  50ms , SR_RX3 , 0x88 , 0x88 , "SERDES" ,false, TRUE , ser_read_data , des_read_data , DEBUG )

    RegRead(SER_ID, SR_RX3, 1,upperword, lowword, "SER_UART_Read")          --expect 0x88 
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID , DR_RX3_GMSL , 1)  --expect 0x88 
    
    SerPrbsSync = integer(lowword&0x88)
    DesPrbsSync = integer(RdWordLower&0x88)

-- --check pre Error  
----Setup Error pin to measure voltage
   disconnect digital pin SER_GPIO1_LFLTB_ERRB from dcl
    connect digital pin SER_GPIO1_LFLTB_ERRB to ppmu
   set digital ppmu SER_GPIO1_LFLTB_ERRB to fi 0.1uA imax 10uA measure v  max 4v clamps to vmin 0v vmax vio + 40mV
   
    wait(20us)
   measure digital ppmu SER_GPIO1_LFLTB_ERRB voltage average 1 delay 10us into PreVerr
--  
   --------------------------------------------------------------------
    -- Propagate error thru link, to verify link is _truly_ there, and not just claiming prbssync

    RegWrite(SER_ID, SR_TX2_0, 1, 16#00, 0x80 , "SER_UART_Write")   
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_TX2_GMSL  , 1 , 0x40 )

--    --      wr GMSL.TX1.{LINK_PRBS_GEN | ERRG_EN_A | ERRG_EN_B} => 8'b1_0_11_00_0_0 = 0xB0 (addr 0x29)
    RegWrite(SER_ID, SR_TX1_0, 1, 16#00, 0xB0 , "SER_UART_Write")
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_TX1_GMSL , 1 , 0xB0 )
    -- wait long enough for 16 err at 1 err per ~5120 samples, slow reverse channel (0.1875GHz), plus setup overhead time
------make sure Error asserted

    measure digital ppmu SER_GPIO1_LFLTB_ERRB voltage average 1 delay 10us into Verr  ---- error so it should be low
    wait(10ms)
    reg_val = fpga_UART_Read( "FPGA1" , "DES" , DESA_ID , DR_CTRL3     , 1 )       
    RegRead(SER_ID, SR_CTRL3, 1,upperword, lowword, "SER_UART_Read")          ---expect 0xCA
    
    SerErrbit = integer( reg_val & 0x04)
    DesErrbit = integer( lowword& 0x04)

    --------------------------------------------------------------------
    -- datalog#5-8:  A_FWD, B_FWD, A_REV, B_REV error counts
    --      per simulation file, ok as long as +-20% from expected target (128 or 16)
    --------------------------------------------------------------------

-- fwd: expect 0x80 (128) errors on forward channel
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_CNT0  , 1 )   --CNT0, error detect linkA,  0x10 on the SER end (from DES TX)
    DesErrCntA = integer(LowerRdWord)
    RdWordLower = fpga_UART_Read( "FPGA1" , "DES"  , DESA_ID  , DR_CNT1  , 1 )   --CNT1, error detect linkb
    DesErrCntB = integer(LowerRdWord)

-- rev: expect 0x10 (16) errors on reverse channel   
    RegRead(SER_ID, SR_CNT0, 1,upperword, RdWordLower, "SER_UART_Read")      --CNT0, error detect linkA        
    SerErrCntA = integer(RdWordLower)

    RegRead(SER_ID, SR_CNT1, 1,upperword, RdWordLower, "SER_UART_Read")      --CNT1, error detect linkB        
    SerErrCntB = integer(RdWordLower)

-----Need check Error pins for DUT and DNUT currently, DUT error failed. DNUT need FPGA mod to measure error pin

    measure digital ppmu SER_GPIO1_LFLTB_ERRB voltage average 1 delay 10us into ClearVerr    ---- should be high



---Need code righ here
-----

    --------------------------------------------------------------------
-----------
 
    --------------------------------------------------------------------
    -- Worst-Case Supply Current
    --------------------------------------------------------------------
    measure hcovi i on SER_VDD for 170 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 170 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 170 samples every 10us averaged into i_vddio_meas

    scatter_1d( gather_1d(i_vdd_meas  ,1) , icc_dlog , 1 )
    scatter_1d( gather_1d(i_vdd18_meas,1) , icc_dlog , 2 )
    scatter_1d( gather_1d(i_vddio_meas,1) , icc_dlog , 3 )

    
 -------------- Power Down --------------------------- 
    disconnect digital pin SER_GPIO1_LFLTB_ERRB from ppmu
    connect digital pin SER_GPIO1_LFLTB_ERRB to dcl
     powerdown_device(POWERDOWN)
    open cbit  DNUT_RXTX_RELAY
    open cbit CB2_SLDC                 --OVI_RELAYS 
    open cbit COAXB_M_RELAY            --OVI_RELAYS
     fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)        
----data log
    test_value SerLock with ser_lock_it
    test_value DesLock with des_lock_it        
    test_value SerCalDoneA with SerCalDoneA_ft
    test_value SerCalDoneB with SerCalDoneB_ft
 
    test_value DesCalDoneA with DesCalDoneA_ft
    test_value DesCalDoneB with DesCalDoneB_ft

    test_value SerRxdpLock with SerRxdpLock_ft  
    test_value DesRxdpLock with DesRxdpLock_ft
  
    test_value SerPrbsSync with SerPrbsSync_ft
    test_value DesPrbsSync with DesPrbsSync_ft
 
    test_value SerPrbsLock with SerPrbsLock_ft
    test_value DesPrbsLock with DesPrbsLock_ft

    test_value PreVerr with PreVerr_ft 
 
    test_value SerErrCntA with SerErrCntA_ft
    test_value SerErrCntB with SerErrCntB_ft
    test_value DesErrCntA with DesErrCntA_ft
    test_value DesErrCntB with DesErrCntB_ft
 

  --test_value PreVerr with PreVerr_ft 
  test_value Verr with Verr_ft 
  test_value ClearVerr with ClearVerr_ft         

 end_body



procedure Sleep_WakeupTest(vcore, vio, v18,POWERUP,POWERDOWN,TP_COAX,TX_SPD,RX_SPD,Link_Lock_dly,ISleep1,IWake1,ISleep2,IWake2,DSTA,ISleep3,IWake3,ISleep4,ISleep5)

--------------------------------------------------------------------------------
in float                        : vcore, vio, v18
in_out array of float_test      : ISleep1,IWake1,ISleep2,IWake2,ISleep3,IWake3,ISleep4,ISleep5
in_out integer_test             : DSTA
in boolean                      : POWERUP,POWERDOWN
in string[20]                   : TP_COAX--,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float                        : TX_SPD,RX_SPD,Link_Lock_dly ---,MIPI_SPD,Link_Lock_dly
--in lword                        : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
local



  multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, des_read0, des_read1, des_read2, des_read,reg_val15,FailLockCount[1]

--  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
--  multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  multisite integer :  number_of_lanes_test

  word              : sites, idx, site,count, LoopCount
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
--  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode
  multisite integer    : DST_A_1

    multisite float : Idd_Sleep1[1],Idd18_Sleep1[1],Iddio_Sleep1[1],Idd_Sleep2[1],Idd18_Sleep2[1],Iddio_Sleep2[1],Idd_Sleep3[1],Idd18_Sleep3[1],Iddio_Sleep3[1]
    multisite float : Idd_Sleep4[1],Idd18_Sleep4[1],Iddio_Sleep4[1],Idd_Sleep5[1],Idd18_Sleep5[1],Iddio_Sleep5[1]
    multisite float : Idd_1[1],Idd18_1[1],Iddio_1[1],Idd_2[1],Idd18_2[1],Iddio_2[1],Idd_3[1],Idd18_3[1],Iddio_3[1]
    multisite float : plot[100]
    multisite float : I_SLEEP1[3],I_WAKE1[3],I_SLEEP2[3],I_WAKE2[3],I_SLEEP3[3],I_WAKE3[3],I_SLEEP4[3],I_SLEEP5[3],IVddioTemp[1]
    boolean         : loop_need
    multisite boolean         : SiteDoneCount
    boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount
end_local


body
   loopcont  = true
   SiteCheck  = false   
    SiteDoneCount = false
    count  = 0
    LoopCount  = 0
    loop_need  = true
    LBDONE = 0  -- need initialize to fail first
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
   DutPowerUp(vio, v18, vcore, "UART", "TP_GMSL2",POWERUP)

    
-----    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     --  for debug device ID, to make sure we test the correct device

---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY
     
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(0ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
    powerup_dnut_vdd_vterm(1.05,1.2)
    
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
    fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
    wait(6ms)
    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg
    wait(0ms)
      
--    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read     for debug

 ---------close CSI feedback loop
    close cbit  FB_RELAY
    wait(5mS)
----Set SER and DES for coax or tp mode
    if TP_COAX = "TP" then
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
    else
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
    end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

       if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
       elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

      if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
      elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
      elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
     end_if 
    ser_link_speed_code = ser_rx_speed + ser_tx_speed
    des_link_speed_code = des_rx_speed + des_tx_speed

----Program link rate

    RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed
wait(20ms) ----needed for reduce wait time on link lock MT 6/2018
-----Write to reg10 to update link speed setting 
    
    -- write Reg0x10 to update to COAX mode
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1,0x10  )  
    RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#30, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89
    wait(1ms)        
    RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)
-----No need to repeat at DES
--     fpga_UART_Write("FPGA1","DES", DESA_ID, 16#10, 1, 0x30)
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x10, 1)      -- self adjust back to 0x01
--     wait(0ms)
     
--------------Check for lock, error bit
----Currently, HS89 rev 1.5G error bit always on.
----at fwd_speed = 6.0G, REV_SPEED = 0.75 then no error.
----at fwd_speed = 3.0G, REV_SPEED = 0.375 then no error.
---------------------------------------------------------------------------------------------------------------------------------------------

   wait(Link_Lock_dly )   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
  RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA
    while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  (lowword[site] = 0xde  OR lowword[site] =0xda  OR lowword[site] =0xCa OR lowword[site] =0xCE OR lowword[site] =0xEa OR lowword[site]=0xEE) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true     
                end_if
                if sitecount = sites then
                    loopcont = false
                end_if     
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
            if loopcont  then
                wait(1ms)
                RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
            end_if
            
        end_for            
 
    end_while

count   =0 --- reset


   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   


--------Program DST_A register

    RegRead(SER_ID, SR_I2C_3, 1, upperword, lowword,"SER_UART_Read")    --   
    RegWrite(SER_ID,SR_I2C_3 , 1, 16#0, 16#AA, "SER_UART_Write")        ------ program DST_A[7:1] with 0xaa

---Enable sleep mode from DNUT
   fpga_UART_Write("FPGA1","DES", SER_ID, SR_CTRL0, 1,0x18  )             ---- Auto Link and enter sleep
   wait(2ms)
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1, 0x50  )             ---- Auto Link and reset link to 1  
   wait(9ms)----needed for part enter sleep
   
-----Measure sleep current
    set hcovi SER_VDDIO  to fv vio   vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA
    set hcovi SER_VDD    to fv vcore measure i max 500uA  clamp imax 500uA imin -500uA
    set hcovi SER_VDD18  to fv v18 measure i max 500uA  clamp imax 500uA imin -500uA

    wait(1ms)
    measure hcovi i on SER_VDD + SER_VDD18 + SER_VDDIO for 20 samples every 10us averaged into I_SLEEP1
    set hcovi SER_VDDIO + SER_VDD + SER_VDD18 to fv vio   vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA
    wait(1ms)
--------------- Wake up part from link A
    set hcovi SER_VDDIO  to fv vio   vmax 4V measure i max 600mA  clamp imax 900mA imin -900mA ----need to set high current prevent glitch mt 2/2019
    set hcovi SER_VDD  to fv vcore   vmax 2V measure i max 600mA  clamp imax 800ma imin -800mA
    set hcovi SER_VDD18 to fv v18   vmax 2V measure i max 600mA  clamp imax 800ma imin -800mA

    wait(1ms)

    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1, 0x10  )             ---- Auto Link and reset link to wake up ser
    wait(4ms)                                                                 ---Part should wake up with 2ms wait
    set hcovi SER_VDDIO  to fv vio   vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA  ----reduce current  for accuracy meas
    wait(1ms)
    measure hcovi i on SER_VDD + SER_VDD18 + SER_VDDIO    for 20 samples every 10us averaged into I_WAKE1

-- RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1, 0x50  )             ---- Auto Link and reset linkto 1 to stop link handshaking
     reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_CTRL0, 1)   -- DES lock bit, 0xCA expected       
     wait(5ms)
--    wait(56ms)      ----Need this this much to enter sleep mode   55ms      ---- part should be back to sleep mode 8 ms does not work
--    wait(56ms)      ----Need this this much to enter sleep mode   55ms      ---- part should be back to sleep mode 8 ms does not work for cold

--------------This section for finding what time needed for part enter sleep mode debug only
--  --    idxs =0
-- --     loop_need  = false                                                                  ----initialize
-- --     measure hcovi i on SER_VDD for 20 samples every 10us averaged into Idd_Sleep2
-- --     for idx = 1 to sites do
-- --         site = active_sites[idx]
-- --         if Idd_Sleep2[site]  > 1ma then
-- --            loop_need = true
-- --         end_if 
-- --    end_for
-- --     while  loop_need do
-- --         loop_need   = false                     ---- reset
-- --         wait(1ms)
-- --         measure hcovi i on SER_VDD for 20 samples every 10us averaged into Idd_Sleep2
-- -- 
-- --         for idx = 1 to sites do
-- --             site = active_sites[idx]
-- --             if Idd_Sleep2[site]  > 1ma then
-- --                 loop_need = true
-- --             end_if 
-- --             plot[site,idxs +1] =Idd_Sleep2[site,1]
-- --         end_for
-- --         idxs = idxs + 1
-- --         if idxs > 100 then
-- --             break
-- --        end_if    
-- --     end_while
-- -- -------------------------------------------------------------------------------------------------------
---Add this loop to maximized test time
    while loop_need do 
        wait(10ms)
        LoopCount = LoopCount + 1
        measure hcovi i on SER_VDD + SER_VDD18 + SER_VDDIO for 20 samples every 10us averaged into I_SLEEP2
        for idx = 1 to sites do
            site = active_sites[idx]
            if I_SLEEP2[site,1] < 10ma and not SiteDoneCount[site] then
                count = count +1
                SiteDoneCount[site] = true
            end_if            
        end_for
        if count = sites or LoopCount > 20 then
            loop_need = false
            
        end_if
    end_while
    set hcovi  SER_VDD  to fv vcore   vmax 4V measure i max 2mA clamp imax 2mA imin -2mA
    set hcovi  SER_VDD18   to fv v18   vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA       
    wait(5ms)
    measure hcovi i on SER_VDD + SER_VDD18 + SER_VDDIO for 20 samples every 10us averaged into I_SLEEP2    
-----------toggle main Rx to wake up 
  set hcovi   SER_VDDIO  to fv vio  vmax 4V measure i max 500mA  clamp imax 500mA imin -500mA    ----Set high current to prevent glitch MT
  set hcovi   SER_VDD18  to fv v18  vmax 4V measure i max 500mA  clamp imax 500mA imin -500mA                        ----change rangeback
  set hcovi   SER_VDD   to fv vcore   vmax 4V measure i max 500mA  clamp imax 500mA imin -500mA                        ----change rangeback
    wait(1ms) 
    wait(4ms)
    execute digital pattern "PowerUp" at label "Wake_Up"   run to end wait      ---------------Provide dummy pulses (3-5) to DUT on main RX pin.
    wait(1ms)  ---- otherwise failed ivddio                                          -----------        part should wake up
    set hcovi   SER_VDDIO  to fv vio  vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA ---reduce to measure more acc
    wait(1ms)    
    measure hcovi i on SER_VDD + SER_VDD18 + SER_VDDIO for 20 samples every 10us averaged into I_WAKE2
    
    RegWrite(SER_ID, SR_CTRL0, 1, 16#0, 16#10, "SER_UART_Write")    ---------Set sleep to to 0 permanently wake up part.
    RegRead(SER_ID, SR_I2C_3, 1, upperword, lowword,"SER_UART_Read")            ----Expect lowword = 0x55
    DST_A_1 = integer(lowword)                       -- for datalog
    wait(5mS)----needed
       set hcovi   SER_VDDIO  to fv vio  vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA   
        wait(5mS)----needed
    measure hcovi i on  SER_VDDIO for 20 samples every 10us averaged into IVddioTemp
    for idx = 1 to sites do
        site = active_sites[idx]
        I_WAKE2[site,3] =  IVddioTemp[site,1]
    end_for
-----------------Wake up detection test through Link B
--    Write WAKE_EN_B=1, WAKE_EN_A=0 to DUT.
    RegWrite(SER_ID, SR_PWR4, 1, 16#0, 16#2A, "SER_UART_Write")  ------WAKE_EN_B=1, WAKE_EN_A=0 
    RegWrite(SER_ID,SR_CTRL0 , 1, 16#0, 16#18, "SER_UART_Write") ---- Auto Link and enter sleep locally link is not active
--   fpga_UART_Write("FPGA1","DES", SER_ID, SR_CTRL0, 1, 0x18  )             ---- Auto Link and enter sleep can not use this link is not locked
   wait(2ms)
--   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1, 0x50  )             ---- Auto Link and reset linkto 1  
   wait(9ms)----needed for part enter sleep

  set hcovi   SER_VDD18  to fv v18  vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA                        ----change rangeback
  set hcovi   SER_VDD   to fv vcore   vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA                        ----change rangeback
    wait(1ms)  
 
 
    measure hcovi i on SER_VDD  + SER_VDD18 + SER_VDDIO for 20 samples every 10us averaged into I_SLEEP3
  set hcovi   SER_VDDIO  to fv vio  vmax 4V measure i max 500mA  clamp imax 500mA imin -500mA  ---prevent glitch MT 2/2019
  set hcovi   SER_VDD18  to fv v18  vmax 4V measure i max 500mA  clamp imax 500mA imin -500mA                        ----change rangeback
  set hcovi   SER_VDD   to fv vcore   vmax 4V measure i max 500mA  clamp imax 500mA imin -500mA                        ----change rangeback
    wait(1ms)

-----    Write RESET_LINK=0 to DNUT (Link B wake up detection circuit would detect activity on the link and wake up DUT)
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1, 0x10  )             ---- Auto Link and reset link 0 to wake up ser
    wait(1ms)
    set hcovi   SER_VDDIO  to fv vio  vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA                        ----change rangeback
    wait(1ms)
    measure hcovi i on SER_VDD + SER_VDD18 + SER_VDDIO  for 20 samples every 10us averaged into I_WAKE3

    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1, 0x50  )             ---- Auto Link and reset linkto 1 to stop link handshaking   
    RegWrite(SER_ID, SR_CTRL0, 1, 16#0, 16#20, "SER_UART_Write")              ---------Set sleep to  0 permanently wake up part 
-------------Wake up dection disable
    RegWrite(SER_ID, SR_PWR4, 1, 16#0, 16#4A, "SER_UART_Write")             ------WAKE_EN_B=0, WAKE_EN_A=0 DIS_LOCAL_WAKE = 1
   
    RegWrite(SER_ID, SR_CTRL0, 1, 16#0, 16#18, "SER_UART_Write")        ---- Auto Link and enter sleep
----    fpga_UART_Write("FPGA1","DES", SER_ID, SR_CTRL0, 1,0x18  )             ---- Auto Link and enter sleep, link not lock can not write from the other side
    wait(2ms)
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1, 0x50  )             ---- Auto Link and reset linkto 1  
    wait(9ms)----needed for part enter sleep

  set hcovi   SER_VDD18  to fv v18  vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA                        ----change rangeback
  set hcovi   SER_VDD   to fv vcore   vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA                        ----change rangeback
    wait(1ms) 
 
    measure hcovi i on SER_VDD  + SER_VDD18 + SER_VDDIO for 20 samples every 10us averaged into I_SLEEP4

  set hcovi   SER_VDD18  to fv v18  vmax 4V measure i max 500mA  clamp imax 500mA imin -500mA                        ----change rangeback
  set hcovi   SER_VDD   to fv vcore   vmax 4V measure i max 500mA  clamp imax 500mA imin -500mA                        ----change rangeback
    wait(1ms)
 
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1, 0x40  )             ---- Auto Link and reset link 0 to wake up ser
    execute digital pattern "PowerUp" at label "Wake_Up" run to end wait        ---------------Provide dummy pulses (3-5) to DUT on main RX pin.
    wait(2ms)   
  set hcovi   SER_VDD18  to fv v18  vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA                        ----change rangeback
  set hcovi   SER_VDD   to fv vcore   vmax 4V measure i max 500uA  clamp imax 500uA imin -500uA                        ----change rangeback
    wait(1ms) 
 
    measure hcovi i on SER_VDD   + SER_VDD18 + SER_VDDIO for 20 samples every 10us averaged into I_SLEEP5


-------------- Power Down --------------------------- 
   set hcovi SER_VDDIO to fv vio   vmax 4V measure i max 500mA  clamp imax 500mA imin -500mA 

--   set digital pin ALL_PATTERN_PINS - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V       
--      set digital pin ALL_PATTERN_PINS  levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V       
    if POWERDOWN then
        set digital pin ALL_PATTERN_PINS  - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V   
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
        wait(6ms)
--        powerdown_device(POWERDOWN)
        open cbit CB2_SLDC                 --OVI_RELAYS 
        open cbit COAXB_M_RELAY            --OVI_RELAYS
        open cbit  FB_RELAY
        open cbit  FB_RELAY
        open cbit  DNUT_RXTX_RELAY
        powerdown_device(POWERDOWN)
    end_if



 test_value I_SLEEP1 with ISleep1 
 test_value I_WAKE1 with IWake1
 test_value I_SLEEP2 with ISleep2 
 test_value I_WAKE2 with IWake2
 test_value DST_A_1 with DSTA
 test_value I_SLEEP3 with ISleep3 
 test_value I_WAKE3 with IWake3 
 test_value I_SLEEP4 with ISleep4
 test_value I_SLEEP5 with ISleep5 
 end_body



procedure TestGMSL1ReverseThreshold(Vdd,  Vdd18, Vddio,GMSL1_rev_HIM_300kHz,GMSL1_rev_leg_100kHz ,GMSL1,POWERUP,POWERDOWN,Rev_HimFT,Rev_NonHimFt)
--------------------------------------------------------------------------------
in float                : Vdd, Vdd18, Vddio,Rev_HimFT,Rev_NonHimFt
in_out float_test       : GMSL1_rev_HIM_300kHz,GMSL1_rev_leg_100kHz
in boolean              : POWERUP,POWERDOWN
in_out integer_test     : GMSL1

local
  multisite float : TxPHMeas[2], TxPLMeas[2], TxNHMeas[2], TxNLMeas[2]
  multisite float : VodH[4], VodL[4], Vod[4], VodDelta[4], VcmH[4], VcmL[10], Vcm[4], VcmDelta[10],Vout[2],VoutDelta,VosCoax[2],VosCoaxDelta
  multisite float : TxPH_1Meas[2], TxPL_1Meas[2], TxNH_1Meas[2], TxNL_1Meas[2]
  multisite float : TxPDisMeas[2], TxNDisMeas[2], TxDis[4]
  PIN LIST[2]     : MeasVi16P, MeasVi16N
  word            : CurSite
  lword           : Reg1Value, Junk
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword  
  word              : sites, idx, site, siteidx
  multisite integer : reg_val 
  multisite lword   : reg_val_des
    float             : TestFreq, TestPrd
    boolean           : search ,needwait    ------=true
    multisite float   : threshold, threshold_attenuate, threshold_attenuate_him
    integer             :site_counter    
    float     : vih_level, vih_step
    multisite boolean : switched    


end_local

body
  active_sites = get_active_sites
  sites = word(len(active_sites))
    get_expr("OpVar_Char",search )


--   -- setup some pin lists to make cadence statements more readable maybe move to global pin groups
--     MeasVi16N =  DC_SE_M_A_VI + DC_SE_M_B_VI                 --DES_TXOUT0_N_SIOA_N_VI16+DES_TXOUT1_N_SIOB_N_VI16
--     MeasVi16P =  DC_SE_P_A_VI + DC_SE_P_B_VI                 --DES_TXOUT0_P_SIOA_P_VI16+DES_TXOUT1_P_SIOB_P_VI16

    set digital pin SER_GPO4_CFG0  + SER_GPO6_CFG2 levels to vil Vconf0 vih Vddio   -- TP/UART mode with DEV_ID = 0x80
    set digital pin  SER_GPO5_CFG1 levels to vil Vconf1 vih Vddio                    ---GMSL2 mode  AND COAX
    close cbit DC_K5 + DC_K8 + DC_K6                                                    ---------Connect to Attenuator
--    close hcovi DC_K7 cbits
    close cbit COAXB_P_RELAY + COAXB_M_RELAY ---Connecto DC circuit
    wait(1ms)

----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL1",POWERUP) ---Set link to GMSL1

    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!


-----debug in what mode    
    RegRead(SER_ID,SR_REG6 , 1, RdWordUpper, RdWordLower, "SER_UART_Read")-----GMSL1 then read back = 0xb and GMSL2 then 0x8b
----Turn on GMSL1 link mode
    RegWrite(SER_ID, SR_GMSL1_4, 1, 0, 16#83, "SER_UART_Write")

    for idx = 1 to sites do
        site = active_sites[idx]
        reg_val[site]  = (integer(RdWordLower[site])  & 0x80) >> 7   
    end_for 
----Turn on GMSL1 HIM mode
    RegWrite(SER_ID, SR_GMSL1_D, 1, 0, 16#80, "SER_UART_Write")

-----Apply a 300 kHz signal to SIOP/SION in HIM mode-----------------------------------
    disconnect digital pin SER_SIOAP + SER_SIOAN  + SER_SIOBP + SER_SIOBN  from ppmu
    connect digital pin SER_SIOAP + SER_SIOAN  + SER_SIOBP + SER_SIOBN  to dcl 
    set digital pin SER_SIOAP + SER_SIOAN  + SER_SIOBP + SER_SIOBN levels to vil 0V vih Vddio
    set digital pin SER_GPIO20_TXSCL modes to comparator enable all fails --load normal

    TestFreq = 300KHz
    TestPrd = 1.0/(TestFreq*2.0)
    set digital clock msdi period t0 to double(TestPrd) c0 to double(TestPrd) for "CLK_100Khz"  -- Set the timing to run at 300KHz (3.33us clock cycle)
    set digital pin SER_GPIO20_TXSCL msdi compare data 0.75*TestPrd for "CLK_100Khz"
 

--    search = true
    threshold = -1.0
    site_counter = 0
    vih_step = 4mV -- 4mv/40 = 100uV steps after attenuator 
    vih_level = 2.0 -- 1V/40 = 25mV start voltage after attenuator 

    while search do
        set digital pin SER_SIOAP + SER_SIOAN levels to vil 0V vih vih_level
        execute digital pattern "GMLS1_reverse_threshold" at label "GMSL1_reverse" run to end into switched
        --abort digital pattern
        for siteidx = 1 to sites do
            site = active_sites[siteidx]
            if not (switched[site]) and threshold[site] == -1.0  then
                threshold[site] = vih_level + vih_step
                threshold_attenuate_him[site] = threshold[site]/float(40) --Apply GMSL1 reverse signal through 26 dB attenuator (20x), plus divide in half to report VPk
                site_counter = site_counter + 1
            end_if
        end_for
        if vih_level < 51mV or site_counter = integer (sites)  then
            search = false
        end_if
        vih_level = vih_level - vih_step
    end_while
    if (not search) then   ---- go no go test MT 2/2019
            vih_level  = Rev_HimFT*40.0
            set digital pin SER_SIOAP + SER_SIOAN levels to vil 0V vih vih_level
            execute digital pattern "GMLS1_reverse_threshold" at label "GMSL1_reverse" run to end into switched
            for siteidx = 1 to sites do
                site = active_sites[siteidx]
                if  (switched[site])  then
                    threshold_attenuate_him[site]   =( Rev_HimFT - 1mV)    ---datalog
                else
                    threshold_attenuate_him[site]   = -999mV    ---datalog failed
                end_if
            end_for

    end_if 

wait(0)
----Now change to legacy mode
----Turn on GMSL1 HIM disable mode
    RegWrite(SER_ID, SR_GMSL1_D, 1, 0, 16#00, "SER_UART_Write")
 -----For some reason, HIM mode does not update after write     

    RegRead(SER_ID, SR_GMSL1_D, 1, upperword, lowword,"SER_UART_Read")
    for siteidx = 1 to sites do
            site = active_sites[siteidx]
            if lowword[site] <> 0x00 then
                needwait = true
            end_if
     end_for
    if needwait then
        wait(15ms)
         RegWrite(SER_ID, SR_GMSL1_D, 1, 0, 16#00, "SER_UART_Write")   
    end_if
    
    TestFreq = 100KHz
    TestPrd = 1.0/(TestFreq*2.0)
    set digital clock msdi period t0 to double(TestPrd) c0 to double(TestPrd) for "CLK_100Khz"  -- Set the timing to run at 100KHz (10us clock cycle)
    set digital pin SER_GPIO20_TXSCL msdi compare data 0.75*TestPrd for "CLK_100Khz"
 
--    search = true
    threshold = -1.0
    site_counter = 0
    vih_step = 4mV -- 4mv/40 = 100uV steps after attenuator 
    vih_level = 2.0 -- 1V/40 = 25mV start voltage after attenuator 
    while search do
        set digital pin SER_SIOAP + SER_SIOAN levels to vil 0V vih vih_level
        execute digital pattern "GMLS1_reverse_threshold" at label "GMSL1_reverse" run to end into switched
        --abort digital pattern
        for siteidx = 1 to sites do
            site = active_sites[siteidx]
            if not (switched[site]) and threshold[site] == -1.0  then
                threshold[site] = vih_level + vih_step
                threshold_attenuate[site] = threshold[site]/float(40) --Apply GMSL1 reverse signal through 26 dB attenuator (20x), plus divide in half to report VPk
                site_counter = site_counter + 1
            end_if
        end_for
        if vih_level < 51mV or site_counter = integer (sites)  then
            search = false
        end_if
        vih_level = vih_level - vih_step
    end_while

    if (not search) then   ---- go no go test MT 2/2019
            vih_level  = Rev_NonHimFt*40.0
            set digital pin SER_SIOAP + SER_SIOAN levels to vil 0V vih vih_level
            execute digital pattern "GMLS1_reverse_threshold" at label "GMSL1_reverse" run to end into switched
            for siteidx = 1 to sites do
                site = active_sites[siteidx]
                if  (switched[site])  then
                    threshold_attenuate[site]   =( Rev_NonHimFt - 1mV)    ---datalog
                else
                    threshold_attenuate[site]   = -999mV    ---datalog failed
                end_if
            end_for

    end_if 






wait(0)
 -----------------------
---------power down 
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
  wait(500us)
  open digital cbit    ABUS_RELAY +  MFP_LT_RELAY
  open cbit CB2_SLDC + CB1_SLDC  ---Connecto DC circuit
  open cbit COAXB_P_RELAY + COAXB_M_RELAY 
  connect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP to dcl
--  open hcovi DC_K7 cbits
open hcovi DC_K5 + DC_K8 + DC_K6 cbits
      powerdown_device(POWERDOWN)


----Datalog


  -- Calculate the VOD, VCM and complimetary differences, store into single variables or all I/O  
  -- I/O Order TXOUTA_0, TXOUTA_1, TXOUTA_2, TXOUTA_3, TXCLKA, TXOUTB_0, TXOUTB_1, TXOUTB_2, TXOUTB_3, TXCLKB
  for idx = 1 to sites do
    CurSite = active_sites[idx]
        Vout[CurSite, 1] = TxPHMeas[CurSite, 1] - TxPLMeas[CurSite, 1]         -- SIOA_P
        Vout[CurSite, 2] = TxNHMeas[CurSite, 1] - TxNLMeas[CurSite, 1]         -- SIOA_N
        VoutDelta[CurSite] = Vout[CurSite, 1] - Vout[CurSite, 2]               ----Delta Vo
        VosCoax[CurSite, 1] = (TxPHMeas[CurSite, 1] + TxPLMeas[CurSite, 1])/2.0   -- SIOA_P Vos
        VosCoax[CurSite, 2] = (TxNHMeas[CurSite, 1] + TxNLMeas[CurSite, 1] )/2.0   -- SIOA_N Vos
        VosCoaxDelta[CurSite] = VosCoax[CurSite, 1] - VosCoax[CurSite, 2]           ------DeltaVos Coax
        Vod[CurSite, 1] = (TxPH_1Meas[CurSite, 1] -  TxNL_1Meas[CurSite, 1])+( TxNH_1Meas[CurSite, 1] -TxPL_1Meas[CurSite, 1])         -- SIOA_VOD
        Vcm[CurSite, 1] = (TxPH_1Meas[CurSite, 1] + TxPL_1Meas[CurSite, 1])/2.0   -- SIOA_P
        Vcm[CurSite, 2] = (TxNH_1Meas[CurSite, 1] + TxNL_1Meas[CurSite, 1])/2.0   -- SIOA_N
       VcmDelta[CurSite, 1] = Vcm[CurSite, 1] - Vcm[CurSite, 2]  
--       Vod[CurSite, 1] = TxPHMeas[CurSite, 1] - TxPLMeas[CurSite, 1]         -- SIOA_P
--       Vod[CurSite, 2] = TxNHMeas[CurSite, 1] - TxNLMeas[CurSite, 1]         -- SIOA_N

--       Vod[CurSite, 3] = TxPHMeas[CurSite, 2] - TxPLMeas[CurSite, 2]         -- SIOB_P
--       Vod[CurSite, 4] = TxNHMeas[CurSite, 2] - TxNLMeas[CurSite, 2]         -- SIOB_N
--       VodDelta[CurSite, 1] = Vod[CurSite, 1] - Vod[CurSite, 2]
--       VodDelta[CurSite, 2] = Vod[CurSite, 3] - Vod[CurSite,4]
-- 
--       Vcm[CurSite, 1] = (TxPHMeas[CurSite, 1] + TxPLMeas[CurSite, 1])/2.0   -- SIOA_P
--       Vcm[CurSite, 2] = (TxNHMeas[CurSite, 1] + TxNLMeas[CurSite, 1])/2.0   -- SIOA_N
--       Vcm[CurSite, 3] = (TxPHMeas[CurSite, 2] + TxPLMeas[CurSite, 2])/2.0   -- SIOB_P
--       Vcm[CurSite, 4] = (TxNHMeas[CurSite, 2] + TxNLMeas[CurSite, 2])/2.0   -- SIOB_N
--       VcmDelta[CurSite, 1] = Vcm[CurSite, 1] - Vcm[CurSite, 2]  
--       VcmDelta[CurSite, 2] = Vcm[CurSite, 3] - Vcm[CurSite, 4]  

   endfor

  -- Datalog Tests
    test_value threshold_attenuate_him with GMSL1_rev_HIM_300kHz
    test_value threshold_attenuate with GMSL1_rev_leg_100kHz
  test_value reg_val with GMSL1
end_body

procedure CFG_VIN_MPW5(Vddio, Vdd18, Vdd, TestPins, CFGRegId, Cfgmax0Test, Cfgmax1Test,Cfgmin1Test, Cfgmax2Test,Cfgmin2Test, Cfgmax3Test,Cfgmin3Test, Cfgmax4Test,Cfgmin4Test, Cfgmax5Test,Cfgmin5Test, Cfgmax6Test,Cfgmin6Test, Cfgmax7Test,Cfgmin7Test,Vmax0,Vmax1,Vmin1,Vmax2,Vmin2,Vmax3,Vmin3,Vmax4,Vmin4,Vmax5,Vmin5,Vmax6,Vmin6,Vmin7,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
in float            : Vddio, Vdd18, Vdd
in PIN LIST[5]    : TestPins
in_out float_test : Cfgmax0Test, Cfgmax1Test,Cfgmin1Test, Cfgmax2Test,Cfgmin2Test, Cfgmax3Test,Cfgmin3Test, Cfgmax4Test,Cfgmin4Test, Cfgmax5Test,Cfgmin5Test, Cfgmax6Test,Cfgmin6Test, Cfgmax7Test,Cfgmin7Test
--in_out float_test : Cfgmax9Test,Cfgmin9Test, Cfgmax10Test,Cfgmin10Test, Cfgmax11Test,Cfgmin11Test, Cfgmax12Test,Cfgmin12Test, Cfgmax13Test,Cfgmin13Test, Cfgmax14Test,Cfgmin14Test, Cfgmax15Test,Cfgmin15Test
in float          : Vmax0,Vmax1,Vmin1,Vmax2,Vmin2,Vmax3,Vmin3,Vmax4,Vmin4,Vmax5,Vmin5,Vmax6,Vmin6,Vmin7      ------Vmax7

in word           : CFGRegId
in boolean        : POWERUP,POWERDOWN


-- in_out array of float_test : MbistDone
-- in_out array of float_test : MbistPassFail


local

  
 
  float             : Vconf0, Vconf1,tt,tt1,tt2,tt3
  multisite lword   : lowword, upperword--, des_read0, des_read1, des_read2, reg_val20, reg_val21

  multisite integer : reg_val, reg_val0, reg_val1
  word              : sites, idx, site
  integer           : idxs

  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
 
     multisite float   : Cfgmax0,Cfgmin0, Cfgmax1,Cfgmin1, Cfgmax2,Cfgmin2, Cfgmax3,Cfgmin3, Cfgmax4,Cfgmin4, Cfgmax5,Cfgmin5, Cfgmax6,Cfgmin6, Cfgmax7,Cfgmin7, Cfgmax8,Cfgmin8
    multisite float   : Cfgmax9,Cfgmin9, Cfgmax10,Cfgmin10, Cfgmax11,Cfgmin11, Cfgmax12,Cfgmin12, Cfgmax13,Cfgmin13, Cfgmax14,Cfgmin14, Cfgmax15,Cfgmin15, Cfgmax16,Cfgmin16
    boolean           : CHAR
 end_local


body
--SER_GPO6_CFG2
--SER_GPO4_CFG0  
    get_expr("OpVar_Char", CHAR)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    --make sure RSVD pin float (HVVI disconnect)
--    CHAR = false
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!

-----Dut power up function
    start_timer()
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
    tt = stop_timer
    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)
--    RegRead(SER_ID, 16#06, 1, upperword, lowword,"SER_UART_Read")   

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      reg_val[site]  = integer(lowword[site])        
    end_for 


-----Code from here
 RegRead(SER_ID, 0x0323, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
 
  enable digital ppmu TestPins fv 0V vmax 5V measure i max 2mA
  set digital ppmu TestPins  to fv 0V vmax 5V measure i max 2mA
  disconnect digital pin TestPins  from dcl
  connect digital ppmu TestPins to fv 0V vmax 5V measure i max 2mA
  if CHAR then
--        Cfgmax0 = Cfg1Search(TestPins, 187mV , 255mV , 2mV, CFGRegId,0, "UP") 
       Cfgmax0 = Cfg1Search(TestPins, Vddio*10.0/100.0 ,Vddio*16.9/100.0  , 2mV, CFGRegId,0, "UP") 
--        Cfgmax1 = Cfg1Search(TestPins, 255mV, 340mV , 2mV, CFGRegId,1, "UP") 
        Cfgmax1 = Cfg1Search(TestPins,Vddio*22.0/100.0 , Vddio*28.8/100.0 , 2mV, CFGRegId,1, "UP")    
        Cfgmin1 = Cfg1Search(TestPins,Vddio*18.0/100.0 , Vddio*12.0/100.0 , 2mV, CFGRegId, 1, "DOWN")  

        Cfgmax2 = Cfg1Search(TestPins,Vddio*34.0/100.0 , Vddio*40.0/100.0 , 2mV, CFGRegId,2, "UP")    
        Cfgmin2 = Cfg1Search(TestPins,Vddio*30.0/100.0 , Vddio*24.0/100.0 , 2mV, CFGRegId, 2, "DOWN")  

        Cfgmax3 = Cfg1Search(TestPins, Vddio*46.0/100.0 , Vddio*52.0/100.0 , 2mV, CFGRegId,3, "UP")    
        Cfgmin3 = Cfg1Search(TestPins, Vddio*41.5/100.0 , Vddio*36.0/100.0,  2mV, CFGRegId, 3, "DOWN")  

        Cfgmax4 = Cfg1Search(TestPins, Vddio*58.0/100.0 , Vddio*65.0/100.0 , 2mV,CFGRegId, 4, "UP")    
        Cfgmin4 = Cfg1Search(TestPins, Vddio*54.0/100.0 , Vddio*47.0/100.0 , 2mV,  CFGRegId,4, "DOWN")  

        Cfgmax5 = Cfg1Search(TestPins, Vddio*71.0/100.0 , Vddio*76.0/100.0 , 2mV, CFGRegId,5, "UP")    
        Cfgmin5 = Cfg1Search(TestPins, Vddio*66.0/100.0 , Vddio*59.0/100.0 , 2mV, CFGRegId, 5, "DOWN")  

        Cfgmax6 = Cfg1Search(TestPins, Vddio*82.0/100.0 , Vddio*89.0/100.0 , 2mV,CFGRegId, 6, "UP")    
        Cfgmin6 = Cfg1Search(TestPins, Vddio*78.0/100.0 , Vddio*70.0/100.0 , 2mV,  CFGRegId,6, "DOWN")  

--        Cfgmax7 = Cfg1Search(TestPins, 765mV, 850mV , 2mV,CFGRegId, 7, "UP")    
        Cfgmin7 = Cfg1Search(TestPins, Vddio*90.0/100.0 , Vddio*83.0/100.0 , 2mV, CFGRegId, 7, "DOWN")  

--         Cfgmax8 = Cfg1Search(TestPins, 850mV, 918mV , 2mV,CFGRegId, 8, "UP")    
--         Cfgmin8 = Cfg1Search(TestPins, 850mV, 765mV, 2mV, CFGRegId, 8, "DOWN")  
--         Cfgmax9 = Cfg1Search(TestPins, 918mV, 1V , 2mV,CFGRegId, 9, "UP")    
--         Cfgmin9 = Cfg1Search(TestPins, 918mV, 850mV, 2mV, CFGRegId, 9, "DOWN")  
--         Cfgmax10 = Cfg1Search(TestPins, 1V, 1.1V , 2mV, CFGRegId,10, "UP")    
--         Cfgmin10 = Cfg1Search(TestPins, 1V, 0.9V, 2mV,  CFGRegId,10, "DOWN")  
--         Cfgmax11 = Cfg1Search(TestPins, 1.0881V, 1.2V , 2mV,CFGRegId, 11, "UP")    
--         Cfgmin11 = Cfg1Search(TestPins, 1.088V, 1V, 2mV,CFGRegId, 11, "DOWN")  
--         Cfgmax12 = Cfg1Search(TestPins, 1.173V, 1.26V , 2mV,CFGRegId, 12, "UP")    
--         Cfgmin12 = Cfg1Search(TestPins, 1.173V, 1.088V, 2mV,CFGRegId, 12, "DOWN")  
--         Cfgmax13 = Cfg1Search(TestPins, 1.258V, 1.428 , 2mV, CFGRegId,13, "UP")    
--         Cfgmin13 = Cfg1Search(TestPins, 1.258V, 1.173V, 2mV, CFGRegId,13, "DOWN")  
--         Cfgmax14 = Cfg1Search(TestPins, 1.343V, 1.462V , 2mV,CFGRegId, 14, "UP")    
--         Cfgmin14 = Cfg1Search(TestPins, 1.343V, 1.258V, 2mV, CFGRegId,14, "DOWN")  
--         Cfgmax15 = Cfg1Search(TestPins, 1.428V, 1.6V , 2mV, CFGRegId,15, "UP")    
--         Cfgmin15 = Cfg1Search(TestPins, 1.428V, 1.343V, 2mV,CFGRegId, 15, "DOWN")  
  else

        Cfgmax0 = CfgGoNoGo(TestPins, CFGRegId,Vmax0, 0)
        Cfgmax1 = CfgGoNoGo(TestPins, CFGRegId,Vmax1, 1)
        Cfgmin1 = CfgGoNoGo(TestPins, CFGRegId,Vmin1, 1)
        Cfgmax2 = CfgGoNoGo(TestPins, CFGRegId,Vmax2, 2)
        Cfgmin2 = CfgGoNoGo(TestPins, CFGRegId,Vmin2, 2)
        Cfgmax3 = CfgGoNoGo(TestPins, CFGRegId,Vmax3, 3)
        Cfgmin3 = CfgGoNoGo(TestPins, CFGRegId,Vmin3, 3)
        Cfgmax4 = CfgGoNoGo(TestPins, CFGRegId,Vmax4, 4)
        Cfgmin4 = CfgGoNoGo(TestPins, CFGRegId,Vmin4, 4)
        Cfgmax5 = CfgGoNoGo(TestPins, CFGRegId,Vmax5, 5)
        Cfgmin5 = CfgGoNoGo(TestPins, CFGRegId,Vmin5, 5)
        Cfgmax6 = CfgGoNoGo(TestPins, CFGRegId,Vmax6, 6)
        Cfgmin6 = CfgGoNoGo(TestPins, CFGRegId,Vmin6, 6)
--        Cfgmax7 = CfgGoNoGo(TestPins, CFGRegId,Vmax7-15mV, 7)
        Cfgmin7 = CfgGoNoGo(TestPins, CFGRegId,Vmin7, 7)
    tt1 = stop_timer()
--         Cfgmax8 = CfgGoNoGo(TestPins, CFGRegId,Vmax8-15mV, 8)
--         Cfgmin8 = CfgGoNoGo(TestPins, CFGRegId,Vmin8+15mV, 8)
--         Cfgmax9 = CfgGoNoGo(TestPins, CFGRegId,Vmax9-15mV, 9)
--         Cfgmin9 = CfgGoNoGo(TestPins, CFGRegId,Vmin9+15mV, 9)
--         Cfgmax10 = CfgGoNoGo(TestPins, CFGRegId,Vmax10-15mV, 10)
--         Cfgmin10 = CfgGoNoGo(TestPins, CFGRegId,Vmin10+15mV, 10)
--         Cfgmax11 = CfgGoNoGo(TestPins, CFGRegId,Vmax11-15mV, 11)
--         Cfgmin11 = CfgGoNoGo(TestPins, CFGRegId,Vmin11+15mV, 11)
--         Cfgmax12 = CfgGoNoGo(TestPins, CFGRegId,Vmax12-15mV, 12)
--         Cfgmin12 = CfgGoNoGo(TestPins, CFGRegId,Vmin12+15mV, 12)
--         Cfgmax13 = CfgGoNoGo(TestPins, CFGRegId,Vmax13-15mV, 13)
--         Cfgmin13 = CfgGoNoGo(TestPins, CFGRegId,Vmin13+15mV, 13)
--         Cfgmax14 = CfgGoNoGo(TestPins, CFGRegId,Vmax14-15mV, 14)
--         Cfgmin14 = CfgGoNoGo(TestPins, CFGRegId,Vmin14+15mV, 14)
--         Cfgmax15 = CfgGoNoGo(TestPins, CFGRegId,Vmax15-15mV, 15)
--         Cfgmin15 = CfgGoNoGo(TestPins, CFGRegId,Vmin15+15mV, 15)  


  end_if
 ---------------------------------------------

-------------- Power Down ---------------------------
   disconnect digital pin TestPins  from ppmu
   connect digital pin TestPins  to dcl
      powerdown_device(POWERDOWN)  

    tt2 = stop_timer()
   -- Datalog Results   
      test_value Cfgmax0 with Cfgmax0Test  
      test_value Cfgmin1 with Cfgmin1Test
      test_value Cfgmax1 with Cfgmax1Test  
      test_value Cfgmin2 with Cfgmin2Test
      test_value Cfgmax2 with Cfgmax2Test  
      test_value Cfgmin3 with Cfgmin3Test
      test_value Cfgmax3 with Cfgmax3Test
      test_value Cfgmin4 with Cfgmin4Test
      test_value Cfgmax4 with Cfgmax4Test
      test_value Cfgmin5 with Cfgmin5Test
      test_value Cfgmax5 with Cfgmax5Test
      test_value Cfgmin6 with Cfgmin6Test
      test_value Cfgmax6 with Cfgmax6Test
      test_value Cfgmin7 with Cfgmin7Test
--       test_value Cfgmax7 with Cfgmax7Test
--       test_value Cfgmin8 with Cfgmin8Test
--       test_value Cfgmax8 with Cfgmax8Test
--       test_value Cfgmin9 with Cfgmin9Test
--       test_value Cfgmax9 with Cfgmax9Test
--       test_value Cfgmin10 with Cfgmin10Test
--       test_value Cfgmax10 with Cfgmax10Test
--       test_value Cfgmin11 with Cfgmin11Test
--       test_value Cfgmax11 with Cfgmax11Test
--       test_value Cfgmin12 with Cfgmin12Test
--       test_value Cfgmax12 with Cfgmax12Test
--       test_value Cfgmin13 with Cfgmin13Test
--       test_value Cfgmax13 with Cfgmax13Test
--       test_value Cfgmin14 with Cfgmin14Test
--       test_value Cfgmax14 with Cfgmax14Test
--       test_value Cfgmin15 with Cfgmin15Test
--       test_value Cfgmax15 with Cfgmax15Test 

    tt3 = stop_timer()
 end_body


procedure GMSL1OutputResistance(Vdd, Vdd18, Vddio,Res_GMSL_P,Res_GMSL_N,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
--  
in float                : Vdd, Vdd18, Vddio
in_out float_test : Res_GMSL_P,Res_GMSL_N
in boolean              : POWERUP,POWERDOWN

local
    word              : site, siteidx, idx, sites_local, csite, stn
    multisite float   : i_slp1,i_sln1, i_slp2,i_sln2, res_p, res_n
end_local

body
    active_sites = get_active_sites()
    sites = word(len(active_sites))


--    set digital pin SER_GPO4_CFG0  + SER_GPO6_CFG2 levels to vil Vconf0 vih Vddio   -- TP/UART mode with DEV_ID = 0x80
--    set digital pin  SER_GPO5_CFG1 levels to vil Vconf1 vih Vddio                    ---GMSL2 mode  AND COAX
--   close hcovi DC_K7 cbits
    close cbit COAXB_P_RELAY + COAXB_M_RELAY  ---Connecto DC circuit
    wait(1ms)

----Dut power up function
--   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL1",POWERUP) ---Set link to GMSL1
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "COAX_GMSL1",POWERUP) ---Set link to GMSL1 
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!

   disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from dcl
-----debug in what mode    
    RegRead(SER_ID,SR_REG6 , 1, RdWordUpper, RdWordLower, "SER_UART_Read")-----GMSL1 then read back = 0xb and GMSL2 then 0x8b

--  Set TX amplitude field = 0x00. 
  RegWrite(SER_ID, SR_RLMS95_A, 1, 0, 0xC0, "SER_UART_Write")
  RegWrite(SER_ID, SR_RLMS95_B, 1, 0, 0xC0, "SER_UART_Write")
--  Set TX PreDrvAmplMan field = 0x30
  RegWrite(SER_ID, SR_RLMS94_A, 1, 0, 0x70, "SER_UART_Write")  ---70
  RegWrite(SER_ID, SR_RLMS94_B, 1, 0, 0x70, "SER_UART_Write")---70

    set vi16 chan DC_SE_M_A_VI + DC_SE_P_A_VI to fv Vdd18-0.2 measure i max 5ma clamp imax 5ma imin -5ma
    gate vi16 chan  DC_SE_M_A_VI + DC_SE_P_A_VI on
    connect vi16 chan DC_SE_M_A_VI + DC_SE_P_A_VI remote hot switch
    wait(1ms)
    measure vi16 i on chan DC_SE_P_A_VI for 20 samples every 10us averaged into i_slp1
    measure vi16 i on chan  DC_SE_M_A_VI for 20 samples every 10us averaged into i_sln1


    set vi16 chan DC_SE_M_A_VI + DC_SE_P_A_VI to fv Vdd18 -0.3 measure i max 5ma clamp imax 5ma imin -5ma
    wait(1ms)
    
    measure vi16 i on chan DC_SE_P_A_VI for 20 samples every 10us averaged into i_slp2
    measure vi16 i on chan DC_SE_M_A_VI for 20 samples every 10us averaged into i_sln2
    
    res_p = 0.1/(i_slp1-i_slp2)
    res_n = 0.1/(i_sln1-i_sln2)
---------power down 
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
  wait(500us)

  open cbit COAXB_P_RELAY + COAXB_M_RELAY
  connect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP to dcl
 

      powerdown_device(POWERDOWN)
    
     -- Datalog Tests
    test_value res_p with Res_GMSL_P
    test_value res_n with Res_GMSL_N



end_body

procedure IsupplyMipi_DualView(Vdd, Vddio, Vdd18, ser_lock_it, des_lock_it,POWERUP,POWERDOWN,TP_COAX,TX_SPD,RX_SPD,MIPI_SPD,CSI_MODE,NUMB_LANES,Link_Lock_dly,FW_SPD,RW_SPD,CSI_SPD,NUMBER_LANES,VddioI,Vdd18I,VddI)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in_out integer_test : ser_lock_it, des_lock_it,NUMBER_LANES
in boolean          : POWERUP,POWERDOWN
in string[20]       : TP_COAX,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,MIPI_SPD,Link_Lock_dly
in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,RW_SPD,CSI_SPD
in_out float_test   : VddioI,Vdd18I,VddI

local



  multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

 multisite lword    : RLMSA3_A,RLMSA3_B, RLMSA2_A,RLMSA2_B, RLM89_A,RLM89_B, RLM88_A, RLM88_B, RLM8A_A,RLM8A_B
 multisite lword    : DES_RLMSA3_A, DES_RLMSA3_B, DES_RLMSA2_A,DES_RLMSA2_B, DES_RLM89_A,DES_RLM89_B, DES_RLM88_A, DES_RLM88_B, DES_RLM8A_A,DES_RLM8A_B

 multisite lword    : RLMSC_A,RLMSC_B, RLMSD_A,RLMSD_B, RLMSE_A,RLMSE_B, RLMSF_A,RLMSF_B, RLMS10_A,RLMS10_B, RLMS11_A,RLMS11_B, RLMS13_A,RLMS13_B, RLMS2E_A,RLMS2E_B
 multisite lword    : DES_RLMSC_A,DES_RLMSC_B, DES_RLMSD_A,DES_RLMSD_B, DES_RLMSE_A,DES_RLMSE_B, DES_RLMSF_A,DES_RLMSF_B, DES_RLMS10_A,DES_RLMS10_B, DES_RLMS11_A,DES_RLMS11_B,DES_RLMS13_A,DES_RLMS13_B, DES_RLMS2E_A,DES_RLMS2E_B
 multisite lword    :  array1[26], array2[26]
    string[20]      :  infile[4],tempp, MPW
    multisite float : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1]



end_local


body
  
    MPW = "MPW5"
    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)

    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val[site]  = integer(lowword[site]) 
    end_for 
 
---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY

--  CRYSTAL running now, we should have LOCK on DES site???
--  Answer is NO on rev1 device (bug), but should be fixed on rev2 device  
    
    hizdel_reg_val = fpga_read_register("FPGA1", HIZDEL_REG)       -- should read back decimal 6000 if FPGA working OK
    wait(0ms)
    
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(1ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
    powerup_dnut_vdd_vterm(1.2,1.2)
    wait(1ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
    fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
    wait(5ms)

    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg
    wait(0ms)
      
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read    


    wait(200us)
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val0[site]  = integer(reg_val0[site]) 
    end_for     
    
 ---------close CSI feedback loop
    close cbit  FB_RELAY

----Set SER and DES for coax or tp mode
    if TP_COAX = "TP" then
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
    else
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
    end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

       if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
       elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

      if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
      elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
      elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
     end_if 
    ser_link_speed_code = ser_rx_speed + ser_tx_speed
    des_link_speed_code = des_rx_speed + des_tx_speed
-----TP only work up to 3GHz
    if TP_COAX = "TP" and TX_SPD >3GHz then
        
        ----put print statement on screen to notify engineer ---- do this later
        ser_link_speed_code   = 0   ---fail part
        des_link_speed_code   = 0
    end_if 
----Program link rate

    RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed

    wait(10ms)


-----Write to reg10 to update link speed setting 
    wait(10ms)
    -- write Reg0x10 to update to COAX mode
    RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#30, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89
    wait(1ms)        
    RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)
-----No need to repeat at DES
--     fpga_UART_Write("FPGA1","DES", DESA_ID, 16#10, 1, 0x30)
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x10, 1)      -- self adjust back to 0x01
--     wait(0ms)
     
--------------Check for lock, error bit
----Currently, HS89 rev 1.5G error bit always on.
----at fwd_speed = 6.0G, REV_SPEED = 0.75 then no error.
----at fwd_speed = 3.0G, REV_SPEED = 0.375 then no error.
---------------------------------------------------------------------------------------------------------------------------------------------

   wait(Link_Lock_dly-50ms)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
--   wait(50mS)
   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   

   wait(0ms)
    if reg_val15[2] <> 0xCA then
        wait(400mS)
        RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
        reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
        wait(0ms)       
        wait(400mS) 
        RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
        reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
        wait(0ms)   

    end_if     


  for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val1[site]  = integer(lowword[site])
      ireg_val15[site] = integer(reg_val15[site])      
   end_for    


 
 ----Setup Dual View spliter mode
    RegRead(SER_ID, SR_REG15 , 1, upperword, lowword,"SER_UART_Read")
    
    RegWrite( SER_ID, SR_DV0_A, 1,0x00, 0x07, "SER_UART_Write")                -----DualView spliter mode
    
--     RegRead(SER_ID, SR_DV0_A , 1, upperword, lowword,"SER_UART_Read")
 
   -------------------------DO NOT DELETE, DEBUGGING-------------------------
   -- try to read across the link to SER from DNUT using FPGA, FPGA timeout for read back is hardcode to 128uS
   des_read =  fpga_UART_Read("FPGA1", "DES", SER_ID, 0x00, 1)      -- SER_ID read from DNUT UART mode, expect 0x80
   wait(0ms)
 
----------Now let do loopback test
  -- setup SER/DES for loopback test here
   
  --RegWrite(DevId, RegAddr, ByteCnt, DataUpperWord, DataLowerWord, PatternName)
------MIPI loopback  parameters and error setting for SER

   RegWrite( SER_ID, SR_REG2, 1,0x00, 0x63, "SER_UART_Write")                                             ----Enable video Z and Y
   RegWrite( SER_ID, SR_FRONTTOP_0, 1,0x00, 0x7C, "SER_UART_Write")                                        ----Setup CSI port A used only and pipe lines X,Y,Z,U0 reg =0x308
   RegWrite( SER_ID, SR_FRONTTOP_9 , 1,0x00, 0x42, "SER_UART_Write")                                       ----Setup pipeline Y for portA

  RegWrite(SER_ID, SR_MIPI_LPB0 , 1, 16#00, 16#08, "SER_UART_Write")                                      -- 16#0370    PRBS patterns ????
  RegWrite(SER_ID, SR_MIPI_LPB1, 1, 16#00, 16#02, "SER_UART_Write")                                       --  16#0371   2 lines per frame for loop back test

------Test bench does not have LSB
  RegWrite(SER_ID, SR_MIPI_LPB2, 1, 16#00, 16#02, "SER_UART_Write")                                       -- 16#0372    Pixel count lsb byte for MIPI loop back test current set to 2?
  RegWrite(SER_ID, SR_MIPI_LPB3, 1, 16#00, 16#02, "SER_UART_Write")                                       -- 16#0373    Pixel count Msb byte for MIPI loop back test current set to 2?

  
 ------- Set MIPI_RX registers number of lanes 2x4 mode
  number_of_lane = (NUMB_LANES -1) | ((NUMB_LANES -1) <<4)                                                 ----- Convert number of lanes from pass parameter to code for writing into reg 
  des_numb_lane = (NUMB_LANES -1) | ((NUMB_LANES -1) <<6)
--  des_numb_lane = ((NUMB_LANES -1) <<6)
   if (CSI_MODE = "2X4") or (CSI_MODE = "2x4") then   
        ser_csi_mode = 0x06                                                                              ------2x4 mode   
    elseif (CSI_MODE = "2X4") or( CSI_MODE = "2x4") then
        des_csi_mode = 0x03                                                                             ------2x2 mode
    end_if  
  -----Here for tomorrow
  RegWrite(SER_ID, SR_MIPI_RX0, 1, 16#00, 16#86, "SER_UART_Write")                                       ------ 16#0330   1x4 port A enable
  RegWrite(SER_ID, SR_MIPI_RX1, 1, 16#00, number_of_lane, "SER_UART_Write")                              ------ 16#0331      lanes for cntrl0 and cntrl1 Use this reg to changing number of lane
  RegWrite(SER_ID, SR_MIPI_RX2, 1, 16#00, 16#4E, "SER_UART_Write")                                       ------- 16#0332    Phy1/phy0 lane map 
  RegWrite(SER_ID, SR_MIPI_RX3, 1, 16#00, 16#E4, "SER_UART_Write")                                       ------- 16#0333    Phy2/phy3 lane map 

---------------------Now setup DES------
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_RX0_1, 1, 16#01)                                          ------- 16#51  Receive packet with Select stream ID
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_RX0_2, 1, 16#02)                                          ------- 16#52  Receive packet with Select stream ID

----# Turn off unused phys (disable phy 2/3)		
--   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY2, 1, 16#60)                                      ------- 16#332  turn off phy2 and phy3 ???? may be for HS78 viet's product because it has only 1 port 2x4
                                                                                                         ---For HS89 no need    
---# CSI configuration
   if (CSI_MODE = "2X4") or (CSI_MODE = "2x4") then   
        des_csi_mode = 0x04                                                                              ------2x4 mode   
    elseif (CSI_MODE = "1X4") or( CSI_MODE = "1x4") then
        des_csi_mode = 0x02                                                                             ------1x4 mode
    end_if
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY0, 1,des_csi_mode )                               ------- 16#330  PORT CONFIG 2X4,1X4... and forced CSI clock

----### number of CSI lanes mapping

   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY3, 1,0x4E )                               ------- 16#333  Lane map
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY4, 1,0xE4 )                               ------- 16#334  lane map
   
----### number of CSI lanes 

   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX10_44A, 1,des_numb_lane )                               ------- 16#44A  number of lane CNTL1
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX10_48A, 1,des_numb_lane )                               ------- 16#44A  number of lane CNTL2


----### CSI clk speed 
    mipi_speed = lword(MIPI_SPD / 100.0e6)| 0x20
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP25, 1, mipi_speed)                                ------- 16#320  CSI speed
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP28, 1, mipi_speed)                                ------- 16#323  CSI speed

----### enable CSI clk

   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY0, 1, (des_csi_mode | 0x80))                               ------- 16#330  PORT CONFIG 2X4,1X4... and forced CSI clock 
 
--     RegRead(SER_ID,16#10A , 1, upperword, lowword,"SER_UART_Read")    --       
--     RegRead(SER_ID, 16#112, 1, upperword, lowword,"SER_UART_Read")    --   
--     RegRead(SER_ID,16#102 , 1, upperword, lowword,"SER_UART_Read")    --       
--     RegRead(SER_ID,16#11A , 1, upperword, lowword,"SER_UART_Read")    --
    wait(0)
 ------######loop back test-----

--    if MPW = "MPW4" then
--         RegWrite(SER_ID, SR_MIPI_LPB0 , 1, 16#00, 16#0F, "SER_UART_Write")                                      -- 16#0370    select bad pattern
--    else
--         RegWrite(SER_ID, SR_MIPI_LPB0 , 1, 16#00, 16#6F, "SER_UART_Write")                                      -- 16#0370    select bad pattern
--    end_if
--    wait(100ms)
-- --  RegRead(SER_ID, 16#0370, 1, upperword, lowword,"SER_UART_Read")                                         -- verify write above
--   --wait(0ms)
--  
--   RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, lowword,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
--   wait(200us)
--   
--     for idxs = 1 to len(active_sites) do
--       site = active_sites[idxs]
--       ireg_val_ser_bad[site]  = integer(lowword[site])    
--     end_for 
    if MPW = "MPW4" then
        RegWrite(SER_ID,SR_MIPI_LPB0 , 1, 16#00, 16#0B, "SER_UART_Write")
    else
        RegWrite(SER_ID,SR_MIPI_LPB0 , 1, 16#00, 16#6B, "SER_UART_Write")                                       -- select GOOD pattern  (PRBS)
    end_if
  wait(100ms) 
    
  RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, lowword,"SER_UART_Read")                                       --16#0374 should see NO BIT high, meaning PASS THE TEST   
  wait(200us)   

------------Measure current
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas



    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val_ser_good[site]  = integer(lowword[site])
    end_for 
RegRead(SER_ID, 0x112 , 1, upperword, lowword,"SER_UART_Read") 
  
 --  for idx=1 to sites do
--        site = current_active_sites[idx]
--        if (ireg_val_ser_bad[site] >15) AND (ireg_val_ser_good[site] < 1) then 
--            LBDONE[site] = 1
--        else
--            LBDONE[site] = 0
--        endif
--   endfor  
      

   -- turn off MIPI clocks from DES
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)            
   -- reg_val23  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)
   -- loop back relays on LB opened
--   fpga_cbit_control("FPGA1", 2#0000)      -- control FPGA cbits 2#0000  (cb4, cb3, cb2, cb1)   
     open cbit CB2_SLDC                 --OVI_RELAYS 
     open cbit COAXB_M_RELAY            --OVI_RELAYS
     open cbit  FB_RELAY
-------------- Power Down ---------------------------


 -- set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
  --set  digital  pin ALL_PATTERN_PINS fx1 driver  preset low       

    if (POWERDOWN) then
           set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
           powerdown_device(POWERDOWN)
      end_if 

 

    open cbit  FB_RELAY
    open cbit  DNUT_RXTX_RELAY

    test_value ireg_val1 with ser_lock_it
    test_value ireg_val15 with des_lock_it        

    test_value TX_SPD with FW_SPD     
    test_value RX_SPD with RW_SPD  
    test_value MIPI_SPD with CSI_SPD
    test_value number_of_lanes_test with NUMBER_LANES
    
    test_value i_vddio_meas with VddioI  
    test_value i_vdd18_meas with Vdd18I
    test_value i_vdd_meas with VddI
 end_body




procedure IsupplyMipi_1X4(Vdd, Vddio, Vdd18, ser_lock_it, des_lock_it,POWERUP,POWERDOWN,TP_COAX,TX_SPD,RX_SPD,MIPI_SPD,CSI_MODE,NUMB_LANES,Link_Lock_dly,FW_SPD,RW_SPD,CSI_SPD,NUMBER_LANES,VddioI,Vdd18I,VddI)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in_out integer_test : ser_lock_it, des_lock_it,NUMBER_LANES
in boolean          : POWERUP,POWERDOWN
in string[20]       : TP_COAX,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,MIPI_SPD,Link_Lock_dly
in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,RW_SPD,CSI_SPD
in_out float_test   : VddioI,Vdd18I,VddI

local



  multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

 multisite lword    : RLMSA3_A,RLMSA3_B, RLMSA2_A,RLMSA2_B, RLM89_A,RLM89_B, RLM88_A, RLM88_B, RLM8A_A,RLM8A_B
 multisite lword    : DES_RLMSA3_A, DES_RLMSA3_B, DES_RLMSA2_A,DES_RLMSA2_B, DES_RLM89_A,DES_RLM89_B, DES_RLM88_A, DES_RLM88_B, DES_RLM8A_A,DES_RLM8A_B

 multisite lword    : RLMSC_A,RLMSC_B, RLMSD_A,RLMSD_B, RLMSE_A,RLMSE_B, RLMSF_A,RLMSF_B, RLMS10_A,RLMS10_B, RLMS11_A,RLMS11_B, RLMS13_A,RLMS13_B, RLMS2E_A,RLMS2E_B
 multisite lword    : DES_RLMSC_A,DES_RLMSC_B, DES_RLMSD_A,DES_RLMSD_B, DES_RLMSE_A,DES_RLMSE_B, DES_RLMSF_A,DES_RLMSF_B, DES_RLMS10_A,DES_RLMS10_B, DES_RLMS11_A,DES_RLMS11_B,DES_RLMS13_A,DES_RLMS13_B, DES_RLMS2E_A,DES_RLMS2E_B
 multisite lword    :  array1[26], array2[26]
    string[20]      :  infile[4],tempp, MPW
    multisite float                             : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1]



end_local


body
  
    MPW = "MPW5"
    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)

    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val[site]  = integer(lowword[site]) 
    end_for 
 
---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY

--  CRYSTAL running now, we should have LOCK on DES site???
--  Answer is NO on rev1 device (bug), but should be fixed on rev2 device  
    
    hizdel_reg_val = fpga_read_register("FPGA1", HIZDEL_REG)       -- should read back decimal 6000 if FPGA working OK
    wait(0ms)
    
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(0ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
    powerup_dnut_vdd_vterm(1.2,1.2)
--   wait(6ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
    fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
    wait(1ms)
    
    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg
    wait(0ms)
      
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read    
    wait(200us)
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val0[site]  = integer(reg_val0[site]) 
    end_for     
    
 ---------close CSI feedback loop
    close cbit  FB_RELAY

----Set SER and DES for coax or tp mode
    if TP_COAX = "TP" then
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
    else
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
    end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

       if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
       elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

      if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
      elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
      elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
     end_if 
    ser_link_speed_code = ser_rx_speed + ser_tx_speed
    des_link_speed_code = des_rx_speed + des_tx_speed
-----TP only work up to 3GHz
    if TP_COAX = "TP" and TX_SPD >3GHz then
        
        ----put print statement on screen to notify engineer ---- do this later
        ser_link_speed_code   = 0   ---fail part
        des_link_speed_code   = 0
    end_if 
----Program link rate

    RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed



wait(20ms)
-----Write to reg10 to update link speed setting 
    
    -- write Reg0x10 to update to COAX mode
    RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#30, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89
    wait(1ms)        
    RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)
-----No need to repeat at DES
--     fpga_UART_Write("FPGA1","DES", DESA_ID, 16#10, 1, 0x30)
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x10, 1)      -- self adjust back to 0x01
--     wait(0ms)
     
--------------Check for lock, error bit
----Currently, HS89 rev 1.5G error bit always on.
----at fwd_speed = 6.0G, REV_SPEED = 0.75 then no error.
----at fwd_speed = 3.0G, REV_SPEED = 0.375 then no error.
---------------------------------------------------------------------------------------------------------------------------------------------

   wait(Link_Lock_dly + 100ms)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!

   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
   wait(0ms)
    if reg_val15[2] <> 0xCA then  ----- Need work on afer correlation 
        wait(400mS)
        RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
        reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
        wait(0ms)       
        wait(400mS)
        RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
        reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
        wait(0ms)       

    end_if     



  for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val1[site]  = integer(lowword[site])
      ireg_val15[site] = integer(reg_val15[site])      
   end_for    


 
 ----Setup Dual View spliter mode
    RegRead(SER_ID, SR_REG15 , 1, upperword, lowword,"SER_UART_Read")
---No Dual View    
--    RegWrite( SER_ID, SR_DV0_A, 1,0x00, 0x07, "SER_UART_Write")                -----DualView spliter mode
    
--     RegRead(SER_ID, SR_DV0_A , 1, upperword, lowword,"SER_UART_Read")
 
   -------------------------DO NOT DELETE, DEBUGGING-------------------------
   -- try to read across the link to SER from DNUT using FPGA, FPGA timeout for read back is hardcode to 128uS
   des_read =  fpga_UART_Read("FPGA1", "DES", SER_ID, 0x00, 1)      -- SER_ID read from DNUT UART mode, expect 0x80
   wait(0ms)
 
----------Now let do loopback test
  -- setup SER/DES for loopback test here
   
  --RegWrite(DevId, RegAddr, ByteCnt, DataUpperWord, DataLowerWord, PatternName)
------MIPI loopback  parameters and error setting for SER

   RegWrite( SER_ID, SR_REG2, 1,0x00, 0x63, "SER_UART_Write")                                             ----Enable video Z and Y
   RegWrite( SER_ID, SR_FRONTTOP_0, 1,0x00, 0x6C, "SER_UART_Write")                                        ----Setup CSI port B used only and pipe lines X,Y,Z,U0 reg =0x308
   RegWrite( SER_ID, SR_FRONTTOP_9 , 1,0x00, 0x42, "SER_UART_Write")                                       ----Setup pipeline Y for portA

  RegWrite(SER_ID, SR_MIPI_LPB0 , 1, 16#00, 16#08, "SER_UART_Write")                                      -- 16#0370    PRBS patterns ????
  RegWrite(SER_ID, SR_MIPI_LPB1, 1, 16#00, 16#02, "SER_UART_Write")                                       --  16#0371   2 lines per frame for loop back test

------Test bench does not have LSB
  RegWrite(SER_ID, SR_MIPI_LPB2, 1, 16#00, 16#02, "SER_UART_Write")                                       -- 16#0372    Pixel count lsb byte for MIPI loop back test current set to 2?
  RegWrite(SER_ID, SR_MIPI_LPB3, 1, 16#00, 16#02, "SER_UART_Write")                                       -- 16#0373    Pixel count Msb byte for MIPI loop back test current set to 2?

  
 ------- Set MIPI_RX registers number of lanes 2x4 mode
  number_of_lane = (NUMB_LANES -1) | ((NUMB_LANES -1) <<4)                                                 ----- Convert number of lanes from pass parameter to code for writing into reg 
  des_numb_lane = (NUMB_LANES -1) | ((NUMB_LANES -1) <<6)
--  des_numb_lane = ((NUMB_LANES -1) <<6)
   if (CSI_MODE = "2X4") or (CSI_MODE = "2x4") then   
        ser_csi_mode = 0x06                                                                              ------2x4 mode   
    elseif (CSI_MODE = "2X4") or( CSI_MODE = "2x4") then
        des_csi_mode = 0x03                                                                             ------2x2 mode
    end_if  
  -----Here for tomorrow
  RegWrite(SER_ID, SR_MIPI_RX0, 1, 16#00, 16#85, "SER_UART_Write")                                       ------ 16#0330   1x4 port B enable
  RegWrite(SER_ID, SR_MIPI_RX1, 1, 16#00, number_of_lane, "SER_UART_Write")                              ------ 16#0331      lanes for cntrl0 and cntrl1 Use this reg to changing number of lane
  RegWrite(SER_ID, SR_MIPI_RX2, 1, 16#00, 16#4E, "SER_UART_Write")                                       ------- 16#0332    Phy1/phy0 lane map 
  RegWrite(SER_ID, SR_MIPI_RX3, 1, 16#00, 16#E4, "SER_UART_Write")                                       ------- 16#0333    Phy2/phy3 lane map 

---------------------Now setup DES------
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_RX0_1, 1, 16#01)                                          ------- 16#51  Receive packet with Select stream ID
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_RX0_2, 1, 16#02)                                          ------- 16#52  Receive packet with Select stream ID

----# Turn off unused phys (disable phy 2/3)		
--   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY2, 1, 16#60)                                      ------- 16#332  turn off phy2 and phy3 ???? may be for HS78 viet's product because it has only 1 port 2x4
                                                                                                         ---For HS89 no need    
---# CSI configuration
   if (CSI_MODE = "2X4") or (CSI_MODE = "2x4") then   
        des_csi_mode = 0x04                                                                              ------2x4 mode   
    elseif (CSI_MODE = "1X4") or( CSI_MODE = "1x4") then
        des_csi_mode = 0x02                                                                             ------1x4 mode
    end_if
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY0, 1,des_csi_mode )                               ------- 16#330  PORT CONFIG 2X4,1X4... and forced CSI clock

----### number of CSI lanes mapping

   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY3, 1,0x4E )                               ------- 16#333  Lane map
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY4, 1,0xE4 )                               ------- 16#334  lane map
   
----### number of CSI lanes 

   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX10_44A, 1,des_numb_lane )                               ------- 16#44A  number of lane CNTL1
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX10_48A, 1,des_numb_lane )                               ------- 16#44A  number of lane CNTL2


----### CSI clk speed 
    mipi_speed = lword(MIPI_SPD / 100.0e6)| 0x20
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP25, 1, mipi_speed)                                ------- 16#320  CSI speed
   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP28, 1, mipi_speed)                                ------- 16#323  CSI speed

----### enable CSI clk

   fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY0, 1, (des_csi_mode | 0x80))                               ------- 16#330  PORT CONFIG 2X4,1X4... and forced CSI clock 
 
--     RegRead(SER_ID,16#10A , 1, upperword, lowword,"SER_UART_Read")    --       
--     RegRead(SER_ID, 16#112, 1, upperword, lowword,"SER_UART_Read")    --   
--     RegRead(SER_ID,16#102 , 1, upperword, lowword,"SER_UART_Read")    --       
--     RegRead(SER_ID,16#11A , 1, upperword, lowword,"SER_UART_Read")    --
    wait(0)
 ------######loop back test-----

--    if MPW = "MPW4" then
--         RegWrite(SER_ID, SR_MIPI_LPB0 , 1, 16#00, 16#0F, "SER_UART_Write")                                      -- 16#0370    select bad pattern
--    else
--         RegWrite(SER_ID, SR_MIPI_LPB0 , 1, 16#00, 16#6F, "SER_UART_Write")                                      -- 16#0370    select bad pattern
--    end_if
--    wait(100ms)
-- --  RegRead(SER_ID, 16#0370, 1, upperword, lowword,"SER_UART_Read")                                         -- verify write above
--   --wait(0ms)
--  
--   RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, lowword,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
--   wait(200us)
--   
--     for idxs = 1 to len(active_sites) do
--       site = active_sites[idxs]
--       ireg_val_ser_bad[site]  = integer(lowword[site])    
--     end_for 
    if MPW = "MPW4" then
        RegWrite(SER_ID,SR_MIPI_LPB0 , 1, 16#00, 16#0B, "SER_UART_Write")
    else
        RegWrite(SER_ID,SR_MIPI_LPB0 , 1, 16#00, 16#6B, "SER_UART_Write")                                       -- select GOOD pattern  (PRBS)
    end_if
  wait(100ms) 
    
  RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, lowword,"SER_UART_Read")                                       --16#0374 should see NO BIT high, meaning PASS THE TEST   
  wait(200us)   
   set hcovi SER_VDDIO to fv Vddio   vmax 4V measure i max 600uA  clamp imax 600uA imin -600uA
    wait(1ms)
------------Measure current
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas



    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val_ser_good[site]  = integer(lowword[site])
    end_for 
RegRead(SER_ID, 0x112 , 1, upperword, lowword,"SER_UART_Read") 
 wait(0) 
 --  for idx=1 to sites do
--        site = current_active_sites[idx]
--        if (ireg_val_ser_bad[site] >15) AND (ireg_val_ser_good[site] < 1) then 
--            LBDONE[site] = 1
--        else
--            LBDONE[site] = 0
--        endif
--   endfor  
      

   -- turn off MIPI clocks from DES
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)            
   -- reg_val23  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)
   -- loop back relays on LB opened
--   fpga_cbit_control("FPGA1", 2#0000)      -- control FPGA cbits 2#0000  (cb4, cb3, cb2, cb1)   
     open cbit CB2_SLDC                 --OVI_RELAYS 
     open cbit COAXB_M_RELAY            --OVI_RELAYS
     open cbit  FB_RELAY
-------------- Power Down ---------------------------
  set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V 
  --set  digital  pin ALL_PATTERN_PINS fx1 driver  preset low       
  wait(500us)
     if (POWERDOWN) then
--         fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)
--                 powerup_dnut_vdd_vterm(0.0,0.0) 
--         wait(50mS)
      end_if  
        powerdown_device(POWERDOWN)

 open cbit  FB_RELAY
 open cbit  DNUT_RXTX_RELAY
    wait(10ms)
    test_value ireg_val1 with ser_lock_it
    test_value ireg_val15 with des_lock_it        

    test_value TX_SPD with FW_SPD     
    test_value RX_SPD with RW_SPD  
    test_value MIPI_SPD with CSI_SPD
    test_value number_of_lanes_test with NUMBER_LANES
    
    test_value i_vddio_meas with VddioI  
    test_value i_vdd18_meas with Vdd18I
    test_value i_vdd_meas with VddI
 end_body





procedure HS89_CSI_Leakage(Vdd,Vddio,Vdd18,CSI_HI_LEAKAGE,CSI_LOW_LEAKAGE,CSI_HI_LEAKAGE_PWDNLO,CSI_LOW_LEAKAGE_PWDNLO,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
--  
in float            : Vdd,Vddio,Vdd18
in boolean          : POWERUP,POWERDOWN
in_out float_test   :CSI_HI_LEAKAGE,CSI_LOW_LEAKAGE,CSI_HI_LEAKAGE_PWDNLO,CSI_LOW_LEAKAGE_PWDNLO

local

multisite float     :leak_csi_hi[20],leak_csi_low[20],leak_csi_hi_pwdnlow[20],leak_csi_low_pwdnlow[20]
word    : site , idx, sites
multisite lword     : reg_val
multisite lword   : lowword, upperword

end_local

body

        active_sites = get_active_sites
        sites = word(len(active_sites))  

    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
    disconnect digital pin SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS  from dcl delay 100us
    set ppmu SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS to fv 0.0V measure i max 1.2V clamps to imin 10uA imax 10ua
    connect digital pin  SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS   to ppmu                

    connect digital pin  ALL_PATTERN_PINS    to dcl delay 100us

    set digital pin ALL_PATTERN_PINS - fpga_pattern_pins levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0.0V  ---deglitch

    wait(1ms)


    DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)------------- DutPowerUp(vio, v18, vcore, "UART", "TP_GMSL1",POWERUP)
    set ppmu SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS to fv 1.3V measure i max 1.2V clamps to imin 10uA imax 10ua
    connect digital pin  SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS   to ppmu                
    wait(1ms)    

  
--    connect digital pin  SER_PWDNB    to dcl delay 100us

--   -------- Set PWDN =1 to power up DUT --------
--         execute digital pattern "PowerUp" at label "TP" run to end wait
--         wait(6ms) 

-----#######------Turn off High speed mode; disable 100 ohm differential resistance------\\\\\\
------\\\\\\ Otherwise, once in awhile, have high leakage current at MIPI due to differential res on \\\\\\\MT
------/////// Seen it in mini char--------------------

--     RegRead(SER_ID, SR_MIPI_RX0, 1, upperword, lowword,"SER_UART_Read")   ---- For debug what value to program to register 0x330  MIPI_RX_0

    RegWrite( SER_ID, SR_MIPI_RX0, 1,0x00, 0x0C, "SER_UART_Write")           ------Turn off High speed mode; disable 100 ohm differential resistance otherwise 
    wait(1ms)    

------=========================================================================

----Measure leakage on CSI pin with power down high
    force_instr(SER_CSI_EVEN_PINS  +  SER_CSI_ODD_PINS,   "PPMU", "VOLTAGE" , 1.35V, 10uA,  -10uA,   10uA)
    wait(20us)
    meas_instr(leak_csi_hi, SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS,  "PPMU", "CURRENT", 2uA,  10, 100us)

-- ------Check for measure high value for debug
--     for i = 1 to 20 do 
--         if leak_csi_hi[2,i] > 1.99ua or leak_csi_hi[2,i] < -0.99ua then
--             wait(0)
--         end_if
--     end_for 

--    force_instr(SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS,   "PPMU", "VOLTAGE" , 1V, 200uA,  -200uA,   200uA)
-----*#######-Very important--###############---------------------------------------------------------------
---- ----Bring CSI Neg to zero first before Pos pins to avoid turn on 100ohm-----
----------Ser_CSI_EVEN_PINS are Neg pins
-------*#######-*#######-*#######-=========================================================

    force_instr(  SER_CSI_ODD_PINS + SER_CSI_EVEN_PINS  ,   "PPMU", "VOLTAGE" , -0.05V, 10uA,  -10uA,   10uA) 
    wait(100us)
--    force_instr( SER_CSI_ODD_PINS,   "PPMU", "VOLTAGE" , -0.05V, 10uA,  -10uA,   10uA)

    wait(1ms)
 

   meas_instr(leak_csi_low, SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS,  "PPMU", "CURRENT", 2uA,  10, 100us) 
 wait(1ms)
------Check for measure high value for debug
--     for i = 1 to 20 do 
--         if leak_csi_low[2,i] > 0.99ua or leak_csi_low[2,i] < -0.99ua then
--             wait(0)
--         end_if
--     end_for 
--  wait(1ms)


-----set Powerdown pin low    


    disconnect digital pin  SER_PWDNB from dcl delay 100us
    set digital pin  SER_PWDNB levels to vil 0V vih Vddio*0.9 iol 0uA ioh 0uA vref 0V    
    connect digital pin  SER_PWDNB  to ppmu 
    force_instr(SER_PWDNB,   "PPMU", "VOLTAGE" , 0V, 200uA,  -200uA,   200uA)  
    wait(1ms)    
    force_instr(SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS,   "PPMU", "VOLTAGE" , 1.35V, 200uA,  -200uA,   200uA)
    wait(1ms)
    meas_instr(leak_csi_hi_pwdnlow, SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS,  "PPMU", "CURRENT", 2uA,  10, 100us)
    force_instr(SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS,   "PPMU", "VOLTAGE" , -0.05V, 200uA,  -200uA,   200uA)
    wait(1ms)
    meas_instr(leak_csi_low_pwdnlow, SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS,  "PPMU", "CURRENT", 2uA,  10, 10us)
------Mipi pin CKBP has problem for now  set it to 9.9uA when powerdown low    
--     for idx = 1 to sites do
--         site = active_sites[idx]
--         leak_csi_low_pwdnlow[site,7] = 9.9ua
--         leak_csi_low_pwdnlow[site,17] = 9.9ua
--         leak_csi_hi_pwdnlow[site,7] = 9.9ua        
--         leak_csi_hi_pwdnlow[site,17] = 9.9ua 
--     end_for


------------ Power Down ---------------------------

  force_instr(SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS,   "PPMU", "VOLTAGE" , 0.0V, 200uA,  -200uA,   200uA) 
  disconnect digital pin SER_ODD_PINS + SER_EVEN_PINS + SER_CSI_EVEN_PINS + SER_CSI_ODD_PINS from ppmu --delay 100us   
--  connect digital pin SER_ODD_PINS + SER_EVEN_PINS  to dcl delay 100us
  connect digital pin  ALL_PATTERN_PINS    to dcl delay 100us

  set digital pin ALL_PATTERN_PINS - fpga_pattern_pins levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0.0V
  wait(200us)
  set hcovi SER_VDD + SER_VDD18 +SER_VDDIO  to fv 0V vmax 4V clamp imax 600mA imin -600mA
 	  
  wait(3ms)     -- extra for 47uF cap on SER_VDD  

  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)

------data log

    test_value leak_csi_hi  with CSI_HI_LEAKAGE
    test_value leak_csi_low  with CSI_LOW_LEAKAGE
    test_value leak_csi_hi_pwdnlow  with CSI_HI_LEAKAGE_PWDNLO
    test_value leak_csi_low_pwdnlow  with CSI_LOW_LEAKAGE_PWDNLO


end_body

procedure LocTimeTest(Vdd, Vddio, Vdd18,POWERUP,POWERDOWN,TP_COAX,TX_SPD,RX_SPD, ser_lock_it,Link_Lock_dly,LockTimeTestPower,LockTimeTestOneShot)

--------------------------------------------------------------------------------
in float                        : Vdd, Vddio, Vdd18
in_out  integer_test            : ser_lock_it
in_out  float_test              : LockTimeTestPower,LockTimeTestOneShot
in boolean                      : POWERUP,POWERDOWN
in string[20]                   : TP_COAX--,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float                        : TX_SPD,RX_SPD,Link_Lock_dly 
   
local



  multisite lword   : LowerRdWord, UpperRdWord
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, des_read0, des_read1, des_read2, des_read,reg_val15,FailLockCount[1]

  multisite   double : clock_ts, error_ts
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  

    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    multisite float : LockTimePowerCycle,LockTime1Shot
     multisite integer   :    ireg_val1
   boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount,count


end_local


body
  


    active_sites = get_active_sites
    sites = word(len(active_sites))  
   loopcont  = true
   SiteCheck  = false 
   
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
----These are relays control are on init so we don't have to close and open all the time
--     close cbit XRES_RELAY -- zin revb LB
--      open cbit  DNUT_OSC_RELAY    ----- Connect onboard osc( dnut)
    if POWERUP then
        DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
        
        RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read") --z
        
---Close relay to connect FPGA to control TX/RX on DNUT
        close cbit  DNUT_RXTX_RELAY --z

        wait(6ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
        powerup_dnut_vdd_vterm(1.2,1.2)
  --fpga_Set_DNUT_Pins("FPGA1", CFG2, CFG1, CFG0, PWDN, latch)
        fpga_Set_DNUT_Pins("FPGA1", 0, 0, 1, 1, false)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
        wait(6ms)    
        oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg
        wait(0ms)
    else
        Set_SER_Voltages(Vddio, Vdd, Vdd18)
    end_if
-----    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     --  for debug device ID, to make sure we test the correct device

    
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
     wait(0ms)


 ----Set SER and DES for coax or tp mode
    if TP_COAX = "TP" then
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11  
           
    else
        RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11 
            
    end_if 
    
     

-------Set GMSL link forward and backward speed.

       if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
       elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

      if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
      elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
      elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
     end_if 
    ser_link_speed_code = ser_rx_speed + ser_tx_speed
    des_link_speed_code = des_rx_speed + des_tx_speed

----Program link rate

   RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
           
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed

   wait(5ms)

-----Write to reg10 to update link speed setting 
    
    -- write Reg0x10 to update to COAX mode
--    RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#22, "SER_UART_Write")                           --- 
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1,0x00  )                             -----Dual links
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1,0x50  )                             -----Dual links
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1,0x10  )                             -----Dual links
    RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#50, "SER_UART_Write")                           ---Set auto link config and link reset

    RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#30, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89

    wait(1ms)        
--    RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)
    
--------------Check for lock, error bit
----Currently, HS89 rev 1.5G error bit always on.
----at fwd_speed = 6.0G, REV_SPEED = 0.75 then no error.
----at fwd_speed = 3.0G, REV_SPEED = 0.375 then no error.
---------------------------------------------------------------------------------------------------------------------------------------------

   wait(Link_Lock_dly )   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
 --  reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
   wait(0ms)


    while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  (lowword[site] = 0xde  OR lowword[site] =0xda  OR lowword[site] =0xCa OR lowword[site] =0xCE OR lowword[site] =0xEa OR lowword[site]=0xEE) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true     
                end_if
                if sitecount = sites then
                    loopcont = false
                end_if     
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
            if loopcont  then
                wait(1ms)
                RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
            end_if
            
        end_for            
 
    end_while



--     i = 0
--     while reg_val15[active_sites[1]] <> 0xCA  or reg_val15[active_sites[1]] <> 0xCE do--then
--         wait(5mS)
--           reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected           
--             i = i + 1
--             if reg_val15[active_sites[1]]= 0xCA  or reg_val15[active_sites[1]] = 0xCE then
--                 j = i
--                i = 200
--             end_if
--             if i>100 then 
--                 break    
--             end_if        
--     end_while
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected     
   for idxs = 1 to len(active_sites) do
     site = active_sites[idxs]
     --ireg_val_ser[site]  = integer(ser_read[site])
     ireg_val1[site]  = integer(reg_val15[site])
             if ireg_val1[site] =0xCE or  ireg_val1[site] =0xCA  then
             else
             wait(0)
             end_if
   end_for

-----For now play with lock timing

   set digital pin  SER_GPIO0_MS_LOCK levels to vil 0.0V vih Vddio vol 400mV voh Vddio*0.5 iol 10uA ioh 10uA vref Vddio
    wait(3ms)
    RegWrite_LockTiming(SER_ID, SR_CTRL0, 1, 16#00, 16#30, "SER_UART_Write_LockTime")  

--set digital pin  SER_GPIO0_MS_LOCK levels to vil 0V vih vio vol 400mV voh vio*0.8 iol 0uA ioh 00uA vref 0v
    
    read digital pattern fx1  SER_GPIO0_MS_LOCK fail count into FailLockCount

      read  digital clock msdi period c0 into clock_ts error into error_ts for "UART_WRITE_TS"
---Calculate locktiming from 1 shot
    for idx = 1 to sites do
        site = active_sites[idx]
        LockTime1Shot[site] = float(clock_ts[site]) *  float(FailLockCount[site,1])* 2.0
    end_for  
--     HS92 MPW6 with power cycle does not work
--     execute digital pattern  "SER_UART_Write_LockTime" at label "TESTING"  run to end wait --dlog
--     wait(1mS)
--     read digital pattern fx1  SER_GPIO0_MS_LOCK fail count into FailLockCount
--     read  digital clock msdi period c0 into clock_ts error into error_ts for "UART_WRITE_TS"
--     for idx = 1 to sites do
--         site = active_sites[idx]
--         LockTimePowerCycle[site] = float(clock_ts[site]) *  float(FailLockCount[site,1]) * 2.0
--     end_for

-----End here for debug timing



     open cbit CB2_SLDC                 --OVI_RELAYS 
     open cbit COAXB_M_RELAY            --OVI_RELAYS
     open cbit  FB_RELAY
-------------- Power Down --------------------------- 

--    set digital pin ALL_PATTERN_PINS  - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V       
--    wait(500us)
--    fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
   wait(6ms)
     if (POWERDOWN) then
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link) 
        powerdown_device(POWERDOWN)
    end_if


------------Data log 
  test_value ireg_val1 with ser_lock_it
--  test_value LockTimePowerCycle with LockTimeTestPower
  test_value LockTime1Shot with LockTimeTestOneShot 
  
 end_body



procedure Isupply1X4_900Mbs(Vdd, Vddio, Vdd18, POWERUP,POWERDOWN, HDCP,Link,need_reset,TP_COAX,TX_SPD,RX_SPD,MIPI_SPD,CSI_MODE,NUMB_LANES,Link_Lock_dly,LinkLock,FW_SPD,RW_SPD,CSI_SPD,NUMBER_LANES,DesRx8_1,SerTx2_0,DesRx8_2,SerTx2_1,VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP,VddI_1p26,VddI_1p26_HDCP)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in_out integer_test : NUMBER_LANES
in boolean          : POWERUP,POWERDOWN,need_reset, HDCP
in string[20]       : TP_COAX,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,MIPI_SPD,Link_Lock_dly
in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,RW_SPD,CSI_SPD
in_out integer_test : DesRx8_1,SerTx2_0,DesRx8_2,SerTx2_1,LinkLock
in_out float_test   : VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP,VddI_1p26,VddI_1p26_HDCP
in string[2]        : Link
local



  multisite lword   : LowerRdWord, UpperRdWord
 
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, RegTx2_0, RegTx2_1,desrx8_1,desrx8_2  --, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ilinklock  , number_of_lanes_test,  iRegTx2_0, iRegTx2_1,idesrx8_1,idesrx8_2      ----ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
--  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    string[20]      :  infile[4],tempp, MPW
    multisite float : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1],i_vdd_1p26_meas[1]
    multisite float : i_vdd_meas_hdcp[1] , i_vdd18_meas_hdcp[1] , i_vddio_meas_hdcp[1] ,read_Ivddio[1,1024],i_vdd_1p26_meas_hdcp[1]

    boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount,count

end_local


body
    loopcont  = true
   SiteCheck  = false   
    MPW = "MPW5"
    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
     if vdd_global[2] > 1.05 then
        set hcovi SER_VDD  to fv 1.2 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
        wait(2ms)
        set hcovi SER_VDD  to fv 1.15 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
        wait(2ms)        
        set hcovi SER_VDD  to fv 1.1 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
        wait(5ms)
       vdd_global[2]  = 1.1
     end_if   
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
 
   if (need_reset) then
---Close relay to connect FPGA to control TX/RX on DNUT
        close cbit  DNUT_RXTX_RELAY
 ---Set uart or I2C freq for communication    
        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
        powerup_dnut_vdd_vterm(1.2,1.2)
        wait(1ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
        wait(5ms)

-----    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg     
-----     reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read   for debug 
 

    
 ---------close CSI feedback loop
        close cbit  FB_RELAY

----Set SER and DES for coax or tp mode
        if TP_COAX = "TP" then
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS           
        else
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
            close cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS

        end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

        if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
        elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

        if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
        elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
        elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
        end_if 
        ser_link_speed_code = ser_rx_speed + ser_tx_speed
        des_link_speed_code = des_rx_speed + des_tx_speed

----Program link rate

        RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed

        wait(20ms)     ------needed otherwise has to wait more than 100mS after oneshot command to lock


-----Write to reg10 to update link speed setting 

        if Link = "A" or Link = "a" then
            RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#21, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89      
        elseif Link ="B" or Link = "b" then
            RegWrite(SER_ID, SR_CTRL0, 1, 16#20, 16#22, "SER_UART_Write")    
        else  -----both link
               fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1,0x00  )             ---- DES GMSL link dual
               RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#30, "SER_UART_Write") 

        end_if
   
        RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)

---------------------------------------------------------------------------------------------------------------------------------------------
--        set hcovi SER_VDDIO to fv Vddio   vmax 4V clamp imax 1mA imin -1mA  ---- reduce current
    
        wait(Link_Lock_dly )   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
    end_if   ----- from reset if statement        
-----Check for link lock 
        RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          

    while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  (lowword[site] = 0xde  OR lowword[site] =0xda  OR lowword[site] =0xCa OR lowword[site] =0xCE OR lowword[site] =0xEa OR lowword[site] =0xEE) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true     
                end_if
                if sitecount = sites then
                    loopcont = false
                end_if     
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
            if loopcont  then
                wait(1ms)
                RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
            end_if
            
        end_for            
 
    end_while

---Turn off Adapter EQ periodic
    RegWrite(SER_ID, SR_RLMS4_A ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMS4_B ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x15A4

    RegWrite(SER_ID, SR_RLMSA4_A ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMSA4_B ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x15A4

wait(0)
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock[site]  = integer(lowword[site])       
    end_for    

------Call function to generate color bar 1 to pipeline X
    GenerateColorBar1PipeLineX1x4(lword(MIPI_SPD),Link)
    if Link = "AB" or Link = "ab"    then                                ----Dual links mode
        GenerateColorBar2PipeLineY1x4(lword(MIPI_SPD))
    end_if

    --- force CSI clk out on HS94
    --- force_CSI_out_en = 1	------ Force CSI clock out at the end eleminate 80mS delay for Reg11A update to right value 0x82 
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_PHY0 , 1, 0x84)

--         RegRead(SER_ID,0x16b7 , 1, upperword, lowword,"SER_UART_Read")

--------------- read back value to make sure ser has pclk and des does have video lock
    wait(10ms)  ----Need about 10ms for readout correctly
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")    ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    desrx8_1  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_1, 1)      -- lockbit expect 0x62
    
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    if Link = "AB" or Link = "ab"    then    
        desrx8_2  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_2, 1)      -- lockbit expect 0x62
        wait(1ms)
        desrx8_2  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_2, 1)      -- lockbit expect 0x62
        RegRead(SER_ID, SR_VIDEO_TX2_1, 1, upperword, RegTx2_0,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A    
        RegRead(SER_ID, SR_VIDEO_TX2_1, 1, upperword, RegTx2_1,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    end_if
------------Measure current

          if POWERUP then
        set hcovi SER_VDDIO to fv Vddio vmax 4V measure i max 1mA clamp imax 5mA imin 5mA  ---- reduce current
        --wait(50mS) 

   end_if
    wait(50mS) ----needed for Vdd18 current stable
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas
--    measure hcovi i on SER_VDDIO for 2048 samples every 1ms  into read_Ivddio keep previous

------Add Vdd=1.26 for supply test
---Change VDD to 1.26V for measure second set
    set hcovi SER_VDD to fv 1.26 vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
    wait(2ms)
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas
 wait(2ms)


    if HDCP then  --- turn on HDCP from ser
--          RegWrite(SER_ID, 16#1677 ,1, 0x0, 0x06	, "SER_UART_Write")
--         RegWrite(SER_ID, 0x16B8,1,0x0, 0x01, "SER_UART_Write" )
--         RegWrite(SER_ID, 16#16b9 ,1, 0x0, 0x90	, "SER_UART_Write")
--         RegWrite(SER_ID, 0x16B7,1,0x0, 0x40, "SER_UART_Write" )



           if Link = "A" then
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 0x1695 ,1, 0x0, 0x43	, "SER_UART_Write")                
           elseif Link  = "B" then
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           else
               RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")                
               RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x43	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           end_if    

------------Measure current in HDCP mode
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_hdcp
        measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_hdcp
        measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_hdcp
---Change VDD back to set value for measure second set
        set hcovi SER_VDD to fv Vdd vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
        wait(5ms)
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_hdcp



-----Turn off HDCP
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0xC0	, "SER_UART_Write")                
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0xC0	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x2	, "SER_UART_Write")  
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x2	, "SER_UART_Write")
    end_if


-------------- Power Down ---------------------------
----datalog DesLockbit and serPclk bit
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        idesrx8_1[site]  = integer(desrx8_1[site])       
        iRegTx2_0[site]  = integer(RegTx2_0[site])
        if Link ="AB" or Link = "ab"    then
            idesrx8_2[site]  = integer(desrx8_2[site])       
            iRegTx2_1[site]  = integer(RegTx2_1[site])
       end_if  
    end_for    


    if (POWERDOWN) then

------- turn off MIPI clocks from DES
            fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)         
         fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)    
--          powerup_dnut_vdd_vterm(0.0,0.0) 
--           wait(20mS)
            set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS 
            open cbit  FB_RELAY
            powerdown_device(POWERDOWN)

      end_if 


--------Data log
    test_value ilinklock with LinkLock
    
    test_value msfloat(TX_SPD) with FW_SPD     
    test_value msfloat(RX_SPD) with RW_SPD  
    test_value msfloat(MIPI_SPD) with CSI_SPD
    test_value number_of_lanes_test with NUMBER_LANES
    
    test_value idesrx8_1 with DesRx8_1
    test_value iRegTx2_0 with SerTx2_0
    if Link = "AB" or Link = "ab" then
        test_value idesrx8_2 with DesRx8_2
        test_value iRegTx2_1 with SerTx2_1    
    end_if     
    test_value i_vddio_meas with VddioI  
    test_value i_vdd18_meas with Vdd18I
    test_value i_vdd_meas with VddI
    test_value i_vdd_1p26_meas with VddI_1p26
    if HDCP then    
        test_value i_vddio_meas_hdcp with VddioI_HDCP  
        test_value i_vdd18_meas_hdcp with Vdd18I_HDCP
        test_value i_vdd_meas_hdcp with VddI_HDCP
        test_value i_vdd_1p26_meas_hdcp with VddI_1p26_HDCP        
     end_if
     
 end_body





procedure GmslVolVohABUS(Vdd,  Vdd18, Vddio, VoutTest, VoutDeltaTest,VodHTest, VcmHTest, VcmDeltaTest,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
in float           : Vdd, Vdd18, Vddio
in_out float_test  : VoutTest, VoutDeltaTest,VodHTest, VcmHTest, VcmDeltaTest   -------------VodDeltaTest,
in boolean         : POWERUP,POWERDOWN
local
  multisite float : TxPHMeas[2], TxPLMeas[2], TxNHMeas[2], TxNLMeas[2]
  multisite float : VodH[4], VodL[4], Vod[4], VodDelta[4], VcmH[4], VcmL[10], Vcm[4], VcmDelta[10],Vout[4], VoutDelta[2]
  multisite float : TxPDisMeas[2], TxNDisMeas[2], TxDis[4]
  PIN LIST[2]     : MeasVi16P, MeasVi16N
  word            : CurSite
  lword           : Reg1Value, Junk
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword
  multisite float : measpindirN_L[2],  measpindirP_H[2], measpindirP_L[2],  measpindirN_H[2]   --hcu 04/30/2020 variable declaration for direct measure SIO pins
  multisite float : SIOAP_MeasH, SIOAP_MeasL, SIOAN_MeasH, SIOAN_MeasL,SIOBP_MeasH, SIOBN_MeasL,SIOBP_MeasL,SIOBN_MeasH
end_local

-------------Make Correction on DeltaVod calculation MT 5/2019


body
  active_sites = get_active_sites
  sites = word(len(active_sites))
  
  -- setup some pin lists to make cadence statements more readable maybe move to global pin groups
--     MeasVi16N = SER_ABUS3       ---------- DC_SE_M_A_VI + DC_SE_M_B_VI                 --DES_TXOUT0_N_SIOA_N_VI16+DES_TXOUT1_N_SIOB_N_VI16
--     MeasVi16P = SER_ABUS1       ------- DC_SE_P_A_VI + DC_SE_P_B_VI                 --DES_TXOUT0_P_SIOA_P_VI16+DES_TXOUT1_P_SIOB_P_VI16
    -- 04/30/2020 hcu declaration of SIO pins for direct measurement
    MeasVi16N = DC_SE_M_A_VI + DC_SE_M_B_VI 
    MeasVi16P = DC_SE_P_A_VI + DC_SE_P_B_VI 

--     set digital pin SER_GPO4_CFG0  + SER_GPO6_CFG2 levels to vil Vconf0 vih Vddio   -- TP/UART mode with DEV_ID = 0x80
--     set digital pin  SER_GPO5_CFG1 levels to vil Vconf1 vih Vddio                    ---GMSL2 mode  AND COAX
    close cbit DC_K7 
    close cbit COAXB_P_RELAY + COAXB_M_RELAY ---Connecto DC circuit
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(1ms)
----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
  
---debug in what mode    
    RegRead(SER_ID,SR_REG6 , 1, RdWordUpper, RdWordLower, "SER_UART_Read")

----Disconnect DP from SIOA/SIOB
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from dcl
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from ppmu

  -- Setup the analog hardware that will be used to measure the LVDS output pin voltages
  set vi16 chan MeasVi16P+MeasVi16N to fi 10pA max 5mA measure v max 2V clamp vmax 2V vmin 0V
  gate vi16 chan MeasVi16P+MeasVi16N on
  connect vi16 chan MeasVi16P+MeasVi16N remote hot switch

  -- setup other two ABUS VI16's so they don't load pins/interfere with measurements.
  set vi16 chan SER_ABUS0 +SER_ABUS2 to fi 1.0uA max 5uA measure v max 4V clamp vmax 4V vmin 0V  -- DEGLITCH RELATED: set clamp to 4V so that 3.6V output on GPIO14 which occurs before entering test mode 14 does not get clamped by VI16. Also set current to > 500nA to help prevent the negative glitch.
  gate vi16 chan SER_ABUS0 +SER_ABUS2 on
  connect vi16 chan SER_ABUS0 +SER_ABUS2 remote hot switch
----Connect Abus VI to GMSL link
    close cbit    ABUS_RELAY           ---------- connect the ABUS GPIO to the VI16 resources
    close cbit   MFP_LT_RELAY 
    close  cbit  I2C_LT_CB  + MFP_LT_K12_RELAY ----Using FPGA to communicate
    wait(5mS)
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################

--WH:FOLLOWUP 
  --  Disable Outputs and measure disabled voltage prior to output tests

--  RegWrite(SER_ID, SR_CTRL7, 1, 0, 16#81, "SER_UART_Write")
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_CTRL7, 1,16#81) 

  wait(5ms)
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into TxPDisMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into TxNDisMeas




-- DEBUG CODE 
-- RegRead(SER_ID, SR_RLMS95_A, 1, RdWordUpper, RdWordLower, "dut_uart_read") -- check Tx swing value. multiply by 10mV to get target swing.
-- wait(0s)
-- DEBUG CODE
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################




  -- Set the outputs to logic high
--   RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#29, "SER_UART_Write")
--   RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#29, "SER_UART_Write")
--   RegWrite(SER_ID, SR_CTRL0, 1, 0, 16#20, "SER_UART_Write")

  fpga_UART_Write("FPGA1","SER", SER_ID, SR_RLMS48_A, 1,16#29) 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_RLMS48_B, 1,16#29) 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_CTRL0, 1,16#20)
  
--  SetTestMode(11, False, "dut_uart_write")  -- DEGLITCH RELATED. TestMode14 is less prone to glitching when entering test mode, compared with TestMode11
    SetTestModeFPGA(14, False, "SER_UART_Write")  
 
-- RegWrite(SER_ID, SR_TEST0, 1, 0, 16#89, "SER_UART_Write")  -- Select the PHYA block
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_TEST0, 1,16#89)

  set vi16 chan MeasVi16P+MeasVi16N to fi 10pA max 5uA measure v max 2V clamp vmax 2V vmin 0V  -- DEGLITCH RELATED set VI16 back to 10pA forecd current after selecting PHYA.
  wait(20ms)

--   measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into SIOAP_MeasH--TxPHMeas
--   measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into SIOAN_MeasL
    -- Both sio A and B are now meaured simultaneously
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into measpindirP_H--TxPHMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into measpindirN_L

-- SIO B pins already measured directly above. ALso save test time -- hcu 04/30/2020  
-- --  RegWrite(SER_ID, SR_TEST0, 1, 0, 16#99, "SER_UART_Write")  -- Select the PHYB block 
--   fpga_UART_Write("FPGA1","SER", SER_ID, SR_TEST0, 1,16#99)  -- Select the PHYB block 
-- 
--   wait(2ms)
--   measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into SIOBP_MeasH
--   measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into SIOBN_MeasL

-----  --  Set the outputs in a low state
--   RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#2A, "SER_UART_Write")
--   RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#2A, "SER_UART_Write")
 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_RLMS48_A, 1,16#2A)  -- Set the PHYB Low 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_RLMS48_B, 1,16#2A)  -- Set the PHYB Low 

------------------RegRead(DUT_ID, SR_RLMS95_A, 1, RdWordUpper, RdWordLower, "dut_uart_read")
    --RegWrite(SER_ID, SR_TEST0, 1, 0, 16#89, "SER_UART_Write")  -- Select the PHYA block 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_TEST0, 1,16#89)  -- Select the PHYA block 
  
  wait(15ms)
--   measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into SIOAP_MeasL
--   measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into SIOAN_MeasH
    -- Both sio A and B are now meaured simultaneously hcu 04/30/2020
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into measpindirP_L
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into measpindirN_H

-- SIO B pins already measured directly above for Low. ALso save test time -- hcu 04/30/2020    
-- --RegWrite(SER_ID, SR_TEST0, 1, 0, 16#99, "SER_UART_Write")  -- Select the PHYB block
--   fpga_UART_Write("FPGA1","SER", SER_ID, SR_TEST0, 1,16#99)  -- Select the PHYB block 
--  
--     wait(500us)
-- 
-- --  wait(5ms)
--   measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into  SIOBP_MeasL--TxPLMeas
--   measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into  SIOBN_MeasH--TxNHMeas

  disconnect vi16 chan MeasVi16P+MeasVi16N
  set vi16 chan MeasVi16P+MeasVi16N to fv 0V max 4V measure i max 100mA clamp imax 100mA imin -100mA
--  gate vi16 chan MeasVi16P+MeasVi16N off
  
 -----------------------
---------power down 
  set digital pin ALL_PATTERN_PINS - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
  wait(500us)
  open  cbit    ABUS_RELAY 
--  open cbit CB2_SLDC + CB1_SLDC  ---Connecto DC circuit
  open cbit COAXB_P_RELAY + COAXB_M_RELAY ---Connecto DC circuit
  connect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP to dcl
  open cbit DC_K7 
  open  cbit   MFP_LT_RELAY  + MFP_LT_K12_RELAY
  open  cbit  I2C_LT_CB   ----Using FPGA to communicate


      powerdown_device(POWERDOWN)


----Datalog


  -- Calculate the VOD, VCM and complimetary differences, store into single variables or all I/O  
  -- I/O Order TXOUTA_0, TXOUTA_1, TXOUTA_2, TXOUTA_3, TXCLKA, TXOUTB_0, TXOUTB_1, TXOUTB_2, TXOUTB_3, TXCLKB
  for idx = 1 to sites do
    CurSite = active_sites[idx]
    -- hcu 04/30/2020 variable values
    SIOAP_MeasH[CurSite]=measpindirP_H[CurSite,1]
    SIOBP_MeasH[CurSite]=measpindirP_H[CurSite,2]
    SIOAP_MeasL[CurSite]=measpindirP_L[CurSite,1]
    SIOBP_MeasL[CurSite]=measpindirP_L[CurSite,2]
    SIOAN_MeasH[CurSite]=measpindirN_H[CurSite,1]
    SIOBN_MeasH[CurSite]=measpindirN_H[CurSite,2]
    SIOAN_MeasL[CurSite]=measpindirN_L[CurSite,1]
    SIOBN_MeasL[CurSite]=measpindirN_L[CurSite,2]
    
----New definition as Jon Rose spec
      Vout[CurSite, 1] = SIOAP_MeasH[CurSite] - SIOAP_MeasL[CurSite]         -- SIOA_P  
      Vout[CurSite, 2] = SIOAN_MeasH[CurSite] - SIOAN_MeasL[CurSite]         -- SIOA_N
      Vout[CurSite, 3] = SIOBP_MeasH[CurSite] - SIOBP_MeasL[CurSite]         -- SIOB_P
      Vout[CurSite, 4] = SIOBN_MeasH[CurSite] - SIOBN_MeasL[CurSite]         -- SIOB_N

---No need to calculate deltaVo MT 5/2019      
--      VoutDelta[CurSite, 1] = Vout[CurSite, 1] - Vout[CurSite, 2]
--       VoutDelta[CurSite, 2] = Vout[CurSite, 3] - Vout[CurSite,4]

-----      Vod = (VPH -VNL )+ (VNH-VPL) definition is changed
      Vod[CurSite, 1] = Vout[CurSite,1] + Vout[CurSite, 2]                      -- SIOA
      Vod[CurSite, 2] = Vout[CurSite, 3] +  Vout[CurSite, 4]       -- SIOB 

-------     Vod = (VPH -VNL )- (VNH-VPL)
    VodDelta[CurSite, 1] = (SIOAP_MeasH[CurSite]- SIOAN_MeasL[CurSite]) -(  SIOAN_MeasH[CurSite]    - SIOAP_MeasL[CurSite] )       -- SIOA
    VodDelta[CurSite, 2] = (SIOBP_MeasH[CurSite]- SIOBN_MeasL[CurSite]) -(  SIOBN_MeasH[CurSite]    - SIOBP_MeasL[CurSite] )       -- SIOB

--       Vod[CurSite, 2] = TxNHMeas[CurSite, 1] - TxNLMeas[CurSite, 1]         -- SIOA_N
--       Vod[CurSite, 3] = TxPHMeas[CurSite, 2] - TxPLMeas[CurSite, 2]         -- SIOB_P
--       Vod[CurSite, 4] = TxNHMeas[CurSite, 2] - TxNLMeas[CurSite, 2]         -- SIOB_N
--       VodDelta[CurSite, 1] = Vod[CurSite, 1] - Vod[CurSite, 2]
--       VodDelta[CurSite, 2] = Vod[CurSite, 3] - Vod[CurSite,4]

      Vcm[CurSite, 1] =  (SIOAP_MeasH[CurSite] + SIOAN_MeasL[CurSite])/2.0   -- SIOA_P
      Vcm[CurSite, 2] =  (SIOAN_MeasH[CurSite] + SIOAP_MeasL[CurSite])/2.0   -- SIOA_N
      Vcm[CurSite, 3] =  (SIOBP_MeasH[CurSite] + SIOBN_MeasL[CurSite])/2.0   -- SIOB_P
      Vcm[CurSite, 4] =  (SIOBN_MeasH[CurSite] + SIOBP_MeasL[CurSite])/2.0   -- SIOB_N
      VcmDelta[CurSite, 1] = Vcm[CurSite, 1] - Vcm[CurSite, 2]  
      VcmDelta[CurSite, 2] = Vcm[CurSite, 3] - Vcm[CurSite, 4]  

--       TxDis[CurSite,1] = TxPDisMeas[CurSite,1]
--       TxDis[CurSite,2] = TxNDisMeas[CurSite,1]
--       TxDis[CurSite,3] = TxPDisMeas[CurSite,2]
--       TxDis[CurSite,4] = TxNDisMeas[CurSite,2]
   endfor

  -- Datalog Tests
  test_value Vout with VoutTest
--  test_value VoutDelta with VoutDeltaTest
  test_value VodDelta with VoutDeltaTest

  test_value Vod with VodHTest
--  test_value VodDelta with VodDeltaTest
  test_value Vcm with VcmHTest
  test_value VcmDelta with VcmDeltaTest
    
end_body






procedure FeedBack_LoopTest_mod(Vdd, Vddio, Vdd18, bad_pat_it, good_pat_it,POWERDOWN,MIPI_SPD,CsiPort,NUMB_LANES,CSI_SPD,NUMBER_LANES,Deskew_En,SSEN_PORT,SptrStateChange,TP_COAX,LINK)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in_out integer_test : bad_pat_it, good_pat_it,NUMBER_LANES
in boolean          : POWERDOWN,Deskew_En
in string[20]       : CsiPort      ,TP_COAX                    -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : MIPI_SPD--,Link_Lock_dly
in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
in_out float_test   : CSI_SPD
in string[2]        :SSEN_PORT,LINK
in boolean          :SptrStateChange
local



  multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

 multisite lword    : RLMSA3_A,RLMSA3_B, RLMSA2_A,RLMSA2_B, RLM89_A,RLM89_B, RLM88_A, RLM88_B, RLM8A_A,RLM8A_B
 multisite lword    : DES_RLMSA3_A, DES_RLMSA3_B, DES_RLMSA2_A,DES_RLMSA2_B, DES_RLM89_A,DES_RLM89_B, DES_RLM88_A, DES_RLM88_B, DES_RLM8A_A,DES_RLM8A_B

 multisite lword    : RLMSC_A,RLMSC_B, RLMSD_A,RLMSD_B, RLMSE_A,RLMSE_B, RLMSF_A,RLMSF_B, RLMS10_A,RLMS10_B, RLMS11_A,RLMS11_B, RLMS13_A,RLMS13_B, RLMS2E_A,RLMS2E_B
 multisite lword    : DES_RLMSC_A,DES_RLMSC_B, DES_RLMSD_A,DES_RLMSD_B, DES_RLMSE_A,DES_RLMSE_B, DES_RLMSF_A,DES_RLMSF_B, DES_RLMS10_A,DES_RLMS10_B, DES_RLMS11_A,DES_RLMS11_B,DES_RLMS13_A,DES_RLMS13_B, DES_RLMS2E_A,DES_RLMS2E_B
 multisite lword    :  array1[26], array2[26]
    string[20]      :  infile[4],tempp
   boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount,count
 multisite lword   : Read_BadPtrnLimit

end_local


body

   loopcont  = true
   SiteCheck  = false 

    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    

-----Dut power up function

    Set_SER_Voltages(Vddio, Vdd, Vdd18)    
--    wait(2ms)

---------close CSI feedback loop
    close cbit  FB_RELAY

   wait(5ms)  

    if SptrStateChange then
    --- force_CSI_out_en = 0	------ Force CSI clock out at the end eleminate 80mS delay for Reg11A update to right value 0x82 
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_PHY0 , 1, 0x04)   ---- turn off mipi clock MT 
        if TP_COAX ="COAX" then
            RegWrite(SER_ID, SR_CTRL1, 1, 16#00, 16#0F, "SER_UART_Write")
            fpga_UART_Write("FPGA1","DES", DESA_ID,DR_CTRL1 , 1, 0x0F	)
       else
            RegWrite(SER_ID, SR_CTRL1, 1, 16#00, 16#0a, "SER_UART_Write")
            fpga_UART_Write("FPGA1","DES", DESA_ID,DR_CTRL1 , 1, 0x0a	)
        end_if       
        SSEN_ON_OFF(SSEN_PORT )
    ---------need oneshot reset otherwise loopback will fail
--         RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#30, "SER_UART_Write")                           ---Set manual link config and one shot; auto link will select both links for HS89
--         RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
    if LINK = "A" then
        fpga_UART_Write("FPGA1","DES", DESA_ID, SR_CTRL0, 1, 16#21)
        RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#21, "SER_UART_Write")  ---- only link A
    elseif LINK = "B" then
       fpga_UART_Write("FPGA1","DES", DESA_ID, SR_CTRL0, 1, 16#22)
       RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#22, "SER_UART_Write")    ---- only link B
    else   
        fpga_UART_Write("FPGA1","DES", DESA_ID, SR_CTRL0, 1, 16#20) 
        RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#30, "SER_UART_Write")                           ---Set manual link config and one shot; auto link will select both links for HS89
    end_if
    wait(1ms)      




        count = 0
        while( loopcont) do
            for idx = 1 to sites do 
                site = active_sites[idx]
                    if  (lowword[site] = 0xde  OR lowword[site] =0xda  OR lowword[site] =0xCa OR lowword[site] =0xCE OR lowword[site] =0xEa OR lowword[site] =0xEE) and not SiteCheck[site] then
                        sitecount = sitecount + 1
                        SiteCheck[site] = true     
                    end_if
                    if sitecount = sites then
                        loopcont = false
                    end_if     
                count = count + 1
                if count > 200 then
                    loopcont  = false
                end_if
                if loopcont  then
                    wait(1ms)
                    RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
                end_if
            
            end_for             
        end_while  
    end_if
  
   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
   wait(0ms)


------
   RegWrite(SER_ID,SR_REG2, 1, 0, 0xF3	, "SER_UART_Write" )  --- enable Video transmit
	if CsiPort ="A" then ---- use pipeLine Y
    		RegWrite(SER_ID,SR_FRONTTOP_9,  1,0, 0x02, "SER_UART_Write" )
	elseif CsiPort ="B" then ---- use pipeLine Z
     		RegWrite(SER_ID,SR_FRONTTOP_9,  1,0, 0x40, "SER_UART_Write" )  
	else  ---A&B port A on X and PortB on U
		RegWrite(SER_ID,SR_FRONTTOP_9,  1,0, 0x81, "SER_UART_Write" )
	end_if 	   
   
    RegWrite(SER_ID,SR_FRONTTOP_0, 1, 0, 0x7C, "SER_UART_Write" )  --- select Video pipe line to port A and B
    RegWrite(SER_ID, SR_MIPI_LPB0 ,1, 16#00, 16#08, "SER_UART_Write")                                      -- 16#0370    PRBS patterns ???? 16#08
    RegWrite(SER_ID, SR_MIPI_LPB1, 1, 16#00, 16#02, "SER_UART_Write")
------Test bench does not have LSB
  RegWrite(SER_ID, SR_MIPI_LPB2, 1, 16#00, 16#02, "SER_UART_Write")                                       -- 16#0372    Pixel count lsb byte for MIPI loop back test current set to 2?
  RegWrite(SER_ID, SR_MIPI_LPB3, 1, 16#00, 16#02, "SER_UART_Write")                                       -- 16#0373    Pixel count Msb byte for MIPI loop back test current set to 2?

 
------- Set MIPI_RX registers number of lanes 2x4 mode
    number_of_lane = (NUMB_LANES -1) | ((NUMB_LANES -1) <<4)
---Turn on Deskew 
    if Deskew_En then
        number_of_lane = number_of_lane | 0x44
    end_if 
    RegWrite(SER_ID, SR_MIPI_RX1, 1, 16#00, number_of_lane, "SER_UART_Write")
    if CsiPort ="A" then
	RegWrite(SER_ID,SR_MIPI_RX0, 1, 0,  0x84, "SER_UART_Write")
    elseif CsiPort ="B" then
	RegWrite(SER_ID,SR_MIPI_RX0, 1, 0,  0x85, "SER_UART_Write")
    else
	RegWrite(SER_ID,SR_MIPI_RX0, 1, 0,  0x86, "SER_UART_Write")    
    endif
-----Lane mapping    
    RegWrite(SER_ID, SR_MIPI_RX2, 1, 16#00, 16#4E, "SER_UART_Write")                                       ------- 16#0332    Phy1/phy0 lane map 
    RegWrite(SER_ID, SR_MIPI_RX3, 1, 16#00, 16#E4, "SER_UART_Write")                                       ------- 16#0333    Phy2/phy3 lane map 

 ---------------------Now setup DES------
---- lane mappings	"
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_PHY3 , 1, 0x4e	)
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_PHY4 , 1, 0xe4	)
----# lane count = 4	
    des_numb_lane = ((NUMB_LANES -1) <<6)
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_TX10_40A , 1, 0x00)
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_TX10_44A , 1, des_numb_lane)
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_TX10_48A , 1, des_numb_lane)
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_TX10_4CA , 1, 0x00)

---# CSI rate  per lane
    if MIPI_SPD = 80.0e6 then
        mipi_speed = 0x20
    else           
        mipi_speed = lword(MIPI_SPD / 100.0e6)| 0x20
    end_if
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_BACKTOP22 , 1,  mipi_speed )----29
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_BACKTOP25 , 1,  mipi_speed )----29
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_BACKTOP28 , 1,  mipi_speed) ----29
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_BACKTOP31 , 1,  mipi_speed )----29

----Set  Deskew on DES side
    if Deskew_En then
    
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX4_0, 1, 16#81) 
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX4_1, 1, 16#81)
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX4_2, 1, 16#81)
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX4_3, 1, 16#81)    
    
    end_if


---- STR_SEL_
    if CsiPort ="A" then  ---- Ser on Pipeline Y 
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_0 , 1, 0x0)
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_1 , 1, 0x1)
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_2 , 1, 0x2)
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_3 , 1, 0x3)    	
    elseif CsiPort ="B" then  ---- Ser on Pipeline z 
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_0 , 1, 0x0)
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_1 , 1, 0x1)
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_2 , 1, 0x2)
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_3 , 1, 0x3)    	
    else   ---A on X and Y on U
    
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_0 , 1, 0x1)
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_1 , 1, 0x0)
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_2 , 1, 0x3)
        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_RX0_3 , 1, 0x2)    	
    
    end_if		
    --- force_CSI_out_en = 1	------ Force CSI clock out at the end eleminate 80mS delay for Reg11A update to right value 0x82 
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_PHY0 , 1, 0x84)
 wait(3ms)   ----use to be 100ms
 


 ------######loop back test-----

   RegWrite(SER_ID, SR_MIPI_LPB0 , 1, 16#00, 16#6F, "SER_UART_Write")                                      -- 16#0370    select bad pattern
   wait(20ms)   ----use to be 100ms
  RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, lowword,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
  wait(200us)
 
  RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, lowword,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
  wait(200us)
  Read_BadPtrnLimit  = lword(bad_pat_it.low_limit)

-----------------Optimum time search 
        count = 0
        sitecount = 0
        loopcont  = true
        SiteCheck  = false

        while( loopcont) do
            for idx = 1 to sites do 
                site = active_sites[idx]
                    if  (lowword[site] = Read_BadPtrnLimit[site]) and not SiteCheck[site] then
                        sitecount = sitecount + 1
                        SiteCheck[site] = true     
                    end_if
                    if sitecount = sites then
                        loopcont = false
                    end_if     
            end_for   
                count = count + 1
                if count > 10 then
                    loopcont  = false
                end_if
                if loopcont  then
                    wait(1ms)
                    RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, lowword,"SER_UART_Read")  
  

                end_if
         
        end_while  

--  RegRead(SER_ID, 16#010A, 1, upperword, lowword,"SER_UART_Read")   

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val_ser_bad[site]  = integer(lowword[site])    
    end_for 
  

  RegWrite(SER_ID,SR_MIPI_LPB0 , 1, 16#00, 16#6B, "SER_UART_Write")                                       -- select GOOD pattern  (PRBS)
  wait(3ms) 
    
  RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, lowword,"SER_UART_Read")                                       --16#0374 should see NO BIT high, meaning PASS THE TEST   
  wait(200us)   
----Debug Readback
-- RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword,upperword ,"SER_UART_Read")
-- RegRead(SER_ID, SR_VIDEO_TX2_1, 1, upperword,upperword ,"SER_UART_Read")
-- RegRead(SER_ID, SR_VIDEO_TX2_2, 1, upperword,upperword ,"SER_UART_Read")
-- RegRead(SER_ID, SR_VIDEO_TX2_3, 1, upperword,upperword ,"SER_UART_Read")
-- 
-- RLMSC_A  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_0, 1)      -- lockbit expect 0x62
-- RLMSC_A  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_1, 1)      -- lockbit expect 0x62
-- RLMSC_A  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_2, 1)      -- lockbit expect 0x62
-- RLMSC_A  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_3, 1)      -- lockbit expect 0x62
-----------




    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val_ser_good[site]  = integer(lowword[site])
    end_for 

  

      

   -- turn off MIPI clocks from DES
            
   RegWrite(SER_ID, SR_MIPI_LPB0 , 1, 16#00, 16#00, "SER_UART_Write") 
   fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)            
   open cbit  FB_RELAY
   wait(5ms)----
   -- reg_val23  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)
   -- loop back relays on LB opened
--   fpga_cbit_control("FPGA1", 2#0000)      -- control FPGA cbits 2#0000  (cb4, cb3, cb2, cb1)   
--      open cbit CB2_SLDC                 --OVI_RELAYS 
--      open cbit COAXB_M_RELAY            --OVI_RELAYS
--      open cbit  FB_RELAY
-------------- Power Down ---------------------------
    if (POWERDOWN) then

--        set digital pin ALL_PATTERN_PINS - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V

        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)
        open cbit CB2_SLDC                 --OVI_RELAYS 
        open cbit COAXB_M_RELAY            --OVI_RELAYS
         open cbit  FB_RELAY
        open cbit  FB_RELAY
        open cbit  DNUT_RXTX_RELAY
        powerdown_device(POWERDOWN)

    end_if 

    test_value ireg_val_ser_bad  with bad_pat_it 
    test_value ireg_val_ser_good with good_pat_it          
    test_value msfloat(MIPI_SPD) with CSI_SPD
    test_value number_of_lanes_test with NUMBER_LANES


 end_body



procedure Gmsl1OutputResistanceAbus(Vdd, Vdd18, Vddio, ResistanceTest, POWERUP,POWERDOWN,GMSL1)
in float          : Vdd, Vdd18, Vddio
in_out float_test : ResistanceTest
in boolean        : POWERUP,POWERDOWN
in_out integer_test    : GMSL1 
local
--   multisite float : PhyAPHighMeas[1], PhyAPLowMeas[1], PhyANHighMeas[1], PhyANLowMeas[1]
--   multisite float : PhyAPHighMeas2[1], PhyAPLowMeas2[1], PhyANHighMeas2[1], PhyANLowMeas2[1]
--   multisite float : PhyBPHighMeas[1], PhyBPLowMeas[1], PhyBNHighMeas[1], PhyBNLowMeas[1]
--   multisite float : PhyBPHighMeas2[1], PhyBPLowMeas2[1], PhyBNHighMeas2[1], PhyBNLowMeas2[1]


  multisite float   : PhyAPTopMeas[1], PhyAPBotMeas[1], PhyANTopMeas[1], PhyANBotMeas[1]
  multisite float   : PhyAPTopMeas2[1], PhyAPBotMeas2[1], PhyANTopMeas2[1], PhyANBotMeas2[1]
  multisite float   : PhyBPTopMeas[1], PhyBPBotMeas[1], PhyBNTopMeas[1], PhyBNBotMeas[1]
  multisite float   : PhyBPTopMeas2[1], PhyBPBotMeas2[1], PhyBNTopMeas2[1], PhyBNBotMeas2[1]

  multisite float : PhyResCalc[4], XresVltg
  multisite word  : Status
  word            : CurSite
  PIN LIST[2]     : MeasVi16P, MeasVi16N

  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword
  multisite integer : gmsl1_bit

endlocal

body
  active_sites = get_active_sites()
  sites = word(len(active_sites))
--  disconnect digital pin DUT_XRES from dcl

  -- setup some pin lists to make cadence statements more readable maybe move to global pin groups
  MeasVi16N = DC_SE_M_A_VI + DC_SE_M_B_VI
  MeasVi16P = DC_SE_P_A_VI + DC_SE_P_B_VI

---  Status = DutPowerUp(Vddc, Vdda, Vdd18, Vddio, Vddio25, Vdd33, "A0_UART_COAX", "SioDc", "", 0.0)
----Procedure for power up  need put in small routine later
   disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!  

        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)
   close cbit COAXB_P_RELAY + COAXB_M_RELAY  ---Connecto DC circuit
    DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL1",POWERUP)
 
    close cbit  ABUS_RELAY           ---------- connect the ABUS GPIO to the VI16 resources

  SetTestMode(11, False, "SER_UART_Write")
  wait(5ms)
    RegRead(SER_ID, SR_REG6, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
--    RegRead(SER_ID, 0, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    for idx = 1 to sites do
        CurSite = active_sites[idx]
        gmsl1_bit[CurSite] = integer(RdWordLower[CurSite]) >> 7
    end_for
--WH:FOLLOWUP


  
--  Set TX amplitude field = 0x00. 
  RegWrite(SER_ID, SR_RLMS95_A, 1, 0, 0xC0, "SER_UART_Write")
  RegWrite(SER_ID, SR_RLMS95_B, 1, 0, 0xC0, "SER_UART_Write")
--  Set TX PreDrvAmplMan field = 0x30
  RegWrite(SER_ID, SR_RLMS94_A, 1, 0, 0x70, "SER_UART_Write")  ---70
  RegWrite(SER_ID, SR_RLMS94_B, 1, 0, 0x70, "SER_UART_Write")---70

-- one-shot reset of data path (register values not affected)
--  RegWrite(SER_ID, SR_CTRL0, 1, 0, 16#20, "SER_UART_Write")

 ------- Select the PHYA block / 
    RegWrite(SER_ID, SR_TEST0, 1, 0, 16#89, "SER_UART_Write")              ------- Select the PHYA block /  set vi16 chan abus0_pins+abus1_pins+abus2_pins+abus3_pins+MeasVi16P+MeasVi16N to fi 0A max 5mA measure v max 2V clamp vmax 2V vmin -1V    
    RegRead(SER_ID, SR_TEST0, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    RegRead(SER_ID, SR_RLMS48_A, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
    RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#29, "SER_UART_Write")         ------Force TXhigh
    RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#29, "SER_UART_Write")         ------Force TXhigh
    close  cbit   MFP_LT_RELAY ----Connect GPIOs to ABUS unfortunately, SDA and SCL also disconnect. Fix in RevB hw
    close cbit COAXB_P_RELAY + COAXB_M_RELAY  ---Connecto DC circuit
    close cbit  I2C_LT_CB + MFP_LT_K12_RELAY  ----Using FPGA to communicate
    
   
----Disconnect DP from SIOA/SIOB
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from dcl
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from ppmu
    wait(5mS)---5ms
  -- **** GMSL PHY A Testing ****
  -- Measure the differential voltage before sinking any current

    connect vi16 chan  SER_ABUS0 + SER_ABUS1+ SER_ABUS2+ SER_ABUS3 remote
    set vi16 chan SER_ABUS0  + SER_ABUS1 +  SER_ABUS2+ SER_ABUS3 to fi 0.01ua  measure V max 2v clamp vmax 2v vmin -0.1v  
    set vi16 chan SER_ABUS0  + SER_ABUS1 +  SER_ABUS2+ SER_ABUS3 + MeasVi16P+MeasVi16N to fi 0A max 5mA measure v max 2V clamp vmax 2V vmin -2V

  gate vi16 chan SER_ABUS0  + SER_ABUS1 +  SER_ABUS2+ SER_ABUS3 + MeasVi16P+MeasVi16N on ---Do I need it? I don't think I gate it off
--  connect vi16 chan SER_ABUS0+abus1_VI16_pins+abus2_VI16_pins+abus3_VI16_pins + MeasVi16P + MeasVi16N remote hot switch
  connect vi16 chan SER_ABUS0  + SER_ABUS1 +  SER_ABUS2+ SER_ABUS3 vm 
  connect vi16 chan MeasVi16P+MeasVi16N remote hot switch

  wait(5ms)---15ms

  measure vi16 v on chan SER_ABUS1 for 15 samples every 10us averaged into PhyAPBotMeas           ------PhyAPLowMeas  
  measure vi16 v on chan SER_ABUS0 for 15 samples every 10us averaged into PhyAPTopMeas           ------PhyAPHighMeas 

--  RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#2A, "SER_UART_Write")         ------Force TXLow

 fpga_UART_Write("FPGA1","SER", SER_ID,SR_RLMS48_A , 1, 0x2A)        ------Force TXLow

--  RegRead(SER_ID,SR_RLMS48_A, 1, RdWordUpper, RdWordLower, "SER_UART_Read")  
  RdWordLower = fpga_UART_Read("FPGA1", "SER", SER_ID,SR_RLMS48_A , 1)
 


  measure vi16 v on chan SER_ABUS3 for 15 samples every 10us averaged into PhyANBotMeas
  measure vi16 v on chan SER_ABUS2 for 15 samples every 10us averaged into PhyANTopMeas
 wait(0)

  -- Sink 5mA of current and re-measure the differential voltage
  set vi16 chan MeasVi16P+MeasVi16N to fi -5mA max 5mA measure v max 2V clamp vmax 2V vmin -1V
  wait(5ms)---15ms
  measure vi16 v on chan SER_ABUS3 for 15 samples every 10us averaged into  PhyANBotMeas2           ------PhyANLowMeas2
  measure vi16 v on chan SER_ABUS2 for 15 samples every 10us averaged into  PhyANTopMeas2            ------PhyANHighMeas2
 
--  RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#29, "SER_UART_Write")         ------Force TXhigh
 fpga_UART_Write("FPGA1","SER", SER_ID,SR_RLMS48_A , 1, 0x29)        ------Force TXhigh
--  RdWordLower = fpga_UART_Read("FPGA1", "SER", SER_ID,SR_RLMS48_A , 1)

  measure vi16 v on chan SER_ABUS1 for 15 samples every 10us averaged into PhyAPBotMeas2            ------ PhyAPLowMeas2  
  measure vi16 v on chan SER_ABUS0 for 15 samples every 10us averaged into PhyAPTopMeas2           ------ PhyAPHighMeas2

  -- Determine the voltage difference between 0mA and 1mA to calculate the resistance
  for idx = 1 to sites do 
    CurSite = active_sites[idx]
    PhyResCalc[CurSite, 1] = ((PhyAPTopMeas2[CurSite, 1] - PhyAPBotMeas2[CurSite, 1] )- (PhyAPTopMeas[CurSite, 1] - PhyAPBotMeas[CurSite, 1] )) / 5mA
    PhyResCalc[CurSite, 2] =  ((PhyANTopMeas2[CurSite, 1] - PhyANBotMeas2[CurSite, 1]-  (PhyANTopMeas[CurSite, 1] - PhyANBotMeas[CurSite, 1] ) ) )/ 5mA
  endfor
  set vi16 chan  SER_ABUS0  + SER_ABUS1 +  SER_ABUS2+ SER_ABUS3 +MeasVi16P + MeasVi16N to fi 0A max 5mA measure v max 2V clamp vmax 2V vmin -1V


--   -- **** GMSL PHY B Testing ****
--   -- Measure the differential voltage before sinking any current
-- 
--  fpga_UART_Write("FPGA1","SER", SER_ID, SR_TEST0, 1, 0x99)   
--   RdWordLower = fpga_UART_Read("FPGA1", "SER", SER_ID,SR_TEST0 , 1)  
--  fpga_UART_Write("FPGA1","SER", SER_ID,SR_RLMS48_B , 1, 0x29)
-- wait(1ms) 
-- 
--   measure vi16 v on chan SER_ABUS1 for 15 samples every 10us averaged into PhyBPBotMeas   
--   measure vi16 v on chan SER_ABUS0 for 15 samples every 10us averaged into PhyBPTopMeas 
-- 
--  fpga_UART_Write("FPGA1","SER", SER_ID,SR_RLMS48_B , 1, 0x2A)        ------Force TXlow
-- 
--   wait(1ms)  
-- 
--   measure vi16 v on chan SER_ABUS3 for 15 samples every 10us averaged into PhyBNBotMeas
--   measure vi16 v on chan SER_ABUS2 for 15 samples every 10us averaged into PhyBNTopMeas 
-- 
--   -- Sink 5mA of current and re-measure the differential voltage
--   set vi16 chan MeasVi16P+MeasVi16N to fi -5mA max 5mA measure v max 2V clamp vmax 2V vmin -1V
--   wait(15ms)
-- 
--   measure vi16 v on chan SER_ABUS1 for 15 samples every 10us averaged into PhyBPBotMeas2          ------ PhyBPLowMeas2  
--   measure vi16 v on chan SER_ABUS0 for 15 samples every 10us averaged into PhyBPTopMeas2          ------PhyBPHighMeas2
-- 
--  fpga_UART_Write("FPGA1","SER", SER_ID,SR_RLMS48_B , 1, 0x29)        
--     wait(1mS)
--   measure vi16 v on chan SER_ABUS3 for 15 samples every 10us averaged into PhyBNBotMeas2    ------ PhyBNLowMeas2
--   measure vi16 v on chan SER_ABUS2 for 15 samples every 10us averaged into PhyBNTopMeas2    ------ PhyBNHighMeas2
-- 
-- 
--   -- Determine the voltage difference between 0mA and 1mA to calculate the resistance
--   for idx = 1 to sites do 
--     CurSite = active_sites[idx]
--     PhyResCalc[CurSite, 3] = ((PhyBPTopMeas2[CurSite, 1] - PhyBPBotMeas2[CurSite, 1] ) - (PhyBPTopMeas[CurSite, 1] - PhyBPBotMeas[CurSite, 1] )) / 5.0mA
--     PhyResCalc[CurSite, 4] = ((PhyBNTopMeas2[CurSite, 1] - PhyBNBotMeas2[CurSite, 1] ) -  (PhyBNTopMeas[CurSite, 1] - PhyBNBotMeas[CurSite, 1] )) / 5.0mA
--   endfor
-- 
--   set vi16 chan SER_ABUS0+SER_ABUS1+SER_ABUS2+SER_ABUS3+MeasVi16P+MeasVi16N to fi 0A max 5mA measure v max 2V clamp vmax 2V vmin -1V
--   wait(1ms)
--   disconnect vi16 chan SER_ABUS0+SER_ABUS1+SER_ABUS2+SER_ABUS3+MeasVi16P+MeasVi16N
--   set vi16 chan SER_ABUS0+SER_ABUS1+SER_ABUS2+SER_ABUS3+MeasVi16P+MeasVi16N to fv 0V max 5V measure i max 100mA clamp imax 100mA imin -100mA
-- 
-- --  gate vi16 chan SER_ABUS0+SER_ABUS1+SER_ABUS2+SER_ABUS3+MeasVi16P+MeasVi16N off

---------power down 

     if (POWERDOWN) then
            wait(500us)
            open  cbit    ABUS_RELAY +  MFP_LT_RELAY  + I2C_LT_CB + MFP_LT_K12_RELAY 
            open cbit CB2_SLDC + CB1_SLDC  ---Connecto DC circuit
            open cbit COAXB_P_RELAY + COAXB_M_RELAY 
            connect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP to dcl
------- turn off MIPI clocks from DES
            set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
            powerdown_device(POWERDOWN)

      end_if 
 
--  
--   set digital pin ALL_PATTERN_PINS levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
--   wait(500us)
--   open digital cbit    ABUS_RELAY +  MFP_LT_RELAY  + I2C_LT_CB
--   open ovi chan CB2_SLDC + CB1_SLDC cbit ---Connecto DC circuit
--   open ovi chan COAXB_P_RELAY + COAXB_M_RELAY cbit
--   connect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP to dcl
-- 
--   set hcovi SER_VDD + SER_VDD18 to fv 0V vmax 4V clamp imax 600mA imin -600mA         
--   set hcovi SER_VDDIO to fv 0V   vmax 4V clamp imax 600mA imin -600mA
  
 	  
--  wait(10ms)     -- extra for 47uF cap on SER_VDD        

  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)  

----Datalog

  test_value PhyResCalc with ResistanceTest
  test_value gmsl1_bit with GMSL1

endbody


procedure Isupply1X4_594MbsGmsl1(Vdd, Vddio, Vdd18, POWERUP,POWERDOWN, HDCP,Link,need_reset,TP_COAX,MIPI_SPD,CSI_MODE,MipiPort,NUMB_LANES,BWS,HIBW,LinkLock,FW_SPD,CSI_SPD,NUMBER_LANES,VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP,VddI1p26,VddI1p26_HDCP)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in_out integer_test : NUMBER_LANES
in boolean          : POWERUP,POWERDOWN,need_reset, HDCP
in string[20]       : TP_COAX,CSI_MODE,      MipiPort                    -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : MIPI_SPD
in lword            : NUMB_LANES  ,BWS,HIBW                         ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,CSI_SPD
in_out integer_test : LinkLock
in_out float_test   : VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP,VddI1p26,VddI1p26_HDCP
in string[2]        : Link
local



  multisite lword   : LowerRdWord, UpperRdWord
 
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1,gmsl1_forward_speed
  multisite lword   : lowword, upperword, RegTx2_0, RegTx2_1,desrx8_1,desrx8_2  --, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ilinklock  , number_of_lanes_test,  iRegTx2_0, iRegTx2_1,idesrx8_1,idesrx8_2      ----ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
--  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    string[20]      :  infile[4],tempp, MPW
    multisite float : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1],i_vdd_meas_1p26[1]
    multisite float : i_vdd_meas_hdcp[1] , i_vdd18_meas_hdcp[1] , i_vddio_meas_hdcp[1] ,read_Ivddio[1,1024],  vdd_sw[1],i_vdd_meas_hdcp_1p26[1]



end_local


body
  
    MPW = "MPW5"
    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    gmsl1_forward_speed  = float((BWS*10) + 30) * MIPI_SPD * float(NUMB_LANES) /24.0
 
 
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
    RegRead(SER_ID,0x06 , 1, upperword, lowword,"SER_UART_Read")
   if (need_reset) then
---Close relay to connect FPGA to control TX/RX on DNUT
        close cbit  DNUT_RXTX_RELAY
 ---Set uart or I2C freq for communication    
        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
        powerup_dnut_vdd_vterm(1.2,1.2)
        wait(1ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
        wait(5ms)

-----    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg     
-----     reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read   for debug 
 
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG6, 1, 0x0B)
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,DR_REG6 , 1) 
 ---------close CSI feedback loop
        close cbit  FB_RELAY

----Set SER and DES for coax or tp mode
        if TP_COAX = "TP" then
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS           
        else
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
            close cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS
            wait(5ms)
        end_if 
 end_if 
----Here 

-----Turn off Adapter EQ periodic
    RegWrite(SER_ID, SR_RLMS4_A ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMS4_B ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x15A4

    RegWrite(SER_ID, SR_RLMSA4_A ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMSA4_B ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x15A4
wait(0)




------Disable Serial and link enable
   RegWrite(SER_ID,  SR_GMSL1_4, 1, 0x00 ,0x03, "SER_UART_Write")----0x404
---enable gmsl1 mode
    RegWrite(SER_ID,  SR_REG6, 1, 0x00 ,0x0B, "SER_UART_Write")    ----0x06

---Set HIBW at ser
--RegWrite(SER_ID,  0x407, 1, 0x00 ,0x40, "SER_UART_Write")   ---- Set this at the end otherwise coax mode hibw not working no lock
    wait(5mS)   ----Needed for port B without this lock is intermittance
    if MipiPort = "A" then
        RegWrite(SER_ID, SR_FRONTTOP_0,1, 0x00 ,0x7C	, "SER_UART_Write")  --- mapping port A 
    else    
        RegWrite(SER_ID, SR_FRONTTOP_0,1, 0x00 ,0x7D	, "SER_UART_Write")     --- mapping port B ---0x331
    end_if
-----# ctrl0_cfg_dpi_vsync_width_l = 1		
    RegWrite(SER_ID,  SR_DSI6, 1, 0x00 ,0x01, "SER_UART_Write")
--    RegWrite(SER_ID,  0x396, 1, 0x00 ,0x01, "SER_UART_Write")


    RegWrite(SER_ID, SR_MIPI_RX1, 1, 0x00 ,0x33	, "SER_UART_Write")                 -- 0x331

    RegWrite(SER_ID, SR_FRONTTOP_20 , 1, 0x00 ,0x98, "SER_UART_Write")               ----0x31C
    RegWrite(SER_ID, SR_FRONTTOP_25  , 1, 0x00 ,0x24, "SER_UART_Write")               ----0x321
--     if MipiPort = "A" then
--         RegWrite(SER_ID,  SR_MIPI_RX0, 1, 0x00 ,0x84, "SER_UART_Write")                 ---0x330---- turn on MIPI port A only
--     else
--         RegWrite(SER_ID,  SR_MIPI_RX0, 1, 0x00 ,0x85, "SER_UART_Write")   ---- turn on MIPI port B only
--    end_if
--     if MipiPort = "A" then
--         RegWrite(SER_ID,  SR_MIPI_LPB0, 1, 0x00 ,0x01, "SER_UART_Write")                ----0x370
--     else
--         RegWrite(SER_ID,  SR_MIPI_LPB0, 1, 0x00 ,0x20, "SER_UART_Write")                ----0x370
--     end_if    
----------
    RegWrite(SER_ID, SR_VTX_X_VTX0  , 1, 0x00 , 0xe3, "SER_UART_Write")                     ------0x1c8
    RegWrite(SER_ID, SR_VTX_X_VTX2  , 1, 0x00 , 0x0, "SER_UART_Write")                      ----0x1ca
    RegWrite(SER_ID, SR_VTX_X_VTX3, 1, 0x00 , 0x0, "SER_UART_Write")                        ----0x1cb
    RegWrite(SER_ID, SR_VTX_X_VTX4 , 1, 0x00 , 0x0, "SER_UART_Write")                       ----- 0x1cc
    RegWrite(SER_ID, SR_VTX_X_VTX5   , 1, 0x00 , 0x00, "SER_UART_Write")                    -----0x1cd
    RegWrite(SER_ID, SR_VTX_X_VTX6   , 1, 0x00 , 0x2A, "SER_UART_Write")                    -----0x1ce
    RegWrite(SER_ID, SR_VTX_X_VTX7, 1, 0x00 , 0xF8, "SER_UART_Write")                    -----0x1cf
    RegWrite(SER_ID, SR_VTX_X_VTX8, 1, 0x00 , 0x19, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX9, 1, 0x00 , 0x02, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX10, 1, 0x00 , 0x58, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX11 , 1, 0x00 , 0x0, "SER_UART_Write")               ------  0x1d3
    RegWrite(SER_ID, SR_VTX_X_VTX12 , 1, 0x00 , 0x0, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX13, 1, 0x00 , 0x0, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX14, 1, 0x00 , 0x00, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX15, 1, 0x00 , 0x28, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX16, 1, 0x00 , 0x08, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX17, 1, 0x00 , 0x70, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX18, 1, 0x00 , 0x02, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX19, 1, 0x00 , 0xEE, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX20, 1, 0x00 , 0x00, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX21, 1, 0x00 , 0xD7, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX22, 1, 0x00 , 0xDC, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX23, 1, 0x00 , 0x06, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX24, 1, 0x00 , 0x90, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX25, 1, 0x00 , 0x02, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX26, 1, 0x00 , 0x08, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX27, 1, 0x00 , 0x02, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX28, 1, 0x00 , 0xD0, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX29, 1, 0x00 , 0x2, "SER_UART_Write")
    RegWrite(SER_ID, SR_VTX_X_VTX30, 1, 0x00 , 0x4, "SER_UART_Write")

-----Setup DES
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG6, 1, 0x0B)--
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_GMSL1_7, 1, 0x08)    -----0xB07

    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_GMSL1_EN, 1, 0x01)         ---0xF00
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_GMSL1_96, 1, 0x83)       ----0xB96
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_GMSL1_A7, 1, 0x45)         ---0xBA7
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_FSYNC_2, 1, 0x01)        ----0x3E2
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP12, 1, 0xC2) -----0x313
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_BACKTOP15 , 1, 0x24)      ---0x316
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP22, 1, 0x6F)                 ----0x31D
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX11, 1, 0x07)             ------ 0x40B
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX45 , 1, 0x15)             -----0x42D,
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX13, 1, 0x24)              ---0x40D
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX14, 1, 0x24)                 ----- 0x40E
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX17, 1, 0x01)
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX18 , 1, 0x01)
--     fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1d00, 1, 0xf4)                ---Doesnot have register name for 1d00
--     fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP25, 1, 0x06)                         ----0x320
--     fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP23, 1, 0x52)                     ---- 0x31e
--     fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY0, 1, 0x84)                    ----0x330                      
    if MipiPort = "A" then
     RegWrite(SER_ID,  SR_MIPI_LPB0, 1, 0x00 ,0x01, "SER_UART_Write") 
    RegWrite(SER_ID,  SR_MIPI_RX0, 1, 0x00 ,0x84, "SER_UART_Write")
    fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1d00, 1, 0xf4)                ---Doesnot have register name for 1d00
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP25, 1, 0x00)                         ----0x320   --06
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP23, 1, 0x52)                     ---- 0x31e
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY0, 1, 0x84)                    ----0x330                      
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX45 , 1, 0x15)             -----0x42D,
        fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1d00, 1, 0xf5)
        fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1d03, 1, 0x92)
        fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1d07, 1, 0x84)
        fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1d08, 1, 0x2f)
        fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1d0a, 1, 0xa1)
    else
         RegWrite(SER_ID,  SR_MIPI_LPB0, 1, 0x00 ,0x20, "SER_UART_Write") 
     RegWrite(SER_ID,  SR_MIPI_RX0, 1, 0x00 ,0x85, "SER_UART_Write")
     fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1E00, 1, 0xf4)                ---Doesnot have register name for 1d00
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP28, 1, 0x00)                         ----0x323 --06
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_BACKTOP26, 1, 0x52)                     ---- 0x321
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_PHY0, 1, 0x84) 
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_MIPI_TX45 , 1, 0x2A)             -----0x42D,
         RegWrite(SER_ID,  0x396, 1, 0x00 ,0x01, "SER_UART_Write")
        fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1E00, 1, 0xf5)
        fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1E03, 1, 0x92)
        fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1E07, 1, 0x84)
        fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1E08, 1, 0x2f)
        fpga_UART_Write("FPGA1","DES", DESA_ID, 0x1E0a, 1, 0xa1)       
    end_if

---Set HIBW at ser
    RegWrite(SER_ID,  SR_GMSL1_7, 1, 0x00 ,0x40, "SER_UART_Write")
    RegWrite(SER_ID,  SR_GMSL1_4, 1, 0x00 , 0x83, "SER_UART_Write")             ---enable ser 
    wait(5mS)
    oreg_reg_val = fpga_read_register("FPGA1", SERDES_STATUS)                       ----Use Fpga to check lock. expect high or we can read out reg at DES 0xbcb
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,0xbcb, 1)
    wait(1ms)



----To Here
---These for debug
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,0x6 , 1) 
-- RegRead(SER_ID, 0x1C9, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(SER_ID, 0x20c, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(SER_ID, 0x24F, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(DESA_ID, 0x0, 1, upperword, RegTx2_0,"SER_UART_Read")---292
-- RegRead(SER_ID, 0x407, 1, upperword, RegTx2_0,"SER_UART_Read")
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,0 , 1)
 reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,DR_GMSL1_CB , 1)

 wait(1ms)
---------------------------------------------------------------------------------------------------------------------------------------------

    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock[site]  = (integer(oreg_reg_val[site])  & 0x800  )   >>11  
    end_for    
wait(1ms)

    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas
---Measure ivdd = 1.26
   set hcovi SER_VDD  to fv 1.26v vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
   wait(5ms)
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_1p26
    if HDCP then  --- turn on HDCP from ser

           if Link = "A" then 
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x43	, "SER_UART_Write")

            end_if    
------------Measure current in HDCP mode
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_hdcp_1p26
        measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_hdcp
        measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_hdcp
        set hcovi SER_VDD  to fv Vdd vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
        wait(5ms)        
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_hdcp
-----Turn off HDCP
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0xC0	, "SER_UART_Write")                
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0xC0	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x2	, "SER_UART_Write")  
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x2	, "SER_UART_Write")

    end_if


-------------- Power Down ---------------------------


    if (POWERDOWN) then

------- turn off MIPI clocks from DES
            fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)         
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)    
--         powerup_dnut_vdd_vterm(0.0,0.0) 
          wait(2mS)
            set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS 
            open cbit  FB_RELAY
            powerdown_device(POWERDOWN)
      end_if 


--------Data log
    test_value ilinklock with LinkLock
    
    test_value msfloat(gmsl1_forward_speed) with FW_SPD      
    test_value msfloat( MIPI_SPD) with CSI_SPD
    test_value number_of_lanes_test with NUMBER_LANES
 
    test_value i_vddio_meas with VddioI  
    test_value i_vdd18_meas with Vdd18I
    test_value i_vdd_meas with VddI

    if HDCP then    
        test_value i_vddio_meas_hdcp with VddioI_HDCP  
        test_value i_vdd18_meas_hdcp with Vdd18I_HDCP
        test_value i_vdd_meas_hdcp with VddI_HDCP
        test_value i_vdd_meas_hdcp_1p26 with VddI1p26_HDCP        
     end_if
    test_value i_vdd_meas_1p26 with VddI1p26
     

 end_body





procedure Isupply1X4_1p3Gbs(Vdd, Vddio, Vdd18, POWERUP,POWERDOWN, HDCP,Link,need_reset,TP_COAX,TX_SPD,RX_SPD,MIPI_SPD,CSI_MODE,NUMB_LANES,Link_Lock_dly,LinkLock,FW_SPD,RW_SPD,CSI_SPD,NUMBER_LANES,DesRx8_1,SerTx2_0,DesRx8_2,SerTx2_1,VddioI,Vdd18I,VddI,Vdd1p26,Vdd181p7,Vdd0p95)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in_out integer_test : NUMBER_LANES
in boolean          : POWERUP,POWERDOWN,need_reset, HDCP
in string[20]       : TP_COAX,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,MIPI_SPD,Link_Lock_dly
in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,RW_SPD,CSI_SPD
in_out integer_test : DesRx8_1,SerTx2_0,DesRx8_2,SerTx2_1,LinkLock
in_out float_test   : VddioI,Vdd18I,VddI,Vdd1p26,Vdd181p7,Vdd0p95
in string[2]        : Link
local

------------This supply current test for HS89 56 lead mipi clock = 1.3g replica or single link A MT 12/2018
------------------------------------------------------------------
  multisite lword   : LowerRdWord, UpperRdWord
 
   
 --  multisite integer : LBDONE
--   float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, RegTx2_0, RegTx2_1,desrx8_1,desrx8_2  --, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ilinklock  , number_of_lanes_test,  iRegTx2_0, iRegTx2_1,idesrx8_1,idesrx8_2      ----ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
--  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    string[20]      :  infile[4],tempp, MPW
    multisite float : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1]
    multisite float : i_vdd_meas_1p26[1],i_vdd_meas_0p95[1],i_vdd18_meas_1p7[1]

    boolean           : CHAR
   boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount,count


end_local


body
    
    loopcont  = true
    SiteCheck  = false  
    get_expr("OpVar_Char", CHAR)


    MPW = "MPW5"

    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)

   if (need_reset) then


---Close relay to connect FPGA to control TX/RX on DNUT
        close cbit  DNUT_RXTX_RELAY
 ---Set uart or I2C freq for communication    
        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
         powerup_dnut_vdd_vterm(1.2,1.2)
--         wait(1ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
         fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
         wait(5ms)

-----    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg     
--     reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read   for debug 
 
RegRead(SER_ID, SR_PWR0, 1, upperword,lowword,"SER_UART_Read")

 ---------close CSI feedback loop
        close cbit  FB_RELAY
 wait(5ms)
----Set SER and DES for coax or tp mode
        if TP_COAX = "TP" then
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS           
        else
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
            close cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS

        end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

        if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
        elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

        if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
        elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
        elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
        end_if 
        ser_link_speed_code = ser_rx_speed + ser_tx_speed
        des_link_speed_code = des_rx_speed + des_tx_speed

----Program link rate

        RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed


        wait(20ms)     ------needed otherwise has to wait more than 100mS after oneshot command to lock



-----Write to reg10 to update link speed setting 

        if Link = "A" or Link = "a" then
            RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#21, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89      
        elseif Link ="B" or Link = "b" then
            RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#22, "SER_UART_Write")    
        elseif Link ="Sp" then
               fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1, 0x13  )             ---- DES GMSL link dual
               RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#53, "SER_UART_Write")         
               RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#13, "SER_UART_Write") 
        else  -----both link
               fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1,0x10  )             ---- DES GMSL link dual
               RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#30, "SER_UART_Write") 

        end_if
   
--        RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)

---------------------------------------------------------------------------------------------------------------------------------------------
         wait(1ms)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!   
--        wait(Link_Lock_dly  )   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
    end_if   ----- from reset if statement        
-----Check for link lock 
        RegRead(SER_ID,SR_CTRL3 , 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          


   while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  (lowword[site] = 0xde  OR lowword[site] =0xda  OR lowword[site] =0xCa OR lowword[site] =0xCE OR lowword[site] =0xEa OR lowword[site]=0xEE OR lowword[site] =0xFa OR lowword[site]=0xFE ) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true     
                end_if
         end_for      
                if sitecount = sites then
                    loopcont = false
                end_if     
           
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
            if loopcont  then
                wait(1ms)
                RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
            end_if
            
                  
 
    end_while

        RegRead(SER_ID,SR_CTRL3 , 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA     

wait(0)



---Turn off Adapter EQ periodic
    RegWrite(SER_ID, SR_RLMS4_A ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMS4_B ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x15A4

    RegWrite(SER_ID, SR_RLMSA4_A ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMSA4_B ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x15A4

wait(0)

-- RegRead(SER_ID, SR_PWR0, 1, upperword,lowword,"SER_UART_Read")              
-- RegRead(SER_ID, 0x1D, 1, upperword,lowword,"SER_UART_Read")
--          upperword  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
-- upperword  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x1D, 1) 
    if Link = "Sp"    then 
-----------------------------# phy_config = 4 (1x4 A port only)  invert_csi_mode = 1
        RegWrite(SER_ID, 0x330 ,1, 0x00 , 0x84, "SER_UART_Write" )---------0x330
-----------------------------# Number of Lanes - turn on all lanes on CTRL 0 and 1   
        RegWrite(SER_ID, 0x331 ,1, 0x00 , 0x33, "SER_UART_Write" )---------0x331
-----------------------------# Enable MIPI loopback TX on port A   
        RegWrite(SER_ID, 0x370 ,1, 0x00 , 0x01, "SER_UART_Write" )---------0x370
-----------------------------# VIDEO_X : TX_STR_SEL = 0  TX_SPLT_MASK_A = 1 
        RegWrite(SER_ID, 0x53 ,1, 0x00 , 0x10, "SER_UART_Write" )---------0x53
-----------------------------# VIDEO_Z : TX_STR_SEL = 2  TX_SPLT_MASK_B = 1 
        RegWrite(SER_ID, 0x5B ,1, 0x00 , 0x22, "SER_UART_Write" )---------0x5B
-----------------------------# VID_TX_EN_X Z = 1 
        RegWrite(SER_ID, 0x02 ,1, 0x00 , 0x53, "SER_UART_Write" )---------0x02
-----------------------------# START_PORTAX = 1  START_PORTAZ = 1  others are 0
        RegWrite(SER_ID, 0x311 ,1, 0x00 , 0x05, "SER_UART_Write" )---------0x311
-----------------------------# CLK_SEL_X = 0  CLK_SEL_Z = 0 
        RegWrite(SER_ID, 0x308 ,1, 0x00 , 0x70, "SER_UART_Write" )---------0x308

    elseif Link = "A" then ------ Link A only port a
-----------------------------# phy_config = 4 (1x4 A port only)  invert_csi_mode = 1
        RegWrite(SER_ID, 0x330 ,1, 0x00 , 0x84, "SER_UART_Write" )---------0x330
-----------------------------# Number of Lanes - turn on all lanes on CTRL 0 and 1   
        RegWrite(SER_ID, 0x331 ,1, 0x00 , 0x33, "SER_UART_Write" )---------0x331
-----------------------------# Enable MIPI loopback TX on port A   
        RegWrite(SER_ID, 0x370 ,1, 0x00 , 0x01, "SER_UART_Write" )---------0x370
-----------------------------# VID_TX_EN_X Z = 1 
        RegWrite(SER_ID, 0x02 ,1, 0x00 , 0x13, "SER_UART_Write" )---------0x02
-----------------------------# START_PORTAX = 1   others are 0
        RegWrite(SER_ID, 0x311 ,1, 0x00 , 0x01, "SER_UART_Write" )---------0x311
-----------------------------# CLK_SEL_X = 0  
        RegWrite(SER_ID, 0x308 ,1, 0x00 , 0x7C, "SER_UART_Write" )---------0x308


    else----portb linkb

-----------------------------# phy_config = 4 (1x4 B port only)  invert_csi_mode = 1
        RegWrite(SER_ID, 0x330 ,1, 0x00 , 0x85, "SER_UART_Write" )---------0x330
-----------------------------# Number of Lanes - turn on all lanes on CTRL 0 and 1   
        RegWrite(SER_ID, 0x331 ,1, 0x00 , 0x33, "SER_UART_Write" )---------0x331
-----------------------------# Enable MIPI loopback TX on port B   
        RegWrite(SER_ID, 0x370 ,1, 0x00 , 0x20, "SER_UART_Write" )---------0x370
-----------------------------# VID_TX_EN_X Z = 1 
        RegWrite(SER_ID, 0x02 ,1, 0x00 , 0x13, "SER_UART_Write" )---------0x02
-----------------------------# START_PORTAX = 1   others are 0
        RegWrite(SER_ID, 0x311 ,1, 0x00 , 0x10, "SER_UART_Write" )---------0x311
-----------------------------# CLK_SEL_X = 1---port B  
        RegWrite(SER_ID, 0x308 ,1, 0x00 , 0x71, "SER_UART_Write" )---------0x308

    end_if

-----------------------------# Generate the 1st COLOR BAR pattern using video timing&pattern generator (pipe-X)   
-----------------------------# resolution 1920x1080  
RegWrite(SER_ID, 0x1c8 ,1, 0x00 , 0xe3, "SER_UART_Write" )---------0x1c8
RegWrite(SER_ID, 0x1CA ,1, 0x00 , 0x0, "SER_UART_Write" )---------0x1CA
RegWrite(SER_ID, 0x1CB ,1, 0x00 , 0x0, "SER_UART_Write" )---------0x1CB
RegWrite(SER_ID, 0x1CC ,1, 0x00 , 0x0, "SER_UART_Write" )---------0x1CC
RegWrite(SER_ID, 0x1CD ,1, 0x00 , 0x0, "SER_UART_Write" )---------0x1CD
RegWrite(SER_ID, 0x1CE ,1, 0x00 , 0x2A, "SER_UART_Write" )---------0x1CE
RegWrite(SER_ID, 0x1CF ,1, 0x00 , 0xF8, "SER_UART_Write" )---------0x1CF
RegWrite(SER_ID, 0x1D0 ,1, 0x00 , 0x25, "SER_UART_Write" )---------0x1D0
RegWrite(SER_ID, 0x1D1 ,1, 0x00 , 0x99, "SER_UART_Write" )---------0x1D1
RegWrite(SER_ID, 0x1D2 ,1, 0x00 , 0x0, "SER_UART_Write" )---------0x1D2
RegWrite(SER_ID, 0x1D3 ,1, 0x00 , 0x0, "SER_UART_Write" )---------0x1D3
RegWrite(SER_ID, 0x1D4 ,1, 0x00 , 0x0, "SER_UART_Write" )---------0x1D4
RegWrite(SER_ID, 0x1D5 ,1, 0x00 , 0x0, "SER_UART_Write" )---------0x1D5
RegWrite(SER_ID, 0x1D6 ,1, 0x00 , 0x0, "SER_UART_Write" )---------0x1D6
RegWrite(SER_ID, 0x1D7 ,1, 0x00 , 0x2C, "SER_UART_Write" )---------0x1D7
RegWrite(SER_ID, 0x1D8 ,1, 0x00 , 0x8, "SER_UART_Write" )---------0x1D8
RegWrite(SER_ID, 0x1D9 ,1, 0x00 , 0x6C, "SER_UART_Write" )---------0x1D9
RegWrite(SER_ID, 0x1DA ,1, 0x00 , 0x4, "SER_UART_Write" )---------0x1DA
RegWrite(SER_ID, 0x1DB ,1, 0x00 , 0x65, "SER_UART_Write" )---------0x1DB
RegWrite(SER_ID, 0x1DC ,1, 0x00 , 0x1, "SER_UART_Write" )---------0x1DC
RegWrite(SER_ID, 0x1DD ,1, 0x00 , 0x61, "SER_UART_Write" )---------0x1DD
RegWrite(SER_ID, 0x1DE ,1, 0x00 , 0x18, "SER_UART_Write" )---------0x1DE
RegWrite(SER_ID, 0x1DF ,1, 0x00 , 0x7, "SER_UART_Write" )---------0x1DF
RegWrite(SER_ID, 0x1E0 ,1, 0x00 , 0x80, "SER_UART_Write" )---------0x1E0
RegWrite(SER_ID, 0x1E1 ,1, 0x00 , 0x1, "SER_UART_Write" )---------0x1E1
RegWrite(SER_ID, 0x1E2 ,1, 0x00 , 0x18, "SER_UART_Write" )---------0x1E2
RegWrite(SER_ID, 0x1E3 ,1, 0x00 , 0x4, "SER_UART_Write" )---------0x1E3
RegWrite(SER_ID, 0x1E4 ,1, 0x00 , 0x38, "SER_UART_Write" )---------0x1E4
RegWrite(SER_ID, 0x1e5 ,1, 0x00 , 0x2, "SER_UART_Write" )---------0x1e5
RegWrite(SER_ID, 0x1e6 ,1, 0x00 , 0x4, "SER_UART_Write" )---------0x1e6
-----------------------------# ------------------------------- HS92 --------------------------------	"

-----------------------------# lane mappings	"
fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x333 ,1 , 0x4e)------0x333
fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x334 ,1 , 0xe4)------0x334
-----------------------------# lane count = 4	"
fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x40A ,1 , 0x00)------0x40A
fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x44A ,1 , 0xD0)------0x44A
fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x48A ,1 , 0xD0	)------0x48A
fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x4CA ,1 , 0x00	)------0x4CA
-----------------------------# set CSI data rate to 1.3Gbps
if MIPI_SPD  = 650MHz then
    fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x1D00 ,1 , 0xf4)
    fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x320 ,1 , 0x00)
    fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x31E ,1 , 0x00)
    fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x1d00 ,1 , 0xf5)
    fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x1d03 ,1 , 0x92)    
    fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x1d07 ,1 , 0x00)    
    fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x1d08 ,1 , 0x34)    
    fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x1d0a ,1 , 0xA1)    
 
 else
    mipi_speed = lword(MIPI_SPD/100.0e6) + 0x20
    if Link ="B" then 

        fpga_UART_Write("FPGA1","DES", DESA_ID,DR_BACKTOP28 , 1,  mipi_speed)----29
    else
        fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x320 ,1 ,mipi_speed )------0x320
    end_if    
 end_if

-----------------------------# STR_SEL
fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x50 ,1 , 0x1)------0x50
fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x51 ,1 , 0x0)------0x51
fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x52 ,1 , 0x2)------0x52
fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x53 ,1 , 0x3	)------0x53 
-----------------------------# force CSI clk out on HS94 (force_CSI_out_en = 1)
 fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x330 ,1 , 0x84	)------0x330"
-- -----------------------------# Disable MIPI loopback TX
-- fpga_UART_Write("FPGA1", "DES", DESA_ID, 0x370 ,1 , 0x00)------0x370

wait(0)
   for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock[site]  = integer(lowword[site])       
    end_for    
-- ---Turn off Adapter EQ periodic
--     RegWrite(SER_ID, SR_RLMS4_A ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x14A4
--     RegWrite(SER_ID, SR_RLMS4_B ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x15A4
-- 
--     RegWrite(SER_ID, SR_RLMSA4_A ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x14A4
--     RegWrite(SER_ID, SR_RLMSA4_B ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x15A4

--------------- read back value to make sure ser has pclk and des does have video lock
    wait(5ms)  ----Need about 10ms for readout correctly
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")    ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    desrx8_1  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_1, 1)      -- lockbit expect 0x62
    
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    for idx = 1 to sites do
        site = active_sites[idx]
        if RegTx2_0[site] <> 0x8A then
            wait(5ms)-----Some units failed at hot when Cef setup. For right now fix
            RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A    
        end_if
    end_for    
    if Link = "Sp"    then    
        desrx8_2  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_2, 1)      -- lockbit expect 0x62 
        RegRead(SER_ID, SR_VIDEO_TX2_2, 1, upperword, RegTx2_1,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    else
--        Print_banner_message("Max9295E only test in Spliter mode.","Please change to correct mode","")
--        desrx8_2  = 0
--        RegTx2_1 = 0
    end_if
------------Measure current

          if POWERUP then
        set hcovi SER_VDDIO to fv Vddio vmax 4V measure i max 1mA clamp imax 5mA imin 5mA  ---- reduce current
        --wait(50mS) 

   end_if
    wait(50mS)-----needed for Vdd18 curent stable
    measure hcovi i on SER_VDD for 50 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 50 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 50 samples every 10us averaged into i_vddio_meas
----Change supply for other measurement

--    Set_SER_Voltages(vio, vdd, vdd18)
    Set_SER_Voltages(Vddio, 1.26V, Vdd18)   --- Change Vdd to 1.26V
    wait(5ms)
    measure hcovi i on SER_VDD for 100 samples every 10us averaged into i_vdd_meas_1p26
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas
    if CHAR then
        Set_SER_Voltages(Vddio, 1.05, 1.7V)   --- Change Vdd to 0.95V
        wait(10ms)
        Set_SER_Voltages(Vddio, 1.00, 1.7V)   --- Change Vdd to 0.95V
        wait(10ms)
        Set_SER_Voltages(Vddio, 0.95, 1.7V)   --- Change Vdd to 0.95V
        wait(5ms)
        measure hcovi i on SER_VDD for 50 samples every 10us averaged into i_vdd_meas_0p95
        measure hcovi i on SER_VDD18 for 50 samples every 10us averaged into i_vdd18_meas_1p7
    end_if

-------------- Power Down ---------------------------
----datalog DesLockbit and serPclk bit
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        idesrx8_1[site]  = integer(desrx8_1[site])       
        iRegTx2_0[site]  = integer(RegTx2_0[site])
        if Link ="Sp"    then
            idesrx8_2[site]  = integer(desrx8_2[site])       
            iRegTx2_1[site]  = integer(RegTx2_1[site])
       end_if  
    end_for    





    if (POWERDOWN) then

------- turn off MIPI clocks from DES
--            fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)
            fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)  
            set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
            powerdown_device(POWERDOWN)
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS 
            open cbit  FB_RELAY
            wait(5ms)
      end_if 


--------Data log
    test_value ilinklock with LinkLock
    
    test_value msfloat(TX_SPD) with FW_SPD     
    test_value msfloat(RX_SPD) with RW_SPD  
    test_value msfloat(MIPI_SPD) with CSI_SPD
    test_value number_of_lanes_test with NUMBER_LANES
    
    test_value idesrx8_1 with DesRx8_1
    test_value iRegTx2_0 with SerTx2_0
    if Link = "Sp" then
        test_value idesrx8_2 with DesRx8_2
        test_value iRegTx2_1 with SerTx2_1    

    end_if     
    test_value i_vddio_meas with VddioI  
    test_value i_vdd18_meas with Vdd18I
    test_value i_vdd_meas with VddI

    test_value i_vdd_meas_1p26 with Vdd1p26
    if CHAR then
        test_value i_vdd18_meas_1p7 with Vdd181p7
        test_value i_vdd_meas_0p95 with Vdd0p95    
    end_if    
 end_body



-- # set CSI data rate to 650Mbps					
-- 0x90	0x1d00	0xf4			
-- 0x90	0x320	0x00			
-- 0x90	0x31e	0x00			
-- 0x90	0x1d00	0xf5			
-- 0x90	0x1d03	0x92			
-- 0x90	0x1d07	0x00			
-- 0x90	0x1d08	0x34			
-- 0x90	0x1d0a	0xA1

procedure FeedBack_LinkLock_LoopTest(Vdd, Vddio, Vdd18,  ser_lock_it, des_lock_it,POWERUP,TP_COAX,TX_SPD,RX_SPD,LINK,Link_Lock_dly)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in_out integer_test : ser_lock_it, des_lock_it
in boolean          : POWERUP----SSEN   remove ssen move it to loopback func
in string[20]       : TP_COAX,LINK                    -----TP_COAX : TP or COAX mode, CSI_PORT --- A or B or A and B
in float            : TX_SPD,RX_SPD,Link_Lock_dly



local



  multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

--  multisite lword    : RLMSA3_A,RLMSA3_B, RLMSA2_A,RLMSA2_B, RLM89_A,RLM89_B, RLM88_A, RLM88_B, RLM8A_A,RLM8A_B
--  multisite lword    : DES_RLMSA3_A, DES_RLMSA3_B, DES_RLMSA2_A,DES_RLMSA2_B, DES_RLM89_A,DES_RLM89_B, DES_RLM88_A, DES_RLM88_B, DES_RLM8A_A,DES_RLM8A_B

 multisite lword    : RLMSC_A,RLMSC_B, RLMSD_A,RLMSD_B, RLMSE_A,RLMSE_B, RLMSF_A,RLMSF_B, RLMS10_A,RLMS10_B, RLMS11_A,RLMS11_B, RLMS13_A,RLMS13_B, RLMS2E_A,RLMS2E_B
 multisite lword    : DES_RLMSC_A,DES_RLMSC_B, DES_RLMSD_A,DES_RLMSD_B, DES_RLMSE_A,DES_RLMSE_B, DES_RLMSF_A,DES_RLMSF_B, DES_RLMS10_A,DES_RLMS10_B, DES_RLMS11_A,DES_RLMS11_B,DES_RLMS13_A,DES_RLMS13_B, DES_RLMS2E_A,DES_RLMS2E_B
 multisite lword    :  array1[26], array2[26]
    string[20]      :  infile[4],tempp
   boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount,count


end_local


body
   loopcont  = true
   SiteCheck  = false 

    LBDONE = 0  -- need initialize to fail first
--    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "COAX_GMSL2",POWERUP)

---For debug    
  --   RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
--     wait(200us)

 
---Close relay to connect FPGA to control TX/RX on DNUT
    close cbit  DNUT_RXTX_RELAY

--  CRYSTAL running now, we should have LOCK on DES site???
--  Answer is NO on rev1 device (bug), but should be fixed on rev2 device  

    
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(0ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
    powerup_dnut_vdd_vterm(1.05,1.2)

    
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
    fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
    wait(6ms)
--     
--     oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg
--     wait(0ms)
      
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read    
    wait(200us)
    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val0[site]  = integer(reg_val0[site]) 
    end_for     
    
 ---------close CSI feedback loop
    close cbit  FB_RELAY

    SetupGmslLinkSpeed(TX_SPD,RX_SPD,TP_COAX)


-----Write to reg10 to update link speed setting 
   wait(10ms)    ------------60ms
    -- write Reg0x10 to update to COAX mode
    if LINK = "A" then
        RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#21, "SER_UART_Write")  ---- only link A
    elseif LINK = "B" then
       RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#22, "SER_UART_Write")    ---- only link B
    else   
        fpga_UART_Write("FPGA1","DES", DESA_ID, SR_CTRL0, 1, 16#00) 
        wait(2ms)
        RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#30, "SER_UART_Write")                           ---Set manual link config and one shot; auto link will select both links for HS89
    end_if
    wait(1ms)        

--    RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)
-----No need to repeat at DES
--     fpga_UART_Write("FPGA1","DES", DESA_ID, 16#10, 1, 0x30)
--     des_read =  fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x10, 1)      -- self adjust back to 0x01
--     wait(0ms)
     
--------------Check for lock, error bit
----Currently, HS89 rev 1.5G error bit always on.
----at fwd_speed = 6.0G, REV_SPEED = 0.75 then no error.
----at fwd_speed = 3.0G, REV_SPEED = 0.375 then no error.
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---DE request to turn on SSEN-----Turn on SSEN, GMSL2 Vpp =2500ppm, PHYA, f = 25kHz spread generation:to sub-routine

   wait(Link_Lock_dly)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!

   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   

    while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  (lowword[site] = 0xde  OR lowword[site] =0xda  OR lowword[site] =0xCa OR lowword[site] =0xCE OR lowword[site] =0xEa OR lowword[site]=0xEE) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true     
                end_if
                if sitecount = sites then
                    loopcont = false
                end_if     
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
            if loopcont  then
                wait(1ms)
                RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
            end_if
            
        end_for            
 
    end_while

   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   

-- 
-- 
--    wait(0ms)
--    
--         if reg_val15[active_sites[1]] = 0xCA  or reg_val15[active_sites[1]] = 0xDA  then 
--         
--         else
--             wait(50ms)
--             RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
--             reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
--         end_if
--    wait(0ms)
 
  for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val1[site]  = integer(lowword[site])
      ireg_val15[site] = integer(reg_val15[site])      
   end_for    



    test_value ireg_val1 with ser_lock_it
    test_value ireg_val15 with des_lock_it        



 end_body







procedure LoopBackGmsl1(Vdd, Vddio, Vdd18, POWERUP,POWERDOWN, HDCP,Link,need_reset,TP_COAX,MIPI_SPD,CSI_MODE,MipiPort,NUMB_LANES,BWS,HIBW,delay,LinkLock,FW_SPD,CSI_SPD,NUMBER_LANES,HIBW_FT,BWS_FT,BadPat,GoodPat)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18,delay
in_out integer_test : NUMBER_LANES,BadPat,GoodPat
in boolean          : POWERUP,POWERDOWN,need_reset, HDCP
in string[20]       : TP_COAX,CSI_MODE,      MipiPort                    -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : MIPI_SPD
in lword            : NUMB_LANES  ,BWS,HIBW                         ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,CSI_SPD
in_out integer_test : LinkLock,HIBW_FT,BWS_FT
--in_out float_test   : HIBW_FT,BWS_FT--VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP
in string[2]        : Link
local



  multisite lword   : LowerRdWord, UpperRdWord
 
 
   
  multisite integer : LBDONE
  float             : gmsl1_forward_speed ---Vconf0, Vconf1,
  multisite lword   : lowword, upperword, RegTx2_0, RegTx2_1,desrx8_1,desrx8_2  

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ilinklock  , number_of_lanes_test,  iRegTx2_0, iRegTx2_1,idesrx8_1,idesrx8_2  ,badpat_ft,goodpat_ft    ----ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
--  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    string[20]        :  infile[4],tempp, MPW
    multisite float   : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1]
    multisite float   : i_vdd_meas_hdcp[1] , i_vdd18_meas_hdcp[1] , i_vddio_meas_hdcp[1] ,read_Ivddio[1,1024],  vdd_sw[1]
    multisite integer : bws_ft, hibw_ft


end_local


body
  
    MPW = "MPW5"
    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    gmsl1_forward_speed  = float((BWS*10) + 30) * MIPI_SPD * float(NUMB_LANES) /24.0
    mipi_speed  = lword(MIPI_SPD/100.0e6)
 
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
    RegRead(SER_ID,0x06 , 1, upperword, lowword,"SER_UART_Read")
   if (need_reset) then
---Close relay to connect FPGA to control TX/RX on DNUT
        close cbit  DNUT_RXTX_RELAY
 ---Set uart or I2C freq for communication    
        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
        powerup_dnut_vdd_vterm(1.2,1.2)
        wait(1ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
        wait(5ms)

-----    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg     
-----     reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read   for debug 
 
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG6, 1, 0x0B)
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,DR_REG6 , 1) 
 ---------close CSI feedback loop
        close cbit  FB_RELAY

----Set SER and DES for coax or tp mode
        if TP_COAX = "TP" then
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS           
        else
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
            close cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS
            wait(5ms)
        end_if 
 end_if 
----Here 
------Disable Serial and link enable
--    RegWrite(SER_ID,  SR_GMSL1_4, 1, 0x00 ,0x03, "SER_UART_Write")----0x404
---enable gmsl1 mode
    RegWrite(SER_ID,  SR_REG6, 1, 0x00 ,0x0B, "SER_UART_Write")    ----0x06


-----Setup DES
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG6, 1, 0x0B)--

----------------------------------########### CLINKEN = 1 SEREN = 0
RegWrite(SER_ID, 0x404 ,1 ,0x00, 0x43, "SER_UART_Write")--------0x404
----------------------------------########### ctrl0_cfg_dpi_vsync_width_l = 1
RegWrite(SER_ID, 0x386 ,1 ,0x00, 0x01, "SER_UART_Write")--------0x386
----------------------------------########### lane count = 4
RegWrite(SER_ID, 0x331 ,1 ,0x00, 0x33	, "SER_UART_Write")--------0x331"
----------------------------------########### soft_dtx_en= 1
RegWrite(SER_ID, 0x31C ,1 ,0x00, 0x98, "SER_UART_Write")--------0x31C
----------------------------------########### soft_dtx = h24
RegWrite(SER_ID, 0x321 ,1 ,0x00, 0x24, "SER_UART_Write")--------0x321
----------------------------------########### soft_dty_en = 1
RegWrite(SER_ID, 0x31D ,1 ,0x00, 0x98, "SER_UART_Write")--------0x31D
----------------------------------########### soft_dty = h24
RegWrite(SER_ID, 0x322 ,1 ,0x00, 0x24, "SER_UART_Write")--------0x322
----------------------------------########### ctrl1_cfg_dpi_vsync_width_l = 1
RegWrite(SER_ID, 0x396 ,1 ,0x00, 0x01, "SER_UART_Write")--------0x396
----------------------------------########### soft_dtz_en = 1
RegWrite(SER_ID, 0x31E ,1 ,0x00, 0x98, "SER_UART_Write")--------0x31E
----------------------------------########### soft_dtz = h24
RegWrite(SER_ID, 0x323 ,1 ,0x00, 0x24, "SER_UART_Write")--------0x323



----------------------------------########### LINK_EN_B = 0
fpga_UART_Write("FPGA1","DES", DESA_ID,0xF00 ,1 ,0x01)     --------0xF00
----------------------------------########### CONV_GMSL1_EN_A = 1 CONV_GMSL1_DATATYPE_A = h10
fpga_UART_Write("FPGA1","DES", DESA_ID,0xB96 ,1 ,0x83)     --------0xB96
----------------------------------########### SHIFT_VID_HVD_A = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0xBA7 ,1 ,0x45)     --------0xBA7
----------------------------------########### MST_LINK_SEL = b000
fpga_UART_Write("FPGA1","DES", DESA_ID,0x3E2 ,1 ,0x01)     --------0x3E2
----------------------------------########### soft_bpp_x = d24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x313 ,1 ,0xC2)     --------0x313
----------------------------------########### soft_dt_x = h24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x316 ,1 ,0x24)     --------0x316
----------------------------------########### override_bpp_vc_dtx = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x31D ,1 ,0x6F)     --------0x31D
----------------------------------########### set CSI data rate
fpga_UART_Write("FPGA1","DES", DESA_ID,0x320 ,1 ,mipi_speed + 0x20)     --------0x320

----------------------------------########### MAP_EN_L_0 = 7
fpga_UART_Write("FPGA1","DES", DESA_ID,0x40B ,1 ,0x07)     --------0x40B
----------------------------------########### MAP_DPHY_DEST_01
fpga_UART_Write("FPGA1","DES", DESA_ID,0x42D ,1 ,0x15)     --------0x42D
----------------------------------########### MAP_SRC_0_0 = h24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x40D ,1 ,0x24)     --------0x40D
----------------------------------########### MAP_DST_0_0 = h24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x40E ,1 ,0x24)     --------0x40E
----------------------------------########### MAP_SRC_2_0 = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x411 ,1 ,0x01)     --------0x411
----------------------------------########### MAP_DST_2_0 = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x412 ,1 ,0x01)     --------0x412
----------------------------------########### force_csi_out_en = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x330 ,1 ,0x84)     --------0x330
----------------------------------########### Set HIBW_A = 1 on DES
    if HIBW = 1 then
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x08)     --------0xB07

----------------------------------########### Set HIBW = 1 on SER
        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x40, "SER_UART_Write")--------0x407
    elseif BWS = 1 then
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x20)     --------0xB07   ----BW = 1
        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x20, "SER_UART_Write")--------0x407----BW = 1
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB06 ,1 ,0x68) ---------- USe HS/VS
   else
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x00)     --------0xB07   ----BW = 1
        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x00, "SER_UART_Write")--------0x407----BW = 1   
        reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,0xb07 , 1)
        RegRead(SER_ID, 0x407, 1, upperword, RegTx2_0,"SER_UART_Read")

    end_if        
----------------------------------########### CLINKEN = 0 SEREN = 1
RegWrite(SER_ID, 0x404 ,1 ,0x00, 0x83, "SER_UART_Write")--------0x404

RegRead(SER_ID, 0x404 , 1, upperword, lowword,"SER_UART_Read")  
----------------------------------########### phy_config = 0 (1x4)   invert_CSI_mode = 1	"
RegWrite(SER_ID, 0x330 ,1 ,0x00, 0x84	, "SER_UART_Write")--------0x330"
----------------------------------########### configure the MIPI Loopback
RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x08, "SER_UART_Write")--------0x370
RegWrite(SER_ID, 0x371 ,1 ,0x00, 0xA, "SER_UART_Write")--------0x371
RegWrite(SER_ID, 0x372 ,1 ,0x00, 0x80, "SER_UART_Write")--------0x372
RegWrite(SER_ID, 0x373 ,1 ,0x00, 0x0, "SER_UART_Write")--------0x373
----------------------------------########### Enable MIPI loopback TX/RX PRBSEN
    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x09, "SER_UART_Write")--------0x370
    wait(4ms)
    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x0B, "SER_UART_Write")--------0x370
    wait(4ms)
    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x0F, "SER_UART_Write")--------0x370
    wait(delay )
    RegRead(SER_ID, SR_MIPI_LPB4 , 1,lowword, reg_val_ser_bad,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
 
    for idx = 1 to sites do
        site = active_sites[idx]
         if reg_val_ser_bad[site] = 0x0 then         
             wait(10ms)
             RegRead(SER_ID, SR_MIPI_LPB4 , 1,lowword, reg_val_ser_bad,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
            wait(0)
         end_if
     end_for
    wait(200us)
--RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x07, "SER_UART_Write")--------0x370
    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x0B, "SER_UART_Write")--------0x370
    wait(delay)
    RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, reg_val_ser_good,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
    wait(200us)

    oreg_reg_val = fpga_read_register("FPGA1", SERDES_STATUS)                       ----Use Fpga to check lock. expect high or we can read out reg at DES 0xbcb
    wait(1ms)

---These for debug
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,0x6 , 1) 
-- RegRead(SER_ID, 0x1C9, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(SER_ID, 0x20c, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(SER_ID, 0x24F, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(DESA_ID, 0x0, 1, upperword, RegTx2_0,"SER_UART_Read")---292
-- RegRead(SER_ID, 0x407, 1, upperword, RegTx2_0,"SER_UART_Read")
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,0 , 1)
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,DR_GMSL1_CB , 1)

 wait(1ms)
---------------------------------------------------------------------------------------------------------------------------------------------

    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock[site]  = (integer(oreg_reg_val[site])  & 0x800  )   >>11  
        hibw_ft[site] = integer(HIBW)    
        bws_ft[site] = integer(BWS)    
        badpat_ft[site] = integer(reg_val_ser_bad[site])
        goodpat_ft[site] = integer(reg_val_ser_good[site])
    end_for    
wait(1ms)



-------------- Power Down ---------------------------


    if (POWERDOWN) then

------- turn off MIPI clocks from DES
            fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)         
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)    
         powerup_dnut_vdd_vterm(0.0,0.0) 
          wait(2mS)
            set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
            powerdown_device(POWERDOWN)
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS 
            open cbit  FB_RELAY
      end_if 


--------Data log
    test_value ilinklock with LinkLock
    
    test_value msfloat(gmsl1_forward_speed) with FW_SPD      
    test_value msfloat(MIPI_SPD) with CSI_SPD
    test_value (number_of_lanes_test) with NUMBER_LANES
 
    test_value hibw_ft with HIBW_FT  
    test_value bws_ft with BWS_FT  
    test_value badpat_ft with BadPat
    test_value goodpat_ft with GoodPat
     
 end_body





procedure LinkMargin(Vdd, Vddio, Vdd18,POWERDOWN,LnkMrgnLim , LnkMrgnChar)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in boolean          : POWERDOWN
in_out array of float_test      : LnkMrgnLim, LnkMrgnChar


local



  multisite lword   : LowerRdWord, UpperRdWord
  --multisite float : mbist_done_ppmu[1] , mbist_fail_ppmu[1]
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

 multisite lword    : RLMSA3_A,RLMSA3_B, RLMSA2_A,RLMSA2_B, RLM89_A,RLM89_B, RLM88_A, RLM88_B, RLM8A_A,RLM8A_B
 multisite lword    : DES_RLMSA3_A, DES_RLMSA3_B, DES_RLMSA2_A,DES_RLMSA2_B, DES_RLM89_A,DES_RLM89_B, DES_RLM88_A, DES_RLM88_B, DES_RLM8A_A,DES_RLM8A_B

 multisite lword    : RLMSC_A,RLMSC_B, RLMSD_A,RLMSD_B, RLMSE_A,RLMSE_B, RLMSF_A,RLMSF_B, RLMS10_A,RLMS10_B, RLMS11_A,RLMS11_B, RLMS13_A,RLMS13_B, RLMS2E_A,RLMS2E_B
 multisite lword    : DES_RLMSC_A,DES_RLMSC_B, DES_RLMSD_A,DES_RLMSD_B, DES_RLMSE_A,DES_RLMSE_B, DES_RLMSF_A,DES_RLMSF_B, DES_RLMS10_A,DES_RLMS10_B, DES_RLMS11_A,DES_RLMS11_B,DES_RLMS13_A,DES_RLMS13_B, DES_RLMS2E_A,DES_RLMS2E_B
 multisite lword    :  array1[26], array2[26]
    string[20]      :  infile[4],tempp

    multisite lword             : ser_read_data, des_read_data
    multisite word              : SerLock, DesLock
    multisite lword             : DfltSerTxAmp , DfltDesTxAmp
    multisite float             : RevChLnkMrgn ,  FwdChLnkMrgn
    multisite float             : testDlog[4]  ---- add linkB MT 2/2019

    lword                       : TxAmp, linkV
    boolean                     : DEBUG = false
    boolean                     : Search = true

    float                       : ErrClr

    boolean                     : allsitefail
    word list[MAX_SITES]        : actv
    word                        : sidx, nSites, s

    boolean                     : CHAR = False
    lword                       : vGB
    string[3]                   : testType



end_local


body
  

    LBDONE = 0  -- need initialize to fail first
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    

-----Dut power up function

    Set_SER_Voltages(Vddio, Vdd, Vdd18)    
    wait(2ms)

---------close CSI feedback loop
--    close cbit  FB_RELAY

   wait(5ms)  

   RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
   reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xCA expected   
   wait(0ms)

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      ireg_val_ser_good[site]  = integer(lowword[site])
    end_for 

  
    get_expr("OpVar_Char", CHAR)
    --CHAR = true

    -- Initialize GB based on test condition
    get_expr("OpVar_TestType", testType )

    -- guardband FT input by 10mV
    if testType = "QA" then
        vGB = 0
    else
        vGB = 1     -- 10mV
    end_if                

    actv = get_active_sites()
    nSites = word(len(actv))

    ErrClr = 25ms

    -- Read default TX amplitudes    
       RegRead(SER_ID, SR_RLMS95_A, 1, upperword, ser_read_data,"SER_UART_Read")
    DfltSerTxAmp = ser_read_data & 0x3F

    des_read_data = fpga_UART_Read ( "FPGA1" ,  "DES", DESA_ID  , DR_RLMS95_A    , 1 )
    DfltDesTxAmp = ser_read_data & 0x3F

    TxAmp = 0x29    --set initial amplitude

    -- Turn off Periodic Adapt on SER/DES

    RegWrite(SER_ID, SR_RLMSA4_A , 1, 16#00, 0x80, "SER_UART_Write") -- Default AEQ_PER_MULT[7:6] = 10, AEQ_PER[5:0] = 111101
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID , DR_RLMSA4_A         , 1 , 0x80 )

    -- Turn off EWM Width Monitor on SER/DES (RLMS1[0] = 0)  -- 0x4B default
    RegWrite(SER_ID, SR_RLMS4_A , 1, 16#00, 0x4A, "SER_UART_Write")
    fpga_UART_Write( "FPGA1" , "DES", DESA_ID ,    DR_RLMS4_A       , 1 , 0x4A )  -- 0x4B default

    -- Turn off Global Adapt on SER/DES ( AdaptEn[7] = 0)
   
    RegWrite(SER_ID, SR_RLMS3_A , 1, 16#00, 0x0A, "SER_UART_Write") -- 0x0A default
    fpga_I2C_Write( "FPGA1" , "DES", DESA_ID , DR_RLMS3_A          , 1 , 0x0A)  -- 0x0A default

    -- Turn on Manual TX on SER/DES-
    RegWrite(SER_ID, SR_RLMS95_A , 1, 16#00, 0xC0 |0x29, "SER_UART_Write")    -- default TxAmplManEn[7]=0 ADCSarMethod[6]=1 TxAmplMan[5:0]=101001 (41d)
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS95_A , 1 , 0xC0 | 0x29 )   -- default TxAmplManEn[7]=0 ADCSarMethod[6]=1 TxAmplMan[5:0]=101001 (41d)

    -- Clear Errors on SER/DES
    
    RegRead(SER_ID, SR_CNT0 , 1, upperword, ser_read_data,"SER_UART_Read") 
    des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT0, 1 )

--     if DEBUG then
--         debug_ReadBackAllRegister(SER_ID, false , "RLMS" )
--         debug_ReadBackAllRegister(DES_ID, false , "RLMS" )
--     end_if        


    --****************************************************************************************
    -- Reverse Channel Link Margin
    --
    -- The receiver under test is the Serializer. The transmitter of the Deserializer is
    -- lowered until errors are observed on the Serializer receiver.
    --****************************************************************************************

    -- Read errors on SER/DES
    RegRead(SER_ID, SR_CNT0 , 1, upperword, ser_read_data,"SER_UART_Read") 
    des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT0       , 1 )

    if DEBUG then
        println (stdout, "Check for Errors on SER/DES - Rev Chan Link Margin")
        println (stdout, "SER Errors ", ser_read_data[2]!h)
        println (stdout, "DES Errors ", des_read_data[2]!h)
    end_if        

    -- Check for RXDP_LOCK (CTRL3[6] should be 1)
    RegRead(SER_ID, SR_CTRL3 , 1, upperword, ser_read_data,"SER_UART_Read") 
    

    if DEBUG then
        println (stdout, "Check for RXDP_LOCK on SER - Rev Chan Link Margin")
        println (stdout, ser_read_data[1] & 0x20!h)
    end_if

    if CHAR then    -- search for link margin

        -- Loop to decrease DES TX amplititude - stop when SER error or RXDP_LOCK = 0
        allsitefail = false
        RevChLnkMrgn = 0.0
        while not(allsitefail) do
    
            -- Decrease DES TX amplitude (RLMS95 - TxAmplMan[5:0]) (by 1)

            fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS95_A         , 1 , 0x80 | TxAmp )
            wait(2ms)
        
            -- Turn on Global Adapt on SER
            RegWrite(SER_ID, SR_RLMS3_A , 1, 16#00, 0x1A, "SER_UART_Write")
            wait(2ms)

            -- Turn off Global Adapt on SER            
            RegWrite(SER_ID, SR_RLMS3_A , 1, 16#00, 0x0A, "SER_UART_Write")
            -- Check for LOCK (CTRL3[3] should be 1)
            RegRead(SER_ID, SR_CTRL3 , 1, upperword, ser_read_data,"SER_UART_Read")
            SerLock = word(ser_read_data & 0x08)

            -- Clear Errors on SER/DES
            
            RegRead(SER_ID, SR_CNT0 , 1, upperword, ser_read_data,"SER_UART_Read")
            des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT0       , 1 )
            wait(ErrClr)
        
            -- Read errors on SER/DES
            RegRead(SER_ID, SR_CNT0 , 1, upperword, ser_read_data,"SER_UART_Read")
            des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT0       , 1 )
            allsitefail = true
            for sidx = 1 to nSites do
                s = actv[sidx]
                if ser_read_data[s] > 0 and RevChLnkMrgn[s] = 0.0 then
                    RevChLnkMrgn[s] = float(DfltDesTxAmp[s] - (TxAmp + 1)) * 10mV
                else_if RevChLnkMrgn[s] == 0.0 then
                    allsitefail = false
                end_if
            end_for

            if TxAmp < 5 then    -- Safety exit
                allsitefail = true
            end_if

            TxAmp = TxAmp - 1     -- Decrease amplitude

        end_while

        -- Rev Chan Link Margin
        scatter_1d ( RevChLnkMrgn , testDlog , 1 )

        -- Reset Device (get ready for Fwd Chan Link Margin Test
        RegWrite(SER_ID, SR_RLMS95_A , 1, 16#00, 0xC0 | DfltSerTxAmp[actv[1]], "SER_UART_Write") -----    DfltSerTxAmp[1]   
        fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS95_A         , 1 , 0xC0 | DfltDesTxAmp[actv[1]] )-----    DfltSerTxAmp[1] 

        -- Turn on Global Adapt on SER
        RegWrite(SER_ID, SR_RLMS3_A , 1, 16#00, 0x1A, "SER_UART_Write")
        wait(20ms)

        -- Turn off Global Adapt on SER
        RegWrite(SER_ID, SR_RLMS3_A , 1, 16#00, 0x0A, "SER_UART_Write")

        -- Read errors on SER/DES
        RegRead(SER_ID, SR_CNT0 , 1, upperword, ser_read_data,"SER_UART_Read")      
        des_read_data = fpga_I2C_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT0       , 1 )

        if DEBUG then
            println (stdout, "Check for Errors on SER/DES - Fwd Chan Link Margin")
            println (stdout, "SER Errors ", ser_read_data[1]!h)
            println (stdout, "DES Errors ", des_read_data[1]!h)
        end_if        

        -- Check for LOCK (should be 0xDA)
        RegRead(SER_ID, SR_CTRL3 , 1, upperword, ser_read_data,"SER_UART_Read")
        if DEBUG then
            println (stdout, "Check for RXDP_LOCK on SER - Fwd Chan Link Margin")
            println (stdout, ser_read_data[2] & 0x20!h)
        end_if

        -- Loop to decrease SER TX amplititude - stop when SER error or RXDP_LOCK = 0
        TxAmp = 0x29    --set initial amplitude
        allsitefail = false
        FwdChLnkMrgn = 0.0
        while not(allsitefail) do
    
            -- Decrease SER TX amplitude (RLMS95 - TxAmplMan[5:0]) (by 1)
            RegWrite(SER_ID, SR_RLMS95_A , 1, 16#00,0x80 | TxAmp , "SER_UART_Write")
            wait(1ms)
        
            -- Turn on Global Adapt on DES

            fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS3_A          , 1 , 0x1A )
            wait(1ms)

            -- Turn off Global Adapt on DES
            fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS3_A          , 1 , 0x0A )
        
            -- Check for LOCK (CTRL3[3] should be 1)
            des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID , DR_CTRL3      , 1 )
            DesLock = word(des_read_data & 0x08)

            -- Clear Errors on SER/DES
            RegRead(SER_ID, SR_CNT0 , 1, upperword, ser_read_data,"SER_UART_Read")            
            des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT0       , 1 )
            wait(ErrClr)
        
            -- Read errors on SER/DES
            RegRead(SER_ID, SR_CNT0 , 1, upperword, ser_read_data,"SER_UART_Read")            
            des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT0       , 1 )
        
            allsitefail = true
            for sidx = 1 to nSites do
                s = actv[sidx]
                if des_read_data[s] > 0 and FwdChLnkMrgn[s] = 0.0 then
                    FwdChLnkMrgn[s] = float(DfltSerTxAmp[s] - (TxAmp + 1)) * 10mV
                else_if FwdChLnkMrgn[s] == 0.0 then
                    allsitefail = false
                end_if
            end_for

            if TxAmp < 5 then    -- Safety exit
                allsitefail = true
            end_if

            TxAmp = TxAmp - 1     -- Decrease amplitude

        end_while

        -- FWD Chan Link Margin
        scatter_1d ( FwdChLnkMrgn , testDlog , 2 )

        -- Report results
        test_value testDlog with LnkMrgnChar

    else    -- production GNG test
------------This is for link A    
        -- Reverse path link margin
-----Per Umut use Default value for linkmargin 2-1019
------------
--        linkV = 26 - vGB
-- 
--         -- Set DES TX amplitude (RLMS95 - TxAmplMan[5:0]) 
--         fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS95_A         , 1 , 0x80 | linkV )
         fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS95_A         , 1 , 0x69)
         RegWrite(SER_ID, SR_RLMS95_A , 1, 0x00, 0x69 , "SER_UART_Write")

         wait(2ms)
       
        -- Turn on Global Adapt on SER
        RegWrite(SER_ID, SR_RLMS3_A , 1, 0x00, 0x1A , "SER_UART_Write")        
        wait(20ms)

        -- Turn off Global Adapt on SER

       RegWrite(SER_ID, SR_RLMS3_A , 1, 0x00, 0x0A , "SER_UART_Write")        
        
---------        -- Check for LOCK (CTRL3[3] should be 1)
        RegRead(SER_ID, SR_CTRL3 , 1, upperword, ser_read_data,"SER_UART_Read")        
        SerLock = word(ser_read_data & 0x08)

        -- Clear Errors on SER/DES
        RegRead(SER_ID, SR_CNT0 , 1, upperword, ser_read_data,"SER_UART_Read") 
        des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT0       , 1 )
        wait(ErrClr)
        
        -- Read errors on SER/DES
        RegRead(SER_ID, SR_CNT0 , 1, upperword, ser_read_data,"SER_UART_Read")
    
        RevChLnkMrgn = float(ser_read_data)
        scatter_1d ( RevChLnkMrgn , testDlog , 1 )

        -- Reset DES TX amplitude (RLMS95 - TxAmplMan[5:0]) 
        fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS95_A         , 1 , 0x80 | TxAmp )
        wait(2ms)


        -- Forward path link margin
        linkV = TxAmp-----26 - vGB
------Per umut use default value
--         -- Decrease SER TX amplitude (RLMS95 - TxAmplMan[5:0]) (by 1)
         RegWrite(SER_ID, SR_RLMS95_A , 1, 0x00, 0x80 | TxAmp , "SER_UART_Write")
--         wait(1ms)
        
        -- Turn on Global Adapt on DES
        fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS3_A          , 1 , 0x1A )
        wait(1ms)

        -- Turn off Global Adapt on DES
        fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS3_A          , 1 , 0x0A )
        
        -- Check for LOCK (CTRL3[3] should be 1)
        des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID , DR_CTRL3      , 1 )
        DesLock = word(des_read_data & 0x08)

        -- Clear Errors on SER/DES
        RegRead(SER_ID, SR_CNT0 , 1, upperword, ser_read_data,"SER_UART_Read")       
        des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT0       , 1 )
        wait(ErrClr)
        
        -- Read errors on SER/DES
        des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT0       , 1 )

        FwdChLnkMrgn = float(des_read_data)
        scatter_1d ( FwdChLnkMrgn , testDlog , 2 )

        -- Reset SER TX amplitude (RLMS95 - TxAmplMan[5:0]) 
         RegWrite(SER_ID, SR_RLMS95_A , 1, 0x00, 0x80 | TxAmp , "SER_UART_Write")

--------------------Change to link B per Umut's request 2-2019 MT.
        -- Reverse path link margin
        linkV = TxAmp ------ vGB

        fpga_UART_Write("FPGA1","DES", DESA_ID, SR_CTRL0, 1, 16#02) 
        RegWrite(SER_ID, SR_CTRL0, 1, 16#00, 16#22, "SER_UART_Write")    ---- only link B
        wait(30ms)
        RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xEA          
        reg_val15  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x13, 1)   -- DES lock bit, 0xEA expected   
-------Per Umut test link margin at default value
--         -- Set DES TX amplitude (RLMS95 - TxAmplMan[5:0]) 
--         fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS95_B , 1 , 0x80 | linkV )
--         des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_RLMS95_B , 1 )
--          fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS95_B , 1 , 0x29 )
--          RegRead(SER_ID, DR_RLMS95_B , 1, upperword, ser_read_data,"SER_UART_Read")   
--         wait(2ms)
        
        -- Turn on Global Adapt on SER
        RegWrite(SER_ID, SR_RLMS3_B , 1, 0x00, 0x1A , "SER_UART_Write")        
        wait(2ms)

        -- Turn off Global Adapt on SER

       RegWrite(SER_ID, SR_RLMS3_B , 1, 0x00, 0x0A , "SER_UART_Write")                
        -- Check for LOCK (CTRL3[3] should be 1)
        RegRead(SER_ID, SR_CTRL3 , 1, upperword, ser_read_data,"SER_UART_Read")        
        SerLock = word(ser_read_data & 0x08)

        -- Clear Errors on SER/DES
        RegRead(SER_ID, SR_CNT1 , 1, upperword, ser_read_data,"SER_UART_Read") 
        des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT1 , 1 )
        wait(ErrClr)
        
        -- Read errors on SER/DES
        RegRead(SER_ID, SR_CNT1 , 1, upperword, ser_read_data,"SER_UART_Read")
    
        RevChLnkMrgn = float(ser_read_data)
        scatter_1d ( RevChLnkMrgn , testDlog , 3 )

        -- Reset DES TX amplitude (RLMS95 - TxAmplMan[5:0]) 
        fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS95_B , 1 , 0x80 | TxAmp )
        wait(2ms)

        -- Forward path link margin
        linkV =  TxAmp--26 - vGB
-------Per umut test with default value
--         -- Decrease SER TX amplitude (RLMS95 - TxAmplMan[5:0]) (by 1)
--        RegWrite(SER_ID, SR_RLMS95_B , 1, 0x00, 0x80 | linkV , "SER_UART_Write")
--         wait(1ms)
        
        -- Turn on Global Adapt on DES
        fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS3_B          , 1 , 0x1A )
        wait(1ms)

        -- Turn off Global Adapt on DES
        fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_RLMS3_B          , 1 , 0x0A )
        
        -- Check for LOCK (CTRL3[3] should be 1)
        des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID , DR_CTRL3      , 1 )
        DesLock = word(des_read_data & 0x08)

        -- Clear Errors on SER/DES
        RegRead(SER_ID, SR_CNT1 , 1, upperword, ser_read_data,"SER_UART_Read")       
        des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT1       , 1 )
        wait(ErrClr)
        
        -- Read errors on SER/DES
        des_read_data = fpga_UART_Read ( "FPGA1" , "DES" , DESA_ID  , DR_CNT1       , 1 )

        FwdChLnkMrgn = float(des_read_data)
        scatter_1d ( FwdChLnkMrgn , testDlog , 4)


        -- Report results
        test_value testDlog with LnkMrgnLim
    end_if


-- 
--       
-- 
--    -- turn off MIPI clocks from DES
--    fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)            
   -- reg_val23  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0x0330, 1)
   -- loop back relays on LB opened
--   fpga_cbit_control("FPGA1", 2#0000)      -- control FPGA cbits 2#0000  (cb4, cb3, cb2, cb1)   
--      open cbit CB2_SLDC                 --OVI_RELAYS 
--      open cbit COAXB_M_RELAY            --OVI_RELAYS
--      open cbit  FB_RELAY
-------------- Power Down ---------------------------
    if (POWERDOWN) then

--        set digital pin ALL_PATTERN_PINS - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
--        powerdown_device(POWERDOWN)
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)
        open cbit CB2_SLDC                 --OVI_RELAYS 
        open cbit COAXB_M_RELAY            --OVI_RELAYS
         open cbit  FB_RELAY
        open cbit  FB_RELAY
        open cbit  DNUT_RXTX_RELAY
        
         powerdown_device(POWERDOWN)
    end_if 
    
--     test_value ireg_val_ser_bad  with bad_pat_it 
--     test_value ireg_val_ser_good with good_pat_it          
--     test_value MIPI_SPD with CSI_SPD
--     test_value number_of_lanes_test with NUMBER_LANES


 end_body



procedure GmslVolVohABUS_1(Vdd,  Vdd18, Vddio, VoutTest, VoutDeltaTest,VodHTest, VcmHTest, VcmDeltaTest,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
in float           : Vdd, Vdd18, Vddio
in_out float_test  : VoutTest, VoutDeltaTest,VodHTest, VcmHTest, VcmDeltaTest   -------------VodDeltaTest,
in boolean         : POWERUP,POWERDOWN
local
  multisite float : TxPHMeas[2], TxPLMeas[2], TxNHMeas[2], TxNLMeas[2]
  multisite float : VodH[4], VodL[4], Vod[4], VodDelta[4], VcmH[4], VcmL[10], Vcm[4], VcmDelta[10],Vout[4], VoutDelta[2]
  multisite float : TxPDisMeas[2], TxNDisMeas[2], TxDis[4]
  PIN LIST[2]     : MeasVi16P, MeasVi16N
  word            : CurSite
  lword           : Reg1Value, Junk
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword
  multisite float : SIOAP_MeasH, SIOAP_MeasL, SIOAN_MeasH, SIOAN_MeasL,SIOBP_MeasH, SIOBN_MeasL,SIOBP_MeasL,SIOBN_MeasH
end_local

body
  active_sites = get_active_sites
  sites = word(len(active_sites))
  
  -- setup some pin lists to make cadence statements more readable maybe move to global pin groups
    MeasVi16N = SER_ABUS3       ---------- DC_SE_M_A_VI + DC_SE_M_B_VI                 --DES_TXOUT0_N_SIOA_N_VI16+DES_TXOUT1_N_SIOB_N_VI16
    MeasVi16P = SER_ABUS1       ------- DC_SE_P_A_VI + DC_SE_P_B_VI                 --DES_TXOUT0_P_SIOA_P_VI16+DES_TXOUT1_P_SIOB_P_VI16

--     set digital pin SER_GPO4_CFG0  + SER_GPO6_CFG2 levels to vil Vconf0 vih Vddio   -- TP/UART mode with DEV_ID = 0x80
--     set digital pin  SER_GPO5_CFG1 levels to vil Vconf1 vih Vddio                    ---GMSL2 mode  AND COAX
    close cbit DC_K7 
    close cbit COAXB_P_RELAY + COAXB_M_RELAY ---Connecto DC circuit
    fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
    fpga_set_UART_Frequency("FPGA1", 1MHz)
    wait(1ms)
----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)

---debug in what mode    
    RegRead(SER_ID,SR_REG6 , 1, RdWordUpper, RdWordLower, "SER_UART_Read")

----Disconnect DP from SIOA/SIOB
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from dcl
    disconnect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP from ppmu

  -- Setup the analog hardware that will be used to measure the LVDS output pin voltages
  set vi16 chan MeasVi16P+MeasVi16N to fi 10pA max 5mA measure v max 2V clamp vmax 2V vmin 0V
  gate vi16 chan MeasVi16P+MeasVi16N on
  connect vi16 chan MeasVi16P+MeasVi16N remote hot switch

  -- setup other two ABUS VI16's so they don't load pins/interfere with measurements.
  set vi16 chan SER_ABUS0 +SER_ABUS2 to fi 1.0uA max 5uA measure v max 4V clamp vmax 4V vmin 0V  -- DEGLITCH RELATED: set clamp to 4V so that 3.6V output on GPIO14 which occurs before entering test mode 14 does not get clamped by VI16. Also set current to > 500nA to help prevent the negative glitch.
  gate vi16 chan SER_ABUS0 +SER_ABUS2 on
  connect vi16 chan SER_ABUS0 +SER_ABUS2 remote hot switch
----Connect Abus VI to GMSL link
    close cbit    ABUS_RELAY           ---------- connect the ABUS GPIO to the VI16 resources
    close cbit   MFP_LT_RELAY 
    close  cbit  I2C_LT_CB  + MFP_LT_K12_RELAY ----Using FPGA to communicate
    wait(5mS)
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################

--WH:FOLLOWUP 
  --  Disable Outputs and measure disabled voltage prior to output tests

--  RegWrite(SER_ID, SR_CTRL7, 1, 0, 16#81, "SER_UART_Write")
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_CTRL7, 1,16#81) 

  wait(5ms)
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into TxPDisMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into TxNDisMeas




-- DEBUG CODE 
-- RegRead(SER_ID, SR_RLMS95_A, 1, RdWordUpper, RdWordLower, "dut_uart_read") -- check Tx swing value. multiply by 10mV to get target swing.
-- wait(0s)
-- DEBUG CODE
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################
-- ########################################################################################




  -- Set the outputs to logic high
--   RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#29, "SER_UART_Write")
--   RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#29, "SER_UART_Write")
--   RegWrite(SER_ID, SR_CTRL0, 1, 0, 16#20, "SER_UART_Write")

  fpga_UART_Write("FPGA1","SER", SER_ID, SR_RLMS48_A, 1,16#29) 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_RLMS48_B, 1,16#29) 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_CTRL0, 1,16#20)
  
--  SetTestMode(11, False, "dut_uart_write")  -- DEGLITCH RELATED. TestMode14 is less prone to glitching when entering test mode, compared with TestMode11
    SetTestModeFPGA(14, False, "SER_UART_Write")  
 
-- RegWrite(SER_ID, SR_TEST0, 1, 0, 16#89, "SER_UART_Write")  -- Select the PHYA block
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_TEST0, 1,16#89)

  set vi16 chan MeasVi16P+MeasVi16N to fi 10pA max 5uA measure v max 2V clamp vmax 2V vmin 0V  -- DEGLITCH RELATED set VI16 back to 10pA forecd current after selecting PHYA.
  wait(20ms)

  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into SIOAP_MeasH--TxPHMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into SIOAN_MeasL

--  RegWrite(SER_ID, SR_TEST0, 1, 0, 16#99, "SER_UART_Write")  -- Select the PHYB block 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_TEST0, 1,16#99)  -- Select the PHYB block 

  wait(2ms)
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into SIOBP_MeasH
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into SIOBN_MeasL

-----  --  Set the outputs in a low state
--   RegWrite(SER_ID, SR_RLMS48_A, 1, 0, 16#2A, "SER_UART_Write")
--   RegWrite(SER_ID, SR_RLMS48_B, 1, 0, 16#2A, "SER_UART_Write")
 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_RLMS48_A, 1,16#2A)  -- Set the PHYB Low 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_RLMS48_B, 1,16#2A)  -- Set the PHYB Low 

------------------RegRead(DUT_ID, SR_RLMS95_A, 1, RdWordUpper, RdWordLower, "dut_uart_read")
    --RegWrite(SER_ID, SR_TEST0, 1, 0, 16#89, "SER_UART_Write")  -- Select the PHYA block 
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_TEST0, 1,16#89)  -- Select the PHYA block 
  
  wait(15ms)
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into SIOAP_MeasL
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into SIOAN_MeasH

--RegWrite(SER_ID, SR_TEST0, 1, 0, 16#99, "SER_UART_Write")  -- Select the PHYB block
  fpga_UART_Write("FPGA1","SER", SER_ID, SR_TEST0, 1,16#99)  -- Select the PHYB block 
 
    wait(500us)

--  wait(5ms)
  measure vi16 v on chan MeasVi16P for 20 samples every 10us averaged into  SIOBP_MeasL--TxPLMeas
  measure vi16 v on chan MeasVi16N for 20 samples every 10us averaged into  SIOBN_MeasH--TxNHMeas

  disconnect vi16 chan MeasVi16P+MeasVi16N
  set vi16 chan MeasVi16P+MeasVi16N to fv 0V max 4V measure i max 100mA clamp imax 100mA imin -100mA
--  gate vi16 chan MeasVi16P+MeasVi16N off
  
 -----------------------
---------power down 
  set digital pin ALL_PATTERN_PINS levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
  wait(500us)
  open  cbit    ABUS_RELAY 
--  open cbit CB2_SLDC + CB1_SLDC  ---Connecto DC circuit
  open cbit COAXB_P_RELAY + COAXB_M_RELAY ---Connecto DC circuit
  connect digital pin SER_SIOAN + SER_SIOAP + SER_SIOBN + SER_SIOBP to dcl
  open cbit DC_K7 
  open  cbit   MFP_LT_RELAY  + MFP_LT_K12_RELAY
  open  cbit  I2C_LT_CB   ----Using FPGA to communicate


      powerdown_device(POWERDOWN)


----Datalog


  -- Calculate the VOD, VCM and complimetary differences, store into single variables or all I/O  
  -- I/O Order TXOUTA_0, TXOUTA_1, TXOUTA_2, TXOUTA_3, TXCLKA, TXOUTB_0, TXOUTB_1, TXOUTB_2, TXOUTB_3, TXCLKB
  for idx = 1 to sites do
    CurSite = active_sites[idx]
----New definition as Jon Rose spec
      Vout[CurSite, 1] = SIOAP_MeasH[CurSite] - SIOAP_MeasL[CurSite]         -- SIOA_P  same as VOD in GMSL1 previous product
      Vout[CurSite, 2] = SIOAN_MeasH[CurSite] - SIOAN_MeasL[CurSite]         -- SIOA_N
      Vout[CurSite, 3] = SIOBP_MeasH[CurSite] - SIOBP_MeasL[CurSite]         -- SIOB_P
      Vout[CurSite, 4] = SIOBN_MeasH[CurSite] - SIOBN_MeasL[CurSite]         -- SIOB_N
      
      VoutDelta[CurSite, 1] = Vout[CurSite, 1] - Vout[CurSite, 2]
      VoutDelta[CurSite, 2] = Vout[CurSite, 3] - Vout[CurSite,4]

-----      Vod = (VPH -VPL )+ (VNH-VNL) definition is changed
      Vod[CurSite, 1] = Vout[CurSite,1] + Vout[CurSite, 2]                      -- SIOA
      Vod[CurSite, 2] = Vout[CurSite, 3] +  Vout[CurSite, 4]       -- SIOB 

--       Vod[CurSite, 2] = TxNHMeas[CurSite, 1] - TxNLMeas[CurSite, 1]         -- SIOA_N
--       Vod[CurSite, 3] = TxPHMeas[CurSite, 2] - TxPLMeas[CurSite, 2]         -- SIOB_P
--       Vod[CurSite, 4] = TxNHMeas[CurSite, 2] - TxNLMeas[CurSite, 2]         -- SIOB_N
--       VodDelta[CurSite, 1] = Vod[CurSite, 1] - Vod[CurSite, 2]
--       VodDelta[CurSite, 2] = Vod[CurSite, 3] - Vod[CurSite,4]

      Vcm[CurSite, 1] =  (SIOAP_MeasH[CurSite] + SIOAP_MeasL[CurSite])/2.0   -- SIOA_P
      Vcm[CurSite, 2] =  (SIOAN_MeasH[CurSite] + SIOAN_MeasL[CurSite])/2.0   -- SIOA_N
      Vcm[CurSite, 3] =  (SIOBP_MeasH[CurSite] + SIOBP_MeasL[CurSite])/2.0   -- SIOB_P
      Vcm[CurSite, 4] =  (SIOBN_MeasH[CurSite] + SIOBN_MeasL[CurSite])/2.0   -- SIOB_N
      VcmDelta[CurSite, 1] = Vcm[CurSite, 1] - Vcm[CurSite, 2]  
      VcmDelta[CurSite, 2] = Vcm[CurSite, 3] - Vcm[CurSite, 4]  

--       TxDis[CurSite,1] = TxPDisMeas[CurSite,1]
--       TxDis[CurSite,2] = TxNDisMeas[CurSite,1]
--       TxDis[CurSite,3] = TxPDisMeas[CurSite,2]
--       TxDis[CurSite,4] = TxNDisMeas[CurSite,2]
   endfor

  -- Datalog Tests
  test_value Vout with VoutTest
  test_value VoutDelta with VoutDeltaTest
  test_value Vod with VodHTest
--  test_value VodDelta with VodDeltaTest
  test_value Vcm with VcmHTest
  test_value VcmDelta with VcmDeltaTest
    
end_body
procedure Isupply1X4_1188Mbs(Vdd, Vddio, Vdd18, POWERUP,POWERDOWN, HDCP,Link,need_reset,TP_COAX,TX_SPD,RX_SPD,MIPI_SPD,CSI_MODE,NUMB_LANES,Link_Lock_dly,LinkLock,FW_SPD,RW_SPD,CSI_SPD,NUMBER_LANES,DesRx8_1,SerTx2_0,DesRx8_2,SerTx2_1,VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP,VddI_1p26,VddI_1p26_HDCP)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in_out integer_test : NUMBER_LANES
in boolean          : POWERUP,POWERDOWN,need_reset, HDCP
in string[20]       : TP_COAX,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,MIPI_SPD,Link_Lock_dly
in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,RW_SPD,CSI_SPD
in_out integer_test : DesRx8_1,SerTx2_0,DesRx8_2,SerTx2_1,LinkLock
in_out float_test   : VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP,VddI_1p26,VddI_1p26_HDCP
in string[2]        : Link
local



  multisite lword   : LowerRdWord, UpperRdWord
 
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, RegTx2_0, RegTx2_1,desrx8_1,desrx8_2  --, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ilinklock  , number_of_lanes_test,  iRegTx2_0, iRegTx2_1,idesrx8_1,idesrx8_2      ----ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
--  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    string[20]      :  infile[4],tempp, MPW
    multisite float : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1],i_vdd_1p26_meas[1]
    multisite float : i_vdd_meas_hdcp[1] , i_vdd18_meas_hdcp[1] , i_vddio_meas_hdcp[1] ,read_Ivddio[1,1024],i_vdd_1p26_meas_hdcp[1]

    boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount,count
end_local


body
    loopcont  = true
   SiteCheck  = false 
    MPW = "MPW5"
    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function
     if vdd_global[2] > 1.05 then
        set hcovi SER_VDD  to fv 1.2 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
        wait(2ms)
        set hcovi SER_VDD  to fv 1.15 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
        wait(2ms)        
        set hcovi SER_VDD  to fv 1.1 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
        wait(5ms)
       vdd_global[2]  = 1.1
     end_if   
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)

   if (need_reset) then
---Close relay to connect FPGA to control TX/RX on DNUT
        close cbit  DNUT_RXTX_RELAY
 ---Set uart or I2C freq for communication    
        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
        powerup_dnut_vdd_vterm(1.2,1.2)
        wait(1ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
        wait(5ms)

-----    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg     
-----     reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read   for debug 
 

    
 ---------close CSI feedback loop
        close cbit  FB_RELAY

----Set SER and DES for coax or tp mode
        if TP_COAX = "TP" then
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS           
        else
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
            close cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS

        end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

        if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
        elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

        if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
        elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
        elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
        end_if 
        ser_link_speed_code = ser_rx_speed + ser_tx_speed
        des_link_speed_code = des_rx_speed + des_tx_speed

----Program link rate

        RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed

        wait(10ms)     ------needed otherwise has to wait more than 100mS after oneshot command to lock


-----Write to reg10 to update link speed setting 

        if Link = "A" or Link = "a" then
            RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#21, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89      
        elseif Link ="B" or Link = "b" then
            RegWrite(SER_ID, SR_CTRL0, 1, 16#20, 16#22, "SER_UART_Write")    
        else  -----both link
               fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1,0x00  )             ---- DES GMSL link dual
               RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#30, "SER_UART_Write") 

        end_if
   
        RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)

---------------------------------------------------------------------------------------------------------------------------------------------

        wait(10ms)
--        wait(Link_Lock_dly + 10mS+ 10mS)   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
    end_if   ----- from reset if statement        
-----Check for link lock 
        RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          
    while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  (lowword[site] = 0xde  OR lowword[site] =0xda  OR lowword[site] =0xCa OR lowword[site] =0xCE OR lowword[site] =0xEa OR lowword[site] =0xEE) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true     
                end_if
                if sitecount = sites then
                    loopcont = false
                end_if     
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
            if loopcont  then
                wait(1ms)
                RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
            end_if
            
        end_for            
 
    end_while
 

---Turn off Adapter EQ periodic
    RegWrite(SER_ID, SR_RLMS4_A ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMS4_B ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x15A4

    RegWrite(SER_ID, SR_RLMSA4_A ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMSA4_B ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x15A4

wait(0)
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock[site]  = integer(lowword[site])       
    end_for    

------Call function to generate color bar 1 to pipeline X
    if  Link = "A" or Link = "a" then
            GenerateColorBar1PipeLineX1x4_1188("A")
    elseif  Link = "B" or Link = "b" then
            GenerateColorBar1PipeLineX1x4_1188("B")    
    else
--    if Link = "AB" or Link = "ab"    then                                ----Dual links mode
        GenerateColorBarPipeLine2x4_1188
    end_if

    --- force CSI clk out on HS94
    --- force_CSI_out_en = 1	------ Force CSI clock out at the end eleminate 80mS delay for Reg11A update to right value 0x82 
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_PHY0 , 1, 0x84)

--         RegRead(SER_ID,0x16b7 , 1, upperword, lowword,"SER_UART_Read")

--------------- read back value to make sure ser has pclk and des does have video lock
    wait(5ms)  ----Need about 10ms for readout correctly
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")    ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    desrx8_1  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_1, 1)      -- lockbit expect 0x62  0x11A
wait(2ms)  ----Need about 10ms for readout correctly
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    desrx8_1  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_1, 1)      -- lockbit expect 0x62  0x11A
-------Just for debug
--     for idx = 1  to sites do
--         site = active_sites[idx]
--         if desrx8_1[site] <> 0x62 or RegTx2_0[site] <> 138 then
--                wait(0)
--          end_if
--    end_for          
    if Link = "AB" or Link = "ab"    then    
        desrx8_2  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_0, 1)      -- lockbit expect 0x62---108 
        desrx8_2  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_0, 1)      -- lockbit expect 0x62---108 
        wait(1ms)
        desrx8_2  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_0, 1)      -- lockbit expect 0x62
        RegRead(SER_ID, SR_VIDEO_TX2_2, 1, upperword, RegTx2_1,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A    
        RegRead(SER_ID, SR_VIDEO_TX2_2, 1, upperword, RegTx2_1,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    end_if
------------Measure current

          if POWERUP then
        set hcovi SER_VDDIO to fv Vddio vmax 4V measure i max 1mA clamp imax 5mA imin 5mA  ---- reduce current
        --wait(50mS) 

   end_if
    wait(5mS) ----needed for Vdd18 current stable--50
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas
--    measure hcovi i on SER_VDDIO for 2048 samples every 1ms  into read_Ivddio keep previous

---Change VDD to 1.26V for measure second set
    set hcovi SER_VDD to fv 1.26 vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
    wait(2ms)
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas
 wait(2ms)
    if HDCP then  --- turn on HDCP from ser
--          RegWrite(SER_ID, 16#1677 ,1, 0x0, 0x06	, "SER_UART_Write")
--         RegWrite(SER_ID, 0x16B8,1,0x0, 0x01, "SER_UART_Write" )
--         RegWrite(SER_ID, 16#16b9 ,1, 0x0, 0x90	, "SER_UART_Write")
--         RegWrite(SER_ID, 0x16B7,1,0x0, 0x40, "SER_UART_Write" )



           if Link = "A" then
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 0x1695 ,1, 0x0, 0x43	, "SER_UART_Write")                
           elseif Link  = "B" then
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           else
               RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")                
               RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x43	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           end_if    

------------Measure current in HDCP mode
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas_hdcp    ----Vdd has been change to 1.26V
        measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_hdcp
        measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_hdcp

---Change VDD back to set value for measure second set
        set hcovi SER_VDD to fv Vdd vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
        wait(5ms)
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_hdcp

-----Turn off HDCP
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0xC0	, "SER_UART_Write")                
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0xC0	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x2	, "SER_UART_Write")  
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x2	, "SER_UART_Write")
    end_if


-------------- Power Down ---------------------------
----datalog DesLockbit and serPclk bit
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        idesrx8_1[site]  = integer(desrx8_1[site])       
        iRegTx2_0[site]  = integer(RegTx2_0[site])
        if Link ="AB" or Link = "ab"    then
            idesrx8_2[site]  = integer(desrx8_2[site])       
            iRegTx2_1[site]  = integer(RegTx2_1[site])
       end_if  
    end_for    


    if (POWERDOWN) then

------- turn off MIPI clocks from DES
            fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)         
--         fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)    
--          powerup_dnut_vdd_vterm(0.0,0.0) 
--           wait(20mS)
            set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
            powerdown_device(POWERDOWN)
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS 
            open cbit  FB_RELAY
      end_if 


--------Data log
    test_value ilinklock with LinkLock
    
    test_value msfloat(TX_SPD) with FW_SPD     
    test_value msfloat(RX_SPD) with RW_SPD  
    test_value msfloat(MIPI_SPD) with CSI_SPD
    test_value number_of_lanes_test with NUMBER_LANES
    
    test_value idesrx8_1 with DesRx8_1
    test_value iRegTx2_0 with SerTx2_0
    if Link = "AB" or Link = "ab" then
        test_value idesrx8_2 with DesRx8_2
        test_value iRegTx2_1 with SerTx2_1    
    end_if     
    test_value i_vddio_meas with VddioI  
    test_value i_vdd18_meas with Vdd18I
    test_value i_vdd_meas with VddI
    test_value i_vdd_1p26_meas with VddI_1p26
    if HDCP then    
        test_value i_vddio_meas_hdcp with VddioI_HDCP  
        test_value i_vdd18_meas_hdcp with Vdd18I_HDCP
        test_value i_vdd_meas_hdcp with VddI_HDCP
        test_value i_vdd_1p26_meas_hdcp with VddI_1p26_HDCP       
     end_if
     
 end_body





procedure LoopBackGmsl1_UART_I2C(Vdd, Vddio, Vdd18, POWERUP,POWERDOWN,Link,need_reset,TP_COAX,MIPI_SPD,MipiPort,NUMB_LANES,BWS,HIBW,delay,LinkLock,CSI_SPD,SerUart,DesUart,SerI2C,DesI2C,SSEN,HIM,RevFast,Freq)
--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18,delay,Freq
in_out integer_test : SerUart,DesUart,SerI2C,DesI2C
in boolean          : POWERUP,POWERDOWN,need_reset,HIM,RevFast
in string[20]       : TP_COAX, MipiPort                    -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : MIPI_SPD ,SSEN 
in lword            : NUMB_LANES  ,BWS,HIBW                       ----- number of CSI lanes 1 to 4    
in_out float_test   :CSI_SPD
in_out integer_test : LinkLock
--in_out float_test   : HIBW_FT,BWS_FT--VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP
in string[2]        : Link
local



  multisite lword   : LowerRdWord, UpperRdWord
 
 
   
  multisite integer : LBDONE
  float             : gmsl1_forward_speed ---Vconf0, Vconf1,
  multisite lword   : lowword, upperword, RegTx2_0, RegTx2_1,desrx8_1,desrx8_2  

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ilinklock  , number_of_lanes_test,  iRegTx2_0, iRegTx2_1,idesrx8_1,idesrx8_2  ,badpat_ft,goodpat_ft    ----ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
--  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    string[20]        :  infile[4],tempp, MPW
    multisite float   : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1]
    multisite float   : i_vdd_meas_hdcp[1] , i_vdd18_meas_hdcp[1] , i_vddio_meas_hdcp[1] ,read_Ivddio[1,1024],  vdd_sw[1]
    multisite integer :SerUartft,DesUartft, SerI2Cft,DesI2Cft
    multisite lword   : ser_read_reg1,ser_read_reg2,des_read_reg1,des_read_reg2

end_local


body
  
    MPW = "MPW5"
    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    gmsl1_forward_speed  = float((BWS*10) + 30) * MIPI_SPD * float(NUMB_LANES) /24.0
    mipi_speed  = lword(MIPI_SPD/100.0e6)
 
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function

    DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
--    RegRead(SER_ID,0x06 , 1, upperword, lowword,"SER_UART_Read")

   if (need_reset) then
---Close relay to connect FPGA to control TX/RX on DNUT
        close cbit  DNUT_RXTX_RELAY +  MFP_LT_K12_RELAY  + I2C_LT_CB

 ---Set uart or I2C freq for communication    
        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
        powerup_dnut_vdd_vterm(1.2,1.2)
        wait(1ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
        wait(5ms)

-----    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg     
-----     reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read   for debug 
 
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG6, 1, 0x0B)
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,DR_REG6 , 1) 
 ---------close CSI feedback loop
        close cbit  FB_RELAY

----Set SER and DES for coax or tp mode
        if TP_COAX = "TP" then
--            RegWrite(SER_ID, SR_CTRL1, 1, 16#00, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","SER", SER_ID, SR_CTRL1, 1, 0x0A)               ---- TP mode SR_CTRL1  =0X11    
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS           
        else
--            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","SER", SER_ID, SR_CTRL1, 1, 0x0F)  
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
            close cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS
            wait(5ms)
        end_if 

--------------Here

---enable gmsl1 mode
--    RegWrite(SER_ID,  SR_REG6, 1, 0x00 ,0x0B, "SER_UART_Write")    ----0x06
    fpga_UART_Write("FPGA1","SER", SER_ID,SR_REG6 , 1, 0x0B)

-----Setup DES
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG6, 1, 0x0B)--

----------------------------------########### CLINKEN = 1 SEREN = 0
RegWrite(SER_ID, 0x404 ,1 ,0x00, 0x43, "SER_UART_Write")--------0x404
----------------------------------########### ctrl0_cfg_dpi_vsync_width_l = 1
--RegWrite(SER_ID, 0x386 ,1 ,0x00, 0x01, "SER_UART_Write")--------0x386
    fpga_UART_Write("FPGA1","SER",SER_ID,0x386 ,1 ,0x01)
----------------------------------########### lane count = 4
--RegWrite(SER_ID, 0x331 ,1 ,0x00, 0x33	, "SER_UART_Write")--------0x331"
    fpga_UART_Write("FPGA1","SER",SER_ID,0x331 ,1 ,0x33)

----------------------------------########### soft_dtx_en= 1
--RegWrite(SER_ID, 0x31C ,1 ,0x00, 0x98, "SER_UART_Write")--------0x31C
    fpga_UART_Write("FPGA1","SER",SER_ID,0x31C ,1 ,0x98)

----------------------------------########### soft_dtx = h24
--RegWrite(SER_ID, 0x321 ,1 ,0x00, 0x24, "SER_UART_Write")--------0x321
    fpga_UART_Write("FPGA1","SER",SER_ID,0x321 ,1 ,0x24)

----------------------------------########### configure the MIPI Loopback
-- RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x08, "SER_UART_Write")--------0x370
-- RegWrite(SER_ID, 0x371 ,1 ,0x00, 0xA, "SER_UART_Write")--------0x371
-- RegWrite(SER_ID, 0x372 ,1 ,0x00, 0x80, "SER_UART_Write")--------0x372
-- RegWrite(SER_ID, 0x373 ,1 ,0x00, 0x0, "SER_UART_Write")--------0x373

    fpga_UART_Write("FPGA1","SER",SER_ID,0x370 ,1 ,0x08)
    fpga_UART_Write("FPGA1","SER",SER_ID,0x371 ,1 ,0x0A)
    fpga_UART_Write("FPGA1","SER",SER_ID,0x372 ,1 ,0x80)
    fpga_UART_Write("FPGA1","SER",SER_ID,0x373 ,1 ,0x0)

----------------------------------########### LINK_EN_B = 0
fpga_UART_Write("FPGA1","DES", DESA_ID,0xF00 ,1 ,0x01)     --------0xF00
----------------------------------########### CONV_GMSL1_EN_A = 1 CONV_GMSL1_DATATYPE_A = h10
fpga_UART_Write("FPGA1","DES", DESA_ID,0xB96 ,1 ,0x83)     --------0xB96
----------------------------------########### SHIFT_VID_HVD_A = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0xBA7 ,1 ,0x45)     --------0xBA7
----------------------------------########### MST_LINK_SEL = b000
fpga_UART_Write("FPGA1","DES", DESA_ID,0x3E2 ,1 ,0x01)     --------0x3E2
----------------------------------########### soft_bpp_x = d24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x313 ,1 ,0xC2)     --------0x313
----------------------------------########### soft_dt_x = h24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x316 ,1 ,0x24)     --------0x316

----------------------------------########### MAP_EN_L_0 = 7
fpga_UART_Write("FPGA1","DES", DESA_ID,0x40B ,1 ,0x07)     --------0x40B
----------------------------------########### MAP_DPHY_DEST_01
fpga_UART_Write("FPGA1","DES", DESA_ID,0x42D ,1 ,0x15)     --------0x42D
----------------------------------########### MAP_SRC_0_0 = h24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x40D ,1 ,0x24)     --------0x40D
----------------------------------########### MAP_DST_0_0 = h24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x40E ,1 ,0x24)     --------0x40E
----------------------------------########### MAP_SRC_2_0 = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x411 ,1 ,0x01)     --------0x411
----------------------------------########### MAP_DST_2_0 = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x412 ,1 ,0x01)     --------0x412

----------------------------------########### override_bpp_vc_dtx = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x31D ,1 ,mipi_speed +0x60)     --------0x31D
----------------------------------########### set CSI data rate
fpga_UART_Write("FPGA1","DES", DESA_ID,0x320 ,1 ,mipi_speed + 0x20)     --------0x320
fpga_UART_Write("FPGA1","DES", DESA_ID,0x323 ,1 ,mipi_speed + 0x20)     --------0x320
fpga_UART_Write("FPGA1","DES", DESA_ID,0x326 ,1 ,mipi_speed + 0x20)     --------0x320


----------------------------------########### force_csi_out_en = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x330 ,1 ,0x84)     --------0x330
 
    if HIBW = 1 then
----------------------------------########### Set HIBW = 1 on SER
--        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x40, "SER_UART_Write")--------0x407        
        fpga_UART_Write("FPGA1","SER", SER_ID,0x407 ,1 ,0x40) 

----------------------------------########### Set HIBW_A = 1 on DES
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x08)     --------0xB07

    elseif BWS = 1 then
--        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x20, "SER_UART_Write")--------0x407----BW = 1
        fpga_UART_Write("FPGA1","SER", SER_ID,0x407 ,1 ,0x20)
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x20)     --------0xB07   ----BW = 1        
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB06 ,1 ,0x68) ---------- USe HS/VS
   else
--        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x00, "SER_UART_Write")--------0x407----BW = 0 
        fpga_UART_Write("FPGA1","SER", SER_ID,0x407 ,1 ,0x00)
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x00)     --------0xB07   ----BW = 0
          

    end_if        

-- ----------------------------------########### phy_config = 0 (1x4)   invert_CSI_mode = 1	"
--     RegWrite(SER_ID, 0x330 ,1 ,0x00, 0x84	, "SER_UART_Write")--------0x330"
      fpga_UART_Write("FPGA1","SER", SER_ID,0x330 ,1 ,0x84)
------------
 end_if    ----Reset

---------

    if SSEN = 4.0 then 
       fpga_UART_Write("FPGA1","SER", SER_ID,0x402 ,1 ,0x0)
        fpga_UART_Write("FPGA1","SER", SER_ID,0x1B03,1 ,0x85)
        fpga_UART_Write("FPGA1","SER", SER_ID,0x402 ,1 ,0x20)

    elseif SSEN = 0.5 then

        fpga_UART_Write("FPGA1","SER", SER_ID,0x402 ,1 ,0x0)
        fpga_UART_Write("FPGA1","SER", SER_ID,0x1B03,1 ,0x82)
        fpga_UART_Write("FPGA1","SER", SER_ID,0x402 ,1 ,0x20)


     else

        fpga_UART_Write("FPGA1","SER", SER_ID,0x402 ,1 ,0x0)
    end_if    



----------------------------------########### Enable MIPI loopback TX/RX PRBSEN
---Stop clock otherwise loopback will be latched MT 1/2019
--    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x00, "SER_UART_Write")--------0x370 
    fpga_UART_Write("FPGA1","SER", SER_ID,0x370 ,1 ,0x0)
    fpga_UART_Write("FPGA1","DES", DESA_ID,0x330 ,1 ,0x04)     --------0x330 
---Changing MIPI freq
----------------------------------########### override_bpp_vc_dtx = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x31D ,1 ,mipi_speed +0x60)     --------0x31D
----------------------------------########### set CSI data rate
fpga_UART_Write("FPGA1","DES", DESA_ID,0x320 ,1 ,mipi_speed + 0x20)     --------0x320
fpga_UART_Write("FPGA1","DES", DESA_ID,0x323 ,1 ,mipi_speed + 0x20)     --------0x320
fpga_UART_Write("FPGA1","DES", DESA_ID,0x326 ,1 ,mipi_speed + 0x20)     --------0x320

--  RegRead(SER_ID, 0x402 , 1, upperword, reg_val_ser_good,"SER_UART_Read")
--  RegRead(SER_ID, 0x1B03 , 1, upperword, reg_val_ser_good,"SER_UART_Read")

    ------------Setup coax or tp 
--    RegRead(SER_ID, SR_CTRL1 , 1,lowword, reg_val_ser_bad,"SER_UART_Read")     
wait(0)
    if TP_COAX = "COAX" then
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1 ,1 ,0xF)     --------Coax
--        RegWrite(SER_ID, SR_CTRL1 ,1 ,0x00, 0xF, "SER_UART_Write")--------program coax
        fpga_UART_Write("FPGA1","SER", SER_ID, SR_CTRL1 ,1 ,0x0F)
    else
         fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1 ,1 ,0x0A)     --------Coax   
         fpga_UART_Write("FPGA1","SER", SER_ID, SR_CTRL1 ,1 ,0x0A)--------program coax
--         RegWrite(SER_ID, SR_CTRL1 ,1 ,0x00, 0x0A, "SER_UART_Write")--------program coax
              
    end_if 
-----Set  HiBw or BWS
    if HIBW = 1 then
----------------------------------########### Set HIBW = 1 on SER
        fpga_UART_Write("FPGA1","SER", SER_ID, 0x407 ,1 ,0x40)
----------------------------------########### Set HIBW_A = 1 on DES
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x08)     --------0xB07

    elseif BWS = 1 then
        fpga_UART_Write("FPGA1","SER", SER_ID, 0x407 ,1 ,0x20)
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x20)     --------0xB07   ----BW = 1        
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB06 ,1 ,0x68) ---------- USe HS/VS
   else
        fpga_UART_Write("FPGA1","SER", SER_ID, 0x407 ,1 ,0x00)
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x00)     --------0xB07   ----BW = 0
 
    end_if        


if MipiPort  ="B" then
----------------------------------########### ctrl0_cfg_dpi_vsync_width_l = 1
    fpga_UART_Write("FPGA1","SER", SER_ID, 0x396 ,1 ,0x01)
    fpga_UART_Write("FPGA1","SER", SER_ID, 0x308 ,1 ,0x7D)

    fpga_UART_Write("FPGA1","DES", DESA_ID,0x42D ,1 ,0x2A) 
    fpga_UART_Write("FPGA1","SER", SER_ID, 0x330 ,1 ,0x85)--------0x330" 1x4 PortB
    fpga_UART_Write("FPGA1","DES", DESA_ID,0x330 ,1 ,0x84)     --------0x330
    wait(2ms)

    fpga_UART_Write("FPGA1","SER", SER_ID, 0x370 ,1 ,0x28)


else----Mipi port A

    fpga_UART_Write("FPGA1","SER", SER_ID, 0x386 ,1 ,0x01)--------0x386
    fpga_UART_Write("FPGA1","SER", SER_ID, 0x308 ,1 ,0x7C)--------0x308


    fpga_UART_Write("FPGA1","DES", DESA_ID,0x42D ,1 ,0x15) 
    fpga_UART_Write("FPGA1","SER", SER_ID, 0x330 ,1 ,0x84)--------0x330"  1x4 PortA
    fpga_UART_Write("FPGA1","DES", DESA_ID,0x330 ,1 ,0x84)     --------0x330
--    fpga_UART_Write("FPGA1","SER", SER_ID, 0x330 ,1 ,0x84)--------0x330"  1x4 PortA
    wait(2ms)
    fpga_UART_Write("FPGA1","SER", SER_ID, 0x370 ,1 ,0x09)
    fpga_UART_Write("FPGA1","SER", SER_ID, 0x370 ,1 ,0x0B)

-- RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x0B, "SER_UART_Write")--------0x370
end_if

    oreg_reg_val = fpga_read_register("FPGA1", SERDES_STATUS)                       ----Use Fpga to check lock. expect high or we can read out reg at DES 0xbcb
    wait(1ms)

--------Set up if it is HIM or Fast_rev

    if HIM  then
        fpga_UART_Write( "FPGA1" , "DES", 0x90     , 0xB06    , 1 , 0xE8     )
        wait(1ms)
        fpga_UART_Write( "FPGA1" , "SER" , 0x80     , 0x44D    , 1 , 0x80     )
        wait(1ms)
    else
        fpga_UART_Write( "FPGA1" , "DES", 0x90     , 0xB06    , 1 , 0x68     )
        fpga_UART_Write( "FPGA1" , "SER" , 0x80     , 0x44D    , 1 , 0x00     )
    end_if

    if RevFast  then
        fpga_UART_Write( "FPGA1" , "DES", 0x90     , 0x14C4   , 1 , 0x44     )
        wait(1ms)
        fpga_UART_Write( "FPGA1" , "SER" , 0x80     , 0x14C4   , 1 , 0x44     )
        fpga_UART_Write( "FPGA1" , "SER" , 0x80     , 0x466    , 1 , 0x70     )
    else
        fpga_UART_Write( "FPGA1" , "DES", 0x90     , 0x14C4   , 1 , 0x40     )
        fpga_UART_Write( "FPGA1" , "SER" , 0x80     , 0x466    , 1 , 0x60     )
        fpga_UART_Write( "FPGA1" , "SER" , 0x80     , 0x14C4   , 1 , 0x40     )
    end_if



        fpga_set_UART_Frequency("FPGA1",Freq)
        fpga_set_I2C_Frequency("FPGA1", Freq)
        wait(1ms)
        fpga_UART_Write("FPGA1","SER", DESA_ID, 16#01C0, 1, 16#7F)             -- write 0x7F to reg, inverted all bits except bit7(can't change)
        ser_read_reg1 =  fpga_UART_Read("FPGA1", "SER", DESA_ID, 16#01C0, 1)   -- FPGA read regs from SER across link after write 
        wait(1ms)    
    
        fpga_UART_Write("FPGA1","DES", SER_ID, 16#01C0, 1, 16#5A)             -- write 0x7F to reg, inverted all bits except bit7(can't change)
        des_read_reg1 =  fpga_UART_Read("FPGA1", "DES", SER_ID, 16#01C0, 1)   -- FPGA read regs from SER across link after write 
        wait(1ms)    
    -- Change to I2C mode
        fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , DR_REG6 , 1 , 0x1B )   --change to I2C mode
        wait(5ms)
        fpga_UART_Write( "FPGA1" , "SER" , SER_ID , SR_REG6 , 1 , 0x1B )    --change to I2C mode
        wait(5ms)

        fpga_I2C_Write("FPGA1","SER", DESA_ID, 16#01C0, 1, 16#5A)             -- write 0x7F to reg, inverted all bits except bit7(can't change)
        ser_read_reg2 =  fpga_I2C_Read("FPGA1", "SER", DESA_ID, 16#01C0, 1)   -- FPGA read regs from SER across link after write 
        wait(1ms)    

        fpga_I2C_Write("FPGA1","DES", SER_ID, 16#01C0, 1, 16#7F)             -- write 0x7F to reg, inverted all bits except bit7(can't change)
        des_read_reg2 =  fpga_I2C_Read("FPGA1", "DES", SER_ID, 16#01C0, 1)   -- FPGA read regs from SER across link after write 
        wait(1ms)    


--------------***** without these commands cannot test next condition without power cycle MT 1/2019
    -- back Change to UART mode
    fpga_I2C_Write( "FPGA1" , "SER" , SER_ID , 0x404 , 1 , 0x81 )    ---Disable Revccen bit
    fpga_I2C_Write( "FPGA1" , "DES" , DESA_ID , 16#B04 , 1 , 0x01 )  ---Disable Revccen bit
    fpga_I2C_Write( "FPGA1" , "SER" , SER_ID , SR_REG6 , 1 , 0x0B )    --change to I2C mode
    wait(1ms)  
    fpga_I2C_Write( "FPGA1" , "DES" , DESA_ID , DR_REG6 , 1 , 0x0B )        --change to I2C mode
    wait(5ms)-------Need some delay to update

    fpga_UART_Write( "FPGA1" , "SER" , SER_ID , 0x404 , 1 , 0x83 )    ---Enable Revccen bit
    fpga_UART_Write( "FPGA1" , "DES" , DESA_ID , 16#B04 , 1 , 0x03 )  ---Enable Revccen bit
--------------***** without these above commands cannot test next condition without power cycle MT 1/2019
 

---These for debug
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,0x6 , 1) 
-- RegRead(SER_ID, 0x1C9, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(SER_ID, 0x20c, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(SER_ID, 0x24F, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(DESA_ID, 0x0, 1, upperword, RegTx2_0,"SER_UART_Read")---292
-- RegRead(SER_ID, 0x407, 1, upperword, RegTx2_0,"SER_UART_Read")
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,0 , 1)
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,DR_GMSL1_CB , 1)

 wait(1ms)
---------------------------------------------------------------------------------------------------------------------------------------------

    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock[site]  = (integer(oreg_reg_val[site])  & 0x800  )   >>11  
        SerUartft[site] = integer(ser_read_reg1[site])       
        DesUartft[site] = integer(des_read_reg1[site])        
        SerI2Cft[site] = integer(ser_read_reg2[site])       
        DesI2Cft[site] = integer(des_read_reg2[site])        

    end_for    
wait(1ms)



-------------- Power Down ---------------------------


    if (POWERDOWN) then

------- turn off MIPI clocks from DES
            fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)         
            fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)    
--         powerup_dnut_vdd_vterm(0.0,0.0) 
          wait(2mS)
            set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
            powerdown_device(POWERDOWN)
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS 
            open cbit  FB_RELAY
--            open cbit  DNUT_RXTX_RELAY +  MFP_LT_K12_RELAY
            open cbit    MFP_LT_RELAY + DNUT_RXTX_RELAY + I2C_LT_CB + MFP_LT_K12_RELAY
      end_if 


--------Data log
    test_value ilinklock with LinkLock
    
--    test_value msfloat(gmsl1_forward_speed) with FW_SPD      
    test_value msfloat(MIPI_SPD) with CSI_SPD
--    test_value (number_of_lanes_test) with NUMBER_LANES
 
--     test_value hibw_ft with HIBW_FT  
--     test_value bws_ft with BWS_FT  
    test_value SerUartft with SerUart
    test_value DesUartft with DesUart
      test_value SerI2Cft with SerI2C
    test_value DesI2Cft with DesI2C    
 end_body






procedure LoopBackGmsl1_mod(Vdd, Vddio, Vdd18, POWERUP,POWERDOWN, HDCP,Link,need_reset,TP_COAX,MIPI_SPD,MipiPort,NUMB_LANES,BWS,HIBW,delay,LinkLock,FW_SPD,CSI_SPD,NUMBER_LANES,HIBW_FT,BWS_FT,BadPat,GoodPat,SSEN)
--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18,delay
in_out integer_test : NUMBER_LANES,BadPat,GoodPat
in boolean          : POWERUP,POWERDOWN,need_reset, HDCP
in string[20]       : TP_COAX, MipiPort                    -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : MIPI_SPD ,SSEN 
in lword            : NUMB_LANES  ,BWS,HIBW                       ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,CSI_SPD
in_out integer_test : LinkLock,HIBW_FT,BWS_FT
--in_out float_test   : HIBW_FT,BWS_FT--VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP
in string[2]        : Link
local



  multisite lword   : LowerRdWord, UpperRdWord
 
 
   
  multisite integer : LBDONE
  float             : gmsl1_forward_speed ---Vconf0, Vconf1,
  multisite lword   : lowword, upperword, RegTx2_0, RegTx2_1,desrx8_1,desrx8_2  

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ilinklock  , number_of_lanes_test,  iRegTx2_0, iRegTx2_1,idesrx8_1,idesrx8_2  ,badpat_ft,goodpat_ft    ----ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
--  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    string[20]        :  infile[4],tempp, MPW
    multisite float   : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1]
    multisite float   : i_vdd_meas_hdcp[1] , i_vdd18_meas_hdcp[1] , i_vddio_meas_hdcp[1] ,read_Ivddio[1,1024],  vdd_sw[1]
    multisite integer : bws_ft, hibw_ft


end_local


body
  
    MPW = "MPW5"
    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    gmsl1_forward_speed  = float((BWS*10) + 30) * MIPI_SPD * float(NUMB_LANES) /24.0
    mipi_speed  = lword(MIPI_SPD/100.0e6)
 
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-----Dut power up function

    DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
    RegRead(SER_ID,0x06 , 1, upperword, lowword,"SER_UART_Read")

   if (need_reset) then
---Close relay to connect FPGA to control TX/RX on DNUT
        close cbit  DNUT_RXTX_RELAY
 ---Set uart or I2C freq for communication    
        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
        powerup_dnut_vdd_vterm(1.2,1.2)
        wait(1ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
        wait(5ms)

-----    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg     
-----     reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read   for debug 
 
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG6, 1, 0x0B)
    reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,DR_REG6 , 1) 
 ---------close CSI feedback loop
        close cbit  FB_RELAY

----Set SER and DES for coax or tp mode
        if TP_COAX = "TP" then
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS           
        else
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
            close cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS
            wait(5ms)
        end_if 

--------------Here

---enable gmsl1 mode
    RegWrite(SER_ID,  SR_REG6, 1, 0x00 ,0x0B, "SER_UART_Write")    ----0x06


-----Setup DES
    fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG6, 1, 0x0B)--

----------------------------------########### CLINKEN = 1 SEREN = 0
--RegWrite(SER_ID, 0x404 ,1 ,0x00, 0x43, "SER_UART_Write")--------0x404
----------------------------------########### ctrl0_cfg_dpi_vsync_width_l = 1
RegWrite(SER_ID, 0x386 ,1 ,0x00, 0x01, "SER_UART_Write")--------0x386
----------------------------------########### lane count = 4
RegWrite(SER_ID, 0x331 ,1 ,0x00, 0x33	, "SER_UART_Write")--------0x331"
----------------------------------########### soft_dtx_en= 1
RegWrite(SER_ID, 0x31C ,1 ,0x00, 0x98, "SER_UART_Write")--------0x31C
----------------------------------########### soft_dtx = h24
RegWrite(SER_ID, 0x321 ,1 ,0x00, 0x24, "SER_UART_Write")--------0x321
----------------------------------########### phy_config = 0 (1x4)   invert_CSI_mode = 1	"
--RegWrite(SER_ID, 0x330 ,1 ,0x00, 0x84	, "SER_UART_Write")--------0x330"----      this statment has to be after DES setup otherwise loopback not working

----------------------------------########### configure the MIPI Loopback
RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x08, "SER_UART_Write")--------0x370
RegWrite(SER_ID, 0x371 ,1 ,0x00, 0xA, "SER_UART_Write")--------0x371
RegWrite(SER_ID, 0x372 ,1 ,0x00, 0x80, "SER_UART_Write")--------0x372
RegWrite(SER_ID, 0x373 ,1 ,0x00, 0x0, "SER_UART_Write")--------0x373
----------------------------------########### Enable MIPI loopback TX/RX PRBSEN onA
 --   RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x09, "SER_UART_Write")--------0x370----      this statment has to be after DES setup otherwise loopback not working
---xxxxxxxxxxxxx-----


----------------------------------########### LINK_EN_B = 0
fpga_UART_Write("FPGA1","DES", DESA_ID,0xF00 ,1 ,0x01)     --------0xF00
----------------------------------########### CONV_GMSL1_EN_A = 1 CONV_GMSL1_DATATYPE_A = h10
fpga_UART_Write("FPGA1","DES", DESA_ID,0xB96 ,1 ,0x83)     --------0xB96
----------------------------------########### SHIFT_VID_HVD_A = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0xBA7 ,1 ,0x45)     --------0xBA7
----------------------------------########### MST_LINK_SEL = b000
fpga_UART_Write("FPGA1","DES", DESA_ID,0x3E2 ,1 ,0x01)     --------0x3E2
----------------------------------########### soft_bpp_x = d24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x313 ,1 ,0xC2)     --------0x313
----------------------------------########### soft_dt_x = h24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x316 ,1 ,0x24)     --------0x316

----------------------------------########### MAP_EN_L_0 = 7
fpga_UART_Write("FPGA1","DES", DESA_ID,0x40B ,1 ,0x07)     --------0x40B
----------------------------------########### MAP_DPHY_DEST_01
fpga_UART_Write("FPGA1","DES", DESA_ID,0x42D ,1 ,0x15)     --------0x42D
----------------------------------########### MAP_SRC_0_0 = h24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x40D ,1 ,0x24)     --------0x40D
----------------------------------########### MAP_DST_0_0 = h24
fpga_UART_Write("FPGA1","DES", DESA_ID,0x40E ,1 ,0x24)     --------0x40E
----------------------------------########### MAP_SRC_2_0 = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x411 ,1 ,0x01)     --------0x411
----------------------------------########### MAP_DST_2_0 = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x412 ,1 ,0x01)     --------0x412

----------------------------------########### override_bpp_vc_dtx = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x31D ,1 ,mipi_speed +0x60)     --------0x31D
----------------------------------########### set CSI data rate
fpga_UART_Write("FPGA1","DES", DESA_ID,0x320 ,1 ,mipi_speed + 0x20)     --------0x320
fpga_UART_Write("FPGA1","DES", DESA_ID,0x323 ,1 ,mipi_speed + 0x20)     --------0x320
fpga_UART_Write("FPGA1","DES", DESA_ID,0x326 ,1 ,mipi_speed + 0x20)     --------0x320


----------------------------------########### force_csi_out_en = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x330 ,1 ,0x84)     --------0x330

    if HIBW = 1 then
----------------------------------########### Set HIBW = 1 on SER
        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x40, "SER_UART_Write")--------0x407        
----------------------------------########### Set HIBW_A = 1 on DES
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x08)     --------0xB07

    elseif BWS = 1 then
        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x20, "SER_UART_Write")--------0x407----BW = 1
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x20)     --------0xB07   ----BW = 1        
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB06 ,1 ,0x68) ---------- USe HS/VS
   else
        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x00, "SER_UART_Write")--------0x407----BW = 0 
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x00)     --------0xB07   ----BW = 0
          

    end_if        

-- ----------------------------------########### phy_config = 0 (1x4)   invert_CSI_mode = 1	"
     RegWrite(SER_ID, 0x330 ,1 ,0x00, 0x84	, "SER_UART_Write")--------0x330"

------------
 end_if    ----Reset

---------

--     if SSEN = 4.0 then 
--         RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x0, "SER_UART_Write")  --- SSEN = 0
--         RegWrite(SER_ID, 0x1B03 ,1 ,0x00, 0x85, "SER_UART_Write")---Set DPLL_AUD to 0x85
--         RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x20, "SER_UART_Write")  --- SSEN = 1
-- 
--  RegRead(SER_ID, 0x402 , 1, upperword, reg_val_ser_good,"SER_UART_Read")
--  RegRead(SER_ID, 0x1B03 , 1, upperword, reg_val_ser_good,"SER_UART_Read")
-- 
--     elseif SSEN = 0.5 then
--         RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x0, "SER_UART_Write")  --- SSEN = 0
--         RegWrite(SER_ID, 0x1B03 ,1 ,0x00, 0x82, "SER_UART_Write")---Set DPLL_AUD to 0x85
--         RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x20, "SER_UART_Write")  --- SSEN = 1    
--      else
--         RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x0, "SER_UART_Write")  --- SSEN = 0
--     end_if    



----------------------------------########### Enable MIPI loopback TX/RX PRBSEN
---Stop clock otherwise loopback will be latched MT 1/2019
    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x00, "SER_UART_Write")--------0x370 
    fpga_UART_Write("FPGA1","DES", DESA_ID,0x330 ,1 ,0x04)     --------0x330 
---Changing MIPI freq
----------------------------------########### override_bpp_vc_dtx = 1
fpga_UART_Write("FPGA1","DES", DESA_ID,0x31D ,1 ,mipi_speed +0x60)     --------0x31D
----------------------------------########### set CSI data rate
fpga_UART_Write("FPGA1","DES", DESA_ID,0x320 ,1 ,mipi_speed + 0x20)     --------0x320
fpga_UART_Write("FPGA1","DES", DESA_ID,0x323 ,1 ,mipi_speed + 0x20)     --------0x320
fpga_UART_Write("FPGA1","DES", DESA_ID,0x326 ,1 ,mipi_speed + 0x20)     --------0x320

--  RegRead(SER_ID, 0x402 , 1, upperword, reg_val_ser_good,"SER_UART_Read")
--  RegRead(SER_ID, 0x1B03 , 1, upperword, reg_val_ser_good,"SER_UART_Read")

    ------------Setup coax or tp 
--    RegRead(SER_ID, SR_CTRL1 , 1,lowword, reg_val_ser_bad,"SER_UART_Read")     
wait(0)
    if TP_COAX = "COAX" then
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1 ,1 ,0xF)     --------Coax
        RegWrite(SER_ID, SR_CTRL1 ,1 ,0x00, 0xF, "SER_UART_Write")--------program coax

    else
         fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1 ,1 ,0x0A)     --------Coax   
         RegWrite(SER_ID, SR_CTRL1 ,1 ,0x00, 0x0A, "SER_UART_Write")--------program coax
              
    end_if 
-----Set  HiBw or BWS
    if HIBW = 1 then
----------------------------------########### Set HIBW = 1 on SER
        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x40, "SER_UART_Write")--------0x407        
----------------------------------########### Set HIBW_A = 1 on DES
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x08)     --------0xB07

    elseif BWS = 1 then
        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x20, "SER_UART_Write")--------0x407----BW = 1
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x20)     --------0xB07   ----BW = 1        
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB06 ,1 ,0x68) ---------- USe HS/VS
   else
        RegWrite(SER_ID, 0x407 ,1 ,0x00, 0x00, "SER_UART_Write")--------0x407----BW = 0 
        fpga_UART_Write("FPGA1","DES", DESA_ID,0xB07 ,1 ,0x00)     --------0xB07   ----BW = 0
 
    end_if        

-------Set up SSEN

if MipiPort  ="B" then
----------------------------------########### ctrl0_cfg_dpi_vsync_width_l = 1

    RegWrite(SER_ID, 0x396 ,1 ,0x00, 0x01, "SER_UART_Write")--------0x386
    RegWrite(SER_ID, 0x308 ,1 ,0x00, 0x7D, "SER_UART_Write")--------0x386
    fpga_UART_Write("FPGA1","DES", DESA_ID,0x42D ,1 ,0x2A) 
    RegWrite(SER_ID, 0x330 ,1 ,0x00, 0x85	, "SER_UART_Write")--------0x330" 1x4 PortB
    fpga_UART_Write("FPGA1","DES", DESA_ID,0x330 ,1 ,0x84)     --------0x330
    wait(2ms)

    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x28, "SER_UART_Write")--------0x370

    if SSEN = 4.0 then 
        RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x0, "SER_UART_Write")  --- SSEN = 0
        RegWrite(SER_ID, 0x1B03 ,1 ,0x00, 0x85, "SER_UART_Write")---Set DPLL_AUD to 0x85
        RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x20, "SER_UART_Write")  --- SSEN = 1
-- ---Check back value
--         RegRead(SER_ID, 0x402 , 1, upperword, reg_val_ser_good,"SER_UART_Read")
--         RegRead(SER_ID, 0x1B03 , 1, upperword, reg_val_ser_good,"SER_UART_Read")

    elseif SSEN = 0.5 then
        RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x0, "SER_UART_Write")  --- SSEN = 0
        RegWrite(SER_ID, 0x1B03 ,1 ,0x00, 0x82, "SER_UART_Write")---Set DPLL_AUD to 0x85
        RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x20, "SER_UART_Write")  --- SSEN = 1    
     else
        RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x0, "SER_UART_Write")  --- SSEN = 0
    end_if    

    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x6C, "SER_UART_Write")--------0x370
    wait(20ms )
    RegRead(SER_ID, SR_MIPI_LPB4 , 1,lowword, reg_val_ser_bad,"SER_UART_Read")      

    for idx = 1 to sites do
        site = active_sites[idx]
         if reg_val_ser_bad[site] = 0x0 then         
             wait(15ms)
             RegRead(SER_ID, SR_MIPI_LPB4 , 1,lowword, reg_val_ser_bad,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
            wait(0)
         end_if
     end_for
    wait(200us)
------No error injected patterns
    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x68, "SER_UART_Write")--------0x370
    wait(delay)
    RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, reg_val_ser_good,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
    wait(200us)

else----Mipi port A
    RegWrite(SER_ID, 0x386 ,1 ,0x00, 0x01, "SER_UART_Write")--------0x386
    RegWrite(SER_ID, 0x308 ,1 ,0x00, 0x7C, "SER_UART_Write")--------0x386
    fpga_UART_Write("FPGA1","DES", DESA_ID,0x42D ,1 ,0x15) 
    RegWrite(SER_ID, 0x330 ,1 ,0x00, 0x84	, "SER_UART_Write")--------0x330"  1x4 PortA
    fpga_UART_Write("FPGA1","DES", DESA_ID,0x330 ,1 ,0x84)     --------0x330
    wait(2ms)
    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x9, "SER_UART_Write")--------0x370
    if SSEN = 4.0 then 
        RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x0, "SER_UART_Write")  --- SSEN = 0
        RegWrite(SER_ID, 0x1A03 ,1 ,0x00, 0x85, "SER_UART_Write")---Set DPLL_AUD to 0x85
        RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x20, "SER_UART_Write")  --- SSEN = 1

--  RegRead(SER_ID, 0x402 , 1, upperword, reg_val_ser_good,"SER_UART_Read")
--  RegRead(SER_ID, 0x1A03 , 1, upperword, reg_val_ser_good,"SER_UART_Read")

    elseif SSEN = 0.5 then
        RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x0, "SER_UART_Write")  --- SSEN = 0
        RegWrite(SER_ID, 0x1B03 ,1 ,0x00, 0x82, "SER_UART_Write")---Set DPLL_AUD to 0x85
        RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x20, "SER_UART_Write")  --- SSEN = 1    
     else
        RegWrite(SER_ID, 0x402 ,1 ,0x00, 0x0, "SER_UART_Write")  --- SSEN = 0
    end_if    



    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x0F, "SER_UART_Write")--------0x370  ---error injected PRBS
    wait(20ms )
    RegRead(SER_ID, SR_MIPI_LPB4 , 1,lowword, reg_val_ser_bad,"SER_UART_Read")  
    for idx = 1 to sites do
        site = active_sites[idx]
         if reg_val_ser_bad[site] = 0x0 then         
             wait(10ms)
             RegRead(SER_ID, SR_MIPI_LPB4 , 1,lowword, reg_val_ser_bad,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
            wait(0)
         end_if
     end_for
    wait(200us)
------No error injected patterns
    RegWrite(SER_ID, 0x370 ,1 ,0x00, 0x0B, "SER_UART_Write")--------0x370
    wait(delay)
    RegRead(SER_ID, SR_MIPI_LPB4 , 1, upperword, reg_val_ser_good,"SER_UART_Read")                                    -------16#0374 should see bit[0 to 7] depend on how many lanes are high, meaning pattern fails the comparison   
    wait(200us)

end_if
-- RegRead(SER_ID, 0x402 , 1, upperword, reg_val_ser_good,"SER_UART_Read")
--     RegRead(SER_ID, 0x1B03 , 1, upperword, reg_val_ser_good,"SER_UART_Read")   
    oreg_reg_val = fpga_read_register("FPGA1", SERDES_STATUS)                       ----Use Fpga to check lock. expect high or we can read out reg at DES 0xbcb
    wait(1ms)

---These for debug
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,0x6 , 1) 
-- RegRead(SER_ID, 0x1C9, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(SER_ID, 0x20c, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(SER_ID, 0x24F, 1, upperword, RegTx2_0,"SER_UART_Read")
-- RegRead(DESA_ID, 0x0, 1, upperword, RegTx2_0,"SER_UART_Read")---292
-- RegRead(SER_ID, 0x407, 1, upperword, RegTx2_0,"SER_UART_Read")
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,0 , 1)
-- reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID,DR_GMSL1_CB , 1)

 wait(1ms)
---------------------------------------------------------------------------------------------------------------------------------------------

    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock[site]  = (integer(oreg_reg_val[site])  & 0x800  )   >>11  
        hibw_ft[site] = integer(HIBW)    
        bws_ft[site] = integer(BWS)    
        if MipiPort  ="B" then
            badpat_ft[site] = integer(reg_val_ser_bad[site] >>4)
            goodpat_ft[site] = integer(reg_val_ser_good[site]>>4)
        else
            badpat_ft[site] = integer(reg_val_ser_bad[site])
            goodpat_ft[site] = integer(reg_val_ser_good[site])
        end_if
    end_for    
wait(1ms)



-------------- Power Down ---------------------------


    if (POWERDOWN) then

------- turn off MIPI clocks from DES
            fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)         
            fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)    
--         powerup_dnut_vdd_vterm(0.0,0.0) 
          wait(2mS)
            set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 200mV iol 0uA ioh 0uA vref 0V
            powerdown_device(POWERDOWN)
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS 
            open cbit  FB_RELAY
      end_if 


--------Data log
    test_value ilinklock with LinkLock
    
    test_value msfloat(gmsl1_forward_speed) with FW_SPD      
    test_value msfloat(MIPI_SPD) with CSI_SPD
    test_value (number_of_lanes_test) with NUMBER_LANES
 
    test_value hibw_ft with HIBW_FT  
    test_value bws_ft with BWS_FT  
    test_value badpat_ft with BadPat
    test_value goodpat_ft with GoodPat
     
 end_body






procedure FXHS_PULLDOWN
--------------------------------------------------------------------------------
--  

local

end_local

body

--added to prevent hot switch/glitch caused by FXHS -- EALIDO/2/27/2019
set digital pin (SER_CSI_PINS+SER_SIOAP+SER_SIOAN+SER_SIOBP+SER_SIOBN) levels to iol 1mA ioh -1mA
wait(0ms)

end_body

procedure CFG_VIN_3PINS(Vddio, Vdd18, Vdd, TestPins, CFGRegId, Cfgmax0Test, Cfgmax1Test,Cfgmin1Test, Cfgmax2Test,Cfgmin2Test, Cfgmax3Test,Cfgmin3Test, Cfgmax4Test,Cfgmin4Test, Cfgmax5Test,Cfgmin5Test, Cfgmax6Test,Cfgmin6Test, Cfgmax7Test,Cfgmin7Test,Vmax0,Vmax1,Vmin1,Vmax2,Vmin2,Vmax3,Vmin3,Vmax4,Vmin4,Vmax5,Vmin5,Vmax6,Vmin6,Vmin7,POWERUP,POWERDOWN)
--------------------------------------------------------------------------------
in float            : Vddio, Vdd18, Vdd
in PIN LIST[5]    : TestPins
in_out array of float_test : Cfgmax0Test, Cfgmax1Test,Cfgmin1Test, Cfgmax2Test,Cfgmin2Test, Cfgmax3Test,Cfgmin3Test, Cfgmax4Test,Cfgmin4Test, Cfgmax5Test,Cfgmin5Test, Cfgmax6Test,Cfgmin6Test, Cfgmax7Test,Cfgmin7Test
--in_out float_test : Cfgmax9Test,Cfgmin9Test, Cfgmax10Test,Cfgmin10Test, Cfgmax11Test,Cfgmin11Test, Cfgmax12Test,Cfgmin12Test, Cfgmax13Test,Cfgmin13Test, Cfgmax14Test,Cfgmin14Test, Cfgmax15Test,Cfgmin15Test
in float          : Vmax0,Vmax1,Vmin1,Vmax2,Vmin2,Vmax3,Vmin3,Vmax4,Vmin4,Vmax5,Vmin5,Vmax6,Vmin6,Vmin7      ------Vmax7

in word           : CFGRegId
in boolean        : POWERUP,POWERDOWN


-- in_out array of float_test : MbistDone
-- in_out array of float_test : MbistPassFail


local

  
 
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword--, des_read0, des_read1, des_read2, reg_val20, reg_val21

  multisite integer : reg_val, reg_val0, reg_val1
  word              : sites, idx, site
  integer           : idxs

  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
 
    multisite float   : Cfgmax0[3],Cfgmin0[3], Cfgmax1[3],Cfgmin1[3], Cfgmax2[3],Cfgmin2[3], Cfgmax3[3],Cfgmin3[3], Cfgmax4[3],Cfgmin4[3], Cfgmax5[3],Cfgmin5[3], Cfgmax6[3],Cfgmin6[3], Cfgmax7[3],Cfgmin7[3], Cfgmax8[3],Cfgmin8[3]
    multisite float   : Cfgmax9[3],Cfgmin9[3], Cfgmax10[3],Cfgmin10[3], Cfgmax11[3],Cfgmin11[3], Cfgmax12[3],Cfgmin12[3], Cfgmax13[3],Cfgmin13[3], Cfgmax14[3],Cfgmin14[3], Cfgmax15[3],Cfgmin15[3], Cfgmax16[3],Cfgmin16[3]
    boolean           : CHAR
 end_local


body
--SER_GPO6_CFG2
--SER_GPO4_CFG0  
    get_expr("OpVar_Char", CHAR)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    --make sure RSVD pin float (HVVI disconnect)
    CHAR = false  --z for FT only
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!

-----Dut power up function
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)

    
    RegRead(SER_ID, SR_REG0, 1, upperword, lowword,"SER_UART_Read")     -- device ID, to make sure we test the correct device
    wait(200us)
--    RegRead(SER_ID, 16#06, 1, upperword, lowword,"SER_UART_Read")   

    for idxs = 1 to len(active_sites) do
      site = active_sites[idxs]
      reg_val[site]  = integer(lowword[site])        
    end_for 


-----Code from here
 RegRead(SER_ID, 0x0323, 1, RdWordUpper, RdWordLower, "SER_UART_Read")
 
  enable digital ppmu TestPins fv 0V vmax 5V measure i max 2mA
  set digital ppmu TestPins  to fv 0V vmax 5V measure i max 2mA
  disconnect digital pin TestPins  from dcl
  connect digital ppmu TestPins to fv 0V vmax 5V measure i max 2mA
  if CHAR then
-- --        Cfgmax0 = Cfg1Search(TestPins, 187mV , 255mV , 2mV, CFGRegId,0, "UP") 
--        Cfgmax0 = Cfg1Search(TestPins, Vddio*10.0/100.0 ,Vddio*16.9/100.0  , 2mV, CFGRegId,0, "UP") 
-- --        Cfgmax1 = Cfg1Search(TestPins, 255mV, 340mV , 2mV, CFGRegId,1, "UP") 
--         Cfgmax1 = Cfg1Search(TestPins,Vddio*22.0/100.0 , Vddio*28.8/100.0 , 2mV, CFGRegId,1, "UP")    
--         Cfgmin1 = Cfg1Search(TestPins,Vddio*18.0/100.0 , Vddio*12.0/100.0 , 2mV, CFGRegId, 1, "DOWN")  
-- 
--         Cfgmax2 = Cfg1Search(TestPins,Vddio*34.0/100.0 , Vddio*40.0/100.0 , 2mV, CFGRegId,2, "UP")    
--         Cfgmin2 = Cfg1Search(TestPins,Vddio*30.0/100.0 , Vddio*24.0/100.0 , 2mV, CFGRegId, 2, "DOWN")  
-- 
--         Cfgmax3 = Cfg1Search(TestPins, Vddio*46.0/100.0 , Vddio*52.0/100.0 , 2mV, CFGRegId,3, "UP")    
--         Cfgmin3 = Cfg1Search(TestPins, Vddio*41.5/100.0 , Vddio*36.0/100.0,  2mV, CFGRegId, 3, "DOWN")  
-- 
--         Cfgmax4 = Cfg1Search(TestPins, Vddio*58.0/100.0 , Vddio*65.0/100.0 , 2mV,CFGRegId, 4, "UP")    
--         Cfgmin4 = Cfg1Search(TestPins, Vddio*54.0/100.0 , Vddio*47.0/100.0 , 2mV,  CFGRegId,4, "DOWN")  
-- 
--         Cfgmax5 = Cfg1Search(TestPins, Vddio*71.0/100.0 , Vddio*76.0/100.0 , 2mV, CFGRegId,5, "UP")    
--         Cfgmin5 = Cfg1Search(TestPins, Vddio*66.0/100.0 , Vddio*59.0/100.0 , 2mV, CFGRegId, 5, "DOWN")  
-- 
--         Cfgmax6 = Cfg1Search(TestPins, Vddio*82.0/100.0 , Vddio*89.0/100.0 , 2mV,CFGRegId, 6, "UP")    
--         Cfgmin6 = Cfg1Search(TestPins, Vddio*78.0/100.0 , Vddio*70.0/100.0 , 2mV,  CFGRegId,6, "DOWN")  
-- 
-- --        Cfgmax7 = Cfg1Search(TestPins, 765mV, 850mV , 2mV,CFGRegId, 7, "UP")    
--         Cfgmin7 = Cfg1Search(TestPins, Vddio*90.0/100.0 , Vddio*83.0/100.0 , 2mV, CFGRegId, 7, "DOWN")  

--         Cfgmax8 = Cfg1Search(TestPins, 850mV, 918mV , 2mV,CFGRegId, 8, "UP")    
--         Cfgmin8 = Cfg1Search(TestPins, 850mV, 765mV, 2mV, CFGRegId, 8, "DOWN")  
--         Cfgmax9 = Cfg1Search(TestPins, 918mV, 1V , 2mV,CFGRegId, 9, "UP")    
--         Cfgmin9 = Cfg1Search(TestPins, 918mV, 850mV, 2mV, CFGRegId, 9, "DOWN")  
--         Cfgmax10 = Cfg1Search(TestPins, 1V, 1.1V , 2mV, CFGRegId,10, "UP")    
--         Cfgmin10 = Cfg1Search(TestPins, 1V, 0.9V, 2mV,  CFGRegId,10, "DOWN")  
--         Cfgmax11 = Cfg1Search(TestPins, 1.0881V, 1.2V , 2mV,CFGRegId, 11, "UP")    
--         Cfgmin11 = Cfg1Search(TestPins, 1.088V, 1V, 2mV,CFGRegId, 11, "DOWN")  
--         Cfgmax12 = Cfg1Search(TestPins, 1.173V, 1.26V , 2mV,CFGRegId, 12, "UP")    
--         Cfgmin12 = Cfg1Search(TestPins, 1.173V, 1.088V, 2mV,CFGRegId, 12, "DOWN")  
--         Cfgmax13 = Cfg1Search(TestPins, 1.258V, 1.428 , 2mV, CFGRegId,13, "UP")    
--         Cfgmin13 = Cfg1Search(TestPins, 1.258V, 1.173V, 2mV, CFGRegId,13, "DOWN")  
--         Cfgmax14 = Cfg1Search(TestPins, 1.343V, 1.462V , 2mV,CFGRegId, 14, "UP")    
--         Cfgmin14 = Cfg1Search(TestPins, 1.343V, 1.258V, 2mV, CFGRegId,14, "DOWN")  
--         Cfgmax15 = Cfg1Search(TestPins, 1.428V, 1.6V , 2mV, CFGRegId,15, "UP")    
--         Cfgmin15 = Cfg1Search(TestPins, 1.428V, 1.343V, 2mV,CFGRegId, 15, "DOWN")  
  else
        Cfgmax0 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmax0, 0)
        Cfgmax1 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmax1, 1)
        Cfgmin1 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmin1, 1)
        Cfgmax2 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmax2, 2)
        Cfgmin2 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmin2, 2)
        Cfgmax3 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmax3, 3)
        Cfgmin3 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmin3, 3)
        Cfgmax4 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmax4, 4)
        Cfgmin4 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmin4, 4)
        Cfgmax5 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmax5, 5)
        Cfgmin5 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmin5, 5)
        Cfgmax6 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmax6, 6)
        Cfgmin6 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmin6, 6)
--        Cfgmax7 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmax7-15mV, 7)
        Cfgmin7 = CfgGoNoGo3PINS(TestPins, CFGRegId,Vmin7, 7)
--         Cfgmax8 = CfgGoNoGo(TestPins, CFGRegId,Vmax8-15mV, 8)
--         Cfgmin8 = CfgGoNoGo(TestPins, CFGRegId,Vmin8+15mV, 8)
--         Cfgmax9 = CfgGoNoGo(TestPins, CFGRegId,Vmax9-15mV, 9)
--         Cfgmin9 = CfgGoNoGo(TestPins, CFGRegId,Vmin9+15mV, 9)
--         Cfgmax10 = CfgGoNoGo(TestPins, CFGRegId,Vmax10-15mV, 10)
--         Cfgmin10 = CfgGoNoGo(TestPins, CFGRegId,Vmin10+15mV, 10)
--         Cfgmax11 = CfgGoNoGo(TestPins, CFGRegId,Vmax11-15mV, 11)
--         Cfgmin11 = CfgGoNoGo(TestPins, CFGRegId,Vmin11+15mV, 11)
--         Cfgmax12 = CfgGoNoGo(TestPins, CFGRegId,Vmax12-15mV, 12)
--         Cfgmin12 = CfgGoNoGo(TestPins, CFGRegId,Vmin12+15mV, 12)
--         Cfgmax13 = CfgGoNoGo(TestPins, CFGRegId,Vmax13-15mV, 13)
--         Cfgmin13 = CfgGoNoGo(TestPins, CFGRegId,Vmin13+15mV, 13)
--         Cfgmax14 = CfgGoNoGo(TestPins, CFGRegId,Vmax14-15mV, 14)
--         Cfgmin14 = CfgGoNoGo(TestPins, CFGRegId,Vmin14+15mV, 14)
--         Cfgmax15 = CfgGoNoGo(TestPins, CFGRegId,Vmax15-15mV, 15)
--         Cfgmin15 = CfgGoNoGo(TestPins, CFGRegId,Vmin15+15mV, 15)  


  end_if
 ---------------------------------------------

-------------- Power Down ---------------------------
   disconnect digital pin TestPins  from ppmu
   connect digital pin TestPins  to dcl
      powerdown_device(POWERDOWN)  


   -- Datalog Results   
      test_value Cfgmax0 with Cfgmax0Test  
      test_value Cfgmin1 with Cfgmin1Test
      test_value Cfgmax1 with Cfgmax1Test  
      test_value Cfgmin2 with Cfgmin2Test
      test_value Cfgmax2 with Cfgmax2Test  
      test_value Cfgmin3 with Cfgmin3Test
      test_value Cfgmax3 with Cfgmax3Test
      test_value Cfgmin4 with Cfgmin4Test
      test_value Cfgmax4 with Cfgmax4Test
      test_value Cfgmin5 with Cfgmin5Test
      test_value Cfgmax5 with Cfgmax5Test
      test_value Cfgmin6 with Cfgmin6Test
      test_value Cfgmax6 with Cfgmax6Test
      test_value Cfgmin7 with Cfgmin7Test
--       test_value Cfgmax7 with Cfgmax7Test
--       test_value Cfgmin8 with Cfgmin8Test
--       test_value Cfgmax8 with Cfgmax8Test
--       test_value Cfgmin9 with Cfgmin9Test
--       test_value Cfgmax9 with Cfgmax9Test
--       test_value Cfgmin10 with Cfgmin10Test
--       test_value Cfgmax10 with Cfgmax10Test
--       test_value Cfgmin11 with Cfgmin11Test
--       test_value Cfgmax11 with Cfgmax11Test
--       test_value Cfgmin12 with Cfgmin12Test
--       test_value Cfgmax12 with Cfgmax12Test
--       test_value Cfgmin13 with Cfgmin13Test
--       test_value Cfgmax13 with Cfgmax13Test
--       test_value Cfgmin14 with Cfgmin14Test
--       test_value Cfgmax14 with Cfgmax14Test
--       test_value Cfgmin15 with Cfgmin15Test
--       test_value Cfgmax15 with Cfgmax15Test 


 end_body


procedure Isupply1X4_Max96755H(Vdd, Vddio, Vdd18, POWERUP,POWERDOWN, HDCP,Link,need_reset,TP_COAX,TX_SPD,RX_SPD,MIPI_SPD,CSI_MODE,NUMB_LANES,Link_Lock_dly,LinkLock,FW_SPD,RW_SPD,CSI_SPD,NUMBER_LANES,DesRx8_1,SerTx2_0,DesRx8_2,SerTx2_1,VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP,VddI_1p26,VddI_1p26_HDCP)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in_out integer_test : NUMBER_LANES
in boolean          : POWERUP,POWERDOWN,need_reset, HDCP
in string[20]       : TP_COAX,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,MIPI_SPD,Link_Lock_dly
in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,RW_SPD,CSI_SPD
in_out integer_test : DesRx8_1,SerTx2_0,DesRx8_2,SerTx2_1,LinkLock
in_out float_test   : VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP,VddI_1p26,VddI_1p26_HDCP
in string[2]        : Link
local



  multisite lword   : LowerRdWord, UpperRdWord
 
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, RegTx2_0, RegTx2_1,desrx8_1,desrx8_2  --, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ilinklock  , number_of_lanes_test,  iRegTx2_0, iRegTx2_1,idesrx8_1,idesrx8_2      ----ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
--  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    string[20]      :  infile[4],tempp, MPW
    multisite float : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1],i_vdd_1p26_meas[1]
    multisite float : i_vdd_meas_hdcp[1] , i_vdd18_meas_hdcp[1] , i_vddio_meas_hdcp[1] ,read_Ivddio[1,1024],i_vdd_1p26_meas_hdcp[1]

    boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount,count

end_local


body
    loopcont  = true
   SiteCheck  = false   
    MPW = "MPW5"
    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-- -----Dut power up function
--      if vdd_global[2] > 1.05 then
--         set hcovi SER_VDD  to fv 1.2 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
--         wait(2ms)
--         set hcovi SER_VDD  to fv 1.15 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
--         wait(2ms)        
--         set hcovi SER_VDD  to fv 1.1 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
--         wait(5ms)
--        vdd_global[2]  = 1.1
--      end_if   
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
 
   if (need_reset) then
---Close relay to connect FPGA to control TX/RX on DNUT
        close cbit  DNUT_RXTX_RELAY
 ---Set uart or I2C freq for communication    
        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
        powerup_dnut_vdd_vterm(1.2,1.2)
        wait(1ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
        wait(5ms)

-----    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg     
-----     reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read   for debug 
 

    
 ---------close CSI feedback loop
        close cbit  FB_RELAY

----Set SER and DES for coax or tp mode
        if TP_COAX = "TP" then
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS           
        else
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
            close cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS

        end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

        if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
        elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

        if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
        elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
        elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
        end_if 
        ser_link_speed_code = ser_rx_speed + ser_tx_speed
        des_link_speed_code = des_rx_speed + des_tx_speed

----Program link rate

        RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed

        wait(20ms)     ------needed otherwise has to wait more than 100mS after oneshot command to lock


-----Write to reg10 to update link speed setting 

        if Link = "A" or Link = "a" then
            RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#21, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89      
        elseif Link ="B" or Link = "b" then
            RegWrite(SER_ID, SR_CTRL0, 1, 16#20, 16#22, "SER_UART_Write")    
        else  -----both link
               fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1,0x00  )             ---- DES GMSL link dual
               RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#30, "SER_UART_Write") 

        end_if
   
        RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)

---------------------------------------------------------------------------------------------------------------------------------------------
--        set hcovi SER_VDDIO to fv Vddio   vmax 4V clamp imax 1mA imin -1mA  ---- reduce current
    
        wait(Link_Lock_dly )   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
    end_if   ----- from reset if statement        
-----Check for link lock 
        RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          

    while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  (lowword[site] = 0xde  OR lowword[site] =0xda  OR lowword[site] =0xCa OR lowword[site] =0xCE OR lowword[site] =0xEa OR lowword[site] =0xEE) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true     
                end_if
                if sitecount = sites then
                    loopcont = false
                end_if     
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
            if loopcont  then
                wait(1ms)
                RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
            end_if
            
        end_for            
 
    end_while

-- ---Turn off Adapter EQ periodic
    RegWrite(SER_ID, SR_RLMS4_A ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMS4_B ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x15A4

    RegWrite(SER_ID, SR_RLMSA4_A ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMSA4_B ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x15A4

wait(0)
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock[site]  = integer(lowword[site])       
    end_for    

------Call function to generate color bar 1 to pipeline X
    if Link = "A" or Link = "a" or  Link = "B" or Link = "b"  then   
        GenerateColorBar_max96755H(Link)
    end_if
    if Link = "AB" or Link = "ab"    then                                ----Dual links mode
        GenerateColorBar_max96755H_DL
    end_if

    --- force CSI clk out on HS94
    --- force_CSI_out_en = 1	------ Force CSI clock out at the end eleminate 80mS delay for Reg11A update to right value 0x82 
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_PHY0 , 1, 0x84)

--         RegRead(SER_ID,0x16b7 , 1, upperword, lowword,"SER_UART_Read")

--------------- read back value to make sure ser has pclk and des does have video lock
    wait(10ms)  ----Need about 10ms for readout correctly
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")    ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    desrx8_1  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_0, 1)      -- lockbit expect 0x62
    
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    if Link = "AB" or Link = "ab"    then    
        desrx8_2  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_2, 1)      -- lockbit expect 0x62
        wait(1ms)
        desrx8_2  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_2, 1)      -- lockbit expect 0x62
        RegRead(SER_ID, SR_VIDEO_TX2_1, 1, upperword, RegTx2_0,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A    
        RegRead(SER_ID, SR_VIDEO_TX2_1, 1, upperword, RegTx2_1,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    end_if
------------Measure current

          if POWERUP then
        set hcovi SER_VDDIO to fv Vddio vmax 4V measure i max 1mA clamp imax 5mA imin 5mA  ---- reduce current
        --wait(50mS) 

   end_if
   --z wait(50mS) ----needed for Vdd18 current stable
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas
--    measure hcovi i on SER_VDDIO for 2048 samples every 1ms  into read_Ivddio keep previous

------Add Vdd=1.26 for supply test
---Change VDD to 1.26V for measure second set
        RegWrite(SER_ID, SR_CTRL0, 1, 0,16#15, "SER_UART_Write")----Reg_enable = 1
        RegWrite(SER_ID,SR_CTRL2, 1, 0,16#14, "SER_UART_Write")  -----LDO =1
    set hcovi SER_VDD to fv 1.26 vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
    wait(2ms)
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas
 wait(2ms)


    if HDCP then  --- turn on HDCP from ser
--          RegWrite(SER_ID, 16#1677 ,1, 0x0, 0x06	, "SER_UART_Write")
--         RegWrite(SER_ID, 0x16B8,1,0x0, 0x01, "SER_UART_Write" )
--         RegWrite(SER_ID, 16#16b9 ,1, 0x0, 0x90	, "SER_UART_Write")
--         RegWrite(SER_ID, 0x16B7,1,0x0, 0x40, "SER_UART_Write" )



           if Link = "A" then
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 0x1695 ,1, 0x0, 0x43	, "SER_UART_Write")                
           elseif Link  = "B" then
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           else
               RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")                
               RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x43	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           end_if    

------------Measure current in HDCP mode
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas_hdcp
        measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_hdcp
        measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_hdcp
---Change VDD back to set value for measure second set
        set hcovi SER_VDD to fv Vdd vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
        wait(5ms)
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_hdcp



-----Turn off HDCP
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0xC0	, "SER_UART_Write")                
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0xC0	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x2	, "SER_UART_Write")  
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x2	, "SER_UART_Write")
    end_if


-------------- Power Down ---------------------------
----datalog DesLockbit and serPclk bit
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        idesrx8_1[site]  = integer(desrx8_1[site])       
        iRegTx2_0[site]  = integer(RegTx2_0[site])
        if Link ="AB" or Link = "ab"    then
            idesrx8_2[site]  = integer(desrx8_2[site])       
            iRegTx2_1[site]  = integer(RegTx2_1[site])
       end_if  
    end_for    


    if (POWERDOWN) then

------- turn off MIPI clocks from DES
            fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)         
         fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)    
--          powerup_dnut_vdd_vterm(0.0,0.0) 
--           wait(20mS)
            set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS 
            open cbit  FB_RELAY
            powerdown_device(POWERDOWN)

      end_if 


--------Data log
    test_value ilinklock with LinkLock
    
    test_value msfloat(TX_SPD) with FW_SPD     
    test_value msfloat(RX_SPD) with RW_SPD  
    test_value msfloat(MIPI_SPD) with CSI_SPD
    test_value number_of_lanes_test with NUMBER_LANES
    
    test_value idesrx8_1 with DesRx8_1
    test_value iRegTx2_0 with SerTx2_0
    if Link = "AB" or Link = "ab" then
        test_value idesrx8_2 with DesRx8_2
        test_value iRegTx2_1 with SerTx2_1    
    end_if     
    test_value i_vddio_meas with VddioI  
    test_value i_vdd18_meas with Vdd18I
    test_value i_vdd_meas with VddI
    test_value i_vdd_1p26_meas with VddI_1p26
    if HDCP then    
        test_value i_vddio_meas_hdcp with VddioI_HDCP  
        test_value i_vdd18_meas_hdcp with Vdd18I_HDCP
        test_value i_vdd_meas_hdcp with VddI_HDCP
        test_value i_vdd_1p26_meas_hdcp with VddI_1p26_HDCP  
          
     end_if
     
 end_body





procedure Isupply1X4_Max96755H_TTR(Vdd, Vddio, Vdd18, POWERUP,POWERDOWN, HDCP,Link,need_reset,TP_COAX,TX_SPD,RX_SPD,MIPI_SPD,CSI_MODE,NUMB_LANES,Link_Lock_dly,LinkLock,FW_SPD,RW_SPD,CSI_SPD,NUMBER_LANES,DesRx8_1,SerTx2_0,DesRx8_2,SerTx2_1,VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP,VddI_1p26,VddI_1p26_HDCP,LinkLock_B,DesRx8_1_B,SerTx2_0_B, VddioI_B,Vdd18I_B,VddI_B,VddioI_HDCP_B,Vdd18I_HDCP_B,VddI_HDCP_B,VddI_1p26_B,VddI_1p26_HDCP_B,VddioI_Vmax_B,Vdd18I_Vmax_B,VddI_Vmax_B,VddioI_HDCP_Vmax_B,Vdd18I_HDCP_Vmax_B,VddI_HDCP_Vmax_B,VddI_1p26_Vmax_B,VddI_1p26_HDCP_Vmax_B, LinkLock_Vmax,DesRx8_1_Vmax,SerTx2_0_Vmax, VddioI_Vmax,Vdd18I_Vmax,VddI_Vmax,VddioI_HDCP_Vmax,Vdd18I_HDCP_Vmax,VddI_HDCP_Vmax,VddI_1p26_Vmax,VddI_1p26_HDCP_Vmax)

--------------------------------------------------------------------------------
in float            : Vdd, Vddio, Vdd18
in_out integer_test : NUMBER_LANES
in boolean          : POWERUP,POWERDOWN,need_reset, HDCP
in string[20]       : TP_COAX,CSI_MODE                          -----TP_COAX : TP or COAX mode, CSI_MODE --- 1x4,2x4,1x2...
in float            : TX_SPD,RX_SPD,MIPI_SPD,Link_Lock_dly
in lword            : NUMB_LANES                                ----- number of CSI lanes 1 to 4    
in_out float_test   : FW_SPD,RW_SPD,CSI_SPD
in_out integer_test : DesRx8_1,SerTx2_0,DesRx8_2,SerTx2_1,LinkLock, DesRx8_1_B,SerTx2_0_B,LinkLock_B, LinkLock_Vmax, DesRx8_1_Vmax,SerTx2_0_Vmax
in_out float_test   : VddioI,Vdd18I,VddI,VddioI_HDCP,Vdd18I_HDCP,VddI_HDCP,VddI_1p26,VddI_1p26_HDCP
in_out float_test   : VddioI_Vmax,Vdd18I_Vmax,VddI_Vmax,VddioI_HDCP_Vmax,Vdd18I_HDCP_Vmax,VddI_HDCP_Vmax,VddI_1p26_Vmax,VddI_1p26_HDCP_Vmax
in_out float_test   : VddioI_B,Vdd18I_B,VddI_B,VddioI_HDCP_B,Vdd18I_HDCP_B,VddI_HDCP_B,VddI_1p26_B,VddI_1p26_HDCP_B
in_out float_test   : VddioI_Vmax_B,Vdd18I_Vmax_B,VddI_Vmax_B,VddioI_HDCP_Vmax_B,Vdd18I_HDCP_Vmax_B,VddI_HDCP_Vmax_B,VddI_1p26_Vmax_B,VddI_1p26_HDCP_Vmax_B
in string[2]        : Link
local



  multisite lword   : LowerRdWord, UpperRdWord
 
   
  multisite integer : LBDONE
  float             : Vconf0, Vconf1
  multisite lword   : lowword, upperword, RegTx2_0, RegTx2_1,desrx8_1,desrx8_2  --, des_read0, des_read1, des_read2, des_read

  multisite lword   : reg_val, reg_val0, reg_val1, reg_val_ser_bad, reg_val_ser_good
  multisite integer : ilinklock  , number_of_lanes_test,  iRegTx2_0, iRegTx2_1,idesrx8_1,idesrx8_2      ----ireg_val, ireg_val0, ireg_val1, ireg_val_ser_bad, ireg_val_ser_good, ireg_val15, number_of_lanes_test
  multisite integer : ilinklock_b, iRegTx2_0_b, idesrx8_1_b , ilinklock_vmax , iRegTx2_0_vmax, idesrx8_1_vmax
  multisite lword   : RegTx2_0_b, desrx8_1_b, RegTx2_0_vmax, desrx8_1_vmax
  word              : sites, idx, site
  integer           : idxs
  
  multisite lword   : hizdel_reg_val, oreg_reg_val
  lword             : data
  
--  multisite lword   : reg_val11,reg_val12,reg_val13,reg_val14,reg_val15,reg_val16,reg_val17,reg_val18,reg_val19, reg_val20,reg_val21,reg_val22,reg_val23
    lword           : ser_link_speed_code, des_link_speed_code, ser_tx_speed, ser_rx_speed, des_tx_speed, des_rx_speed
    lword           : number_of_lane, des_csi_mode,des_numb_lane,mipi_speed, ser_csi_mode

    string[20]      :  infile[4],tempp, MPW
    multisite float : i_vdd_meas[1] , i_vdd18_meas[1] , i_vddio_meas[1] , i_vterm_meas[1], i_dnut_vdd[1],i_vdd_1p26_meas[1]
    multisite float : i_vdd_meas_hdcp[1] , i_vdd18_meas_hdcp[1] , i_vddio_meas_hdcp[1] ,read_Ivddio[1,1024],i_vdd_1p26_meas_hdcp[1]
    multisite float : i_vdd_meas_vmax[1] , i_vdd18_meas_vmax[1] , i_vddio_meas_vmax[1] , i_vterm_meas_vmax[1], i_dnut_vdd_vmax[1],i_vdd_1p26_meas_vmax[1]
    multisite float : i_vdd_meas_hdcp_vmax[1] , i_vdd18_meas_hdcp_vmax[1] , i_vddio_meas_hdcp_vmax[1] ,read_Ivddio_vmax[1,1024],i_vdd_1p26_meas_hdcp_vmax[1]
    multisite float : i_vdd_meas_b[1] , i_vdd18_meas_b[1] , i_vddio_meas_b[1] , i_vterm_meas_b[1], i_dnut_vdd_b[1],i_vdd_1p26_meas_b[1]
    multisite float : i_vdd_meas_hdcp_b[1] , i_vdd18_meas_hdcp_b[1] , i_vddio_meas_hdcp_b[1] ,read_Ivddio_b[1,1024],i_vdd_1p26_meas_hdcp_b[1]
    multisite float : i_vdd_meas_b_vmax[1] , i_vdd18_meas_b_vmax[1] , i_vddio_meas_b_vmax[1] , i_vterm_meas_b_vmax[1], i_dnut_vdd_b_vmax[1],i_vdd_1p26_meas_b_vmax[1]
    multisite float : i_vdd_meas_hdcp_b_vmax[1] , i_vdd18_meas_hdcp_b_vmax[1] , i_vddio_meas_hdcp_b_vmax[1] ,read_Ivddio_b_vmax[1,1024],i_vdd_1p26_meas_hdcp_b_vmax[1]
    
    boolean         : loopcont
    multisite boolean : SiteCheck
    word            :sitecount,count

end_local


body
    loopcont  = true
   SiteCheck  = false   
    MPW = "MPW5"
    LBDONE = 0  -- need initialize to fail first
    number_of_lanes_test = integer(NUMB_LANES)
    active_sites = get_active_sites
    sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
-- -----Dut power up function
--      if vdd_global[2] > 1.05 then
--         set hcovi SER_VDD  to fv 1.2 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
--         wait(2ms)
--         set hcovi SER_VDD  to fv 1.15 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
--         wait(2ms)        
--         set hcovi SER_VDD  to fv 1.1 vmax 2.0V measure i max 600ma clamp imax 900mA imin -900mA
--         wait(5ms)
--        vdd_global[2]  = 1.1
--      end_if   
   DutPowerUp(Vddio, Vdd18, Vdd, "UART", "TP_GMSL2",POWERUP)
 
   if (need_reset) then
---Close relay to connect FPGA to control TX/RX on DNUT
        close cbit  DNUT_RXTX_RELAY
 ---Set uart or I2C freq for communication    
        fpga_set_I2C_Frequency("FPGA1", 1MHz)     -- only need this once, unless want to change freq 
        fpga_set_UART_Frequency("FPGA1", 1MHz)
        wait(1ms)

--------powerup_dnut_vdd_vterm(VDD_SET, VTERM_SET)
        powerup_dnut_vdd_vterm(1.2,1.2)
        wait(1ms)
  --fpga_Set_DNUT_Pins("FPGA1", CFG1, CFG0, PWDN, latch)
        fpga_Set_DNUT_Pins("FPGA1", 0,0, 1, 1, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)               
        wait(5ms)

-----    oreg_reg_val = fpga_read_register("FPGA1", OREG)    -- status of CFG1, CFG0, PWDN reg     
-----     reg_val0  = fpga_UART_Read("FPGA1", "DES", DESA_ID, 0, 1)      -- UART read   for debug 
 

    
 ---------close CSI feedback loop
        close cbit  FB_RELAY

----Set SER and DES for coax or tp mode
        if TP_COAX = "TP" then
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0A, "SER_UART_Write")               ---- TP mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0A)                 ---- TP mode   DR_CTRL1 = 0x11       
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS           
        else
            RegWrite(SER_ID, SR_CTRL1, 1, 16#0F, 16#0F, "SER_UART_Write")               ---- coax mode SR_CTRL1  =0X11            
            fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL1, 1, 0x0F)                 ---- coax mode   DR_CTRL1 = 0x11      
            close cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS

        end_if 

-------Set this to 3 GB
-------Set GMSL link forward and backward speed.

        if TX_SPD = 6GHz then
            ser_tx_speed = 0x8
            des_rx_speed = 0x2
        elseif      TX_SPD = 3GHz then
            ser_tx_speed = 0x4
            des_rx_speed = 0x1            
        elseif      TX_SPD = 1.5GHz then    ----need rev  = 0.1875GHz
            ser_tx_speed = 0x0
            des_rx_speed = 0x0               
       
       end_if  

        if RX_SPD = 1.5GHz then
            ser_rx_speed = 0x3
            des_tx_speed = 0xC
        elseif      RX_SPD = 0.75GHz then
            ser_rx_speed = 0x2
            des_tx_speed = 0x8      
      
        elseif      RX_SPD = 0.375GHz then
            ser_rx_speed = 0x1
            des_tx_speed = 0x4          
       elseif      RX_SPD = 0.1875GHz then
            ser_rx_speed = 0x0
            des_tx_speed = 0x0          
     
        end_if 
        ser_link_speed_code = ser_rx_speed + ser_tx_speed
        des_link_speed_code = des_rx_speed + des_tx_speed

----Program link rate

        RegWrite(SER_ID, SR_REG1, 1, 16#00, ser_link_speed_code, "SER_UART_Write")             ---- SER GMSL link speed
        fpga_UART_Write("FPGA1","DES", DESA_ID, DR_REG1, 1,des_link_speed_code  )             ---- DES GMSL link speed

        wait(20ms)     ------needed otherwise has to wait more than 100mS after oneshot command to lock


-----Write to reg10 to update link speed setting 

 

        if Link = "A" or Link = "a" then
            RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#21, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89      
        elseif Link ="B" or Link = "b" then
            RegWrite(SER_ID, SR_CTRL0, 1, 16#20, 16#22, "SER_UART_Write")    
        else  -----both link
               fpga_UART_Write("FPGA1","DES", DESA_ID, DR_CTRL0, 1,0x00  )             ---- DES GMSL link dual
               RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#30, "SER_UART_Write") 

        end_if
   
        RegRead(SER_ID,SR_CTRL0 , 1, upperword, lowword,"SER_UART_Read")      -- self adjust back to 0x01(default)

---------------------------------------------------------------------------------------------------------------------------------------------
--        set hcovi SER_VDDIO to fv Vddio   vmax 4V clamp imax 1mA imin -1mA  ---- reduce current
    
        wait(Link_Lock_dly )   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
    end_if   ----- from reset if statement        
-----Check for link lock 
        RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA          

    while( loopcont) do
        for idx = 1 to sites do 
            site = active_sites[idx]
                if  (lowword[site] = 0xde  OR lowword[site] =0xda  OR lowword[site] =0xCa OR lowword[site] =0xCE OR lowword[site] =0xEa OR lowword[site] =0xEE) and not SiteCheck[site] then
                    sitecount = sitecount + 1
                    SiteCheck[site] = true     
                end_if
                if sitecount = sites then
                    loopcont = false
                end_if     
            count = count + 1
            if count > 200 then
                loopcont  = false
            end_if
            if loopcont  then
                wait(1ms)
                RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")
            end_if
            
        end_for            
 
    end_while

-- ---Turn off Adapter EQ periodic
    RegWrite(SER_ID, SR_RLMS4_A ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMS4_B ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x15A4

    RegWrite(SER_ID, SR_RLMSA4_A ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMSA4_B ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x15A4

wait(0)
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock[site]  = integer(lowword[site])       
    end_for    

------Call function to generate color bar 1 to pipeline X
    if Link = "A" or Link = "a" or  Link = "B" or Link = "b"  then   
        GenerateColorBar_max96755H(Link)
    end_if
    if Link = "AB" or Link = "ab"    then                                ----Dual links mode
        GenerateColorBar_max96755H_DL
    end_if

    --- force CSI clk out on HS94
    --- force_CSI_out_en = 1	------ Force CSI clock out at the end eleminate 80mS delay for Reg11A update to right value 0x82 
    fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_PHY0 , 1, 0x84)

--         RegRead(SER_ID,0x16b7 , 1, upperword, lowword,"SER_UART_Read")

--------------- read back value to make sure ser has pclk and des does have video lock
    wait(10ms)  ----Need about 10ms for readout correctly
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")    ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    desrx8_1  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_0, 1)      -- lockbit expect 0x62
    
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    if Link = "AB" or Link = "ab"    then    
        desrx8_2  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_2, 1)      -- lockbit expect 0x62
        wait(1ms)
        desrx8_2  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_2, 1)      -- lockbit expect 0x62
        RegRead(SER_ID, SR_VIDEO_TX2_1, 1, upperword, RegTx2_0,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A    
        RegRead(SER_ID, SR_VIDEO_TX2_1, 1, upperword, RegTx2_1,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    end_if
------------Measure current

          if POWERUP then
        set hcovi SER_VDDIO to fv Vddio vmax 4V measure i max 1mA clamp imax 5mA imin 5mA  ---- reduce current
        --wait(50mS) 

   end_if
    --z wait(50mS) ----needed for Vdd18 current stable
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas
--    measure hcovi i on SER_VDDIO for 2048 samples every 1ms  into read_Ivddio keep previous

------Add Vdd=1.26 for supply test
---Change VDD to 1.26V for measure second set
        --z RegRead(SER_ID, SR_CTRL0, 1, upperword, lowword,"SER_UART_Read")
        --z RegRead(SER_ID, SR_CTRL2, 1, upperword, lowword,"SER_UART_Read")
        
        RegWrite(SER_ID, SR_CTRL0, 1, 0,16#15, "SER_UART_Write")----Reg_enable = 1
        RegWrite(SER_ID,SR_CTRL2, 1, 0,16#14, "SER_UART_Write")  -----LDO =1
    set hcovi SER_VDD to fv 1.26 vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
    wait(2ms)
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas
 wait(2ms)


    if HDCP then  --- turn on HDCP from ser
--          RegWrite(SER_ID, 16#1677 ,1, 0x0, 0x06	, "SER_UART_Write")
--         RegWrite(SER_ID, 0x16B8,1,0x0, 0x01, "SER_UART_Write" )
--         RegWrite(SER_ID, 16#16b9 ,1, 0x0, 0x90	, "SER_UART_Write")
--         RegWrite(SER_ID, 0x16B7,1,0x0, 0x40, "SER_UART_Write" )



           if Link = "A" then
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 0x1695 ,1, 0x0, 0x43	, "SER_UART_Write")                
           elseif Link  = "B" then
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           else
               RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")                
               RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x43	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           end_if    

------------Measure current in HDCP mode
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas_hdcp
        measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_hdcp
        measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_hdcp
---Change VDD back to set value for measure second set
        RegWrite(SER_ID, SR_CTRL0, 1, 0,16#02, "SER_UART_Write")----Reg_enable = 0
        RegWrite(SER_ID,SR_CTRL2, 1, 0,16#04, "SER_UART_Write")  -----LDO =0
        set hcovi SER_VDD to fv Vdd vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
        wait(5ms)
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_hdcp



-----Turn off HDCP
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0xC0	, "SER_UART_Write")                
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0xC0	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x2	, "SER_UART_Write")  
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x2	, "SER_UART_Write")
    end_if
    
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        idesrx8_1[site]  = integer(desrx8_1[site])       
        iRegTx2_0[site]  = integer(RegTx2_0[site])
        if Link ="AB" or Link = "ab"    then
            idesrx8_2[site]  = integer(desrx8_2[site])       
            iRegTx2_1[site]  = integer(RegTx2_1[site])
       end_if  
    end_for  
    
    


-------------- Power Down ---------------------------
----datalog DesLockbit and serPclk bit

    
    
    ------------------ Link B ------------------
    -- set Link B
    Link = "B" 
    
    RegWrite(SER_ID, SR_CTRL0, 1, 16#20, 16#22, "SER_UART_Write")
    wait(20ms )   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
    RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA
    wait(0)
    
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock_b[site]  = integer(lowword[site])       
    end_for   

      
    -- ---Turn off Adapter EQ periodic
    RegWrite(SER_ID, SR_RLMS4_A ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMS4_B ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x15A4

    RegWrite(SER_ID, SR_RLMSA4_A ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMSA4_B ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x15A4
    GenerateColorBar_max96755H(Link)
    
    --z fpga_UART_Write("FPGA1","DES", DESA_ID,DR_MIPI_PHY0 , 1, 0x84)
    
    wait(10ms)  ----Need about 10ms for readout correctly
    --RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")    ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    desrx8_1_b  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_0, 1)      -- lockbit expect 0x62
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0_b,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        idesrx8_1_b[site]  = integer(desrx8_1_b[site])       
        iRegTx2_0_b[site]  = integer(RegTx2_0_b[site])
        if Link ="AB" or Link = "ab"    then
            idesrx8_2[site]  = integer(desrx8_2[site])       
            iRegTx2_1[site]  = integer(RegTx2_1[site])
       end_if  
    end_for
    
    --z wait(50mS) ----needed for Vdd18 current stable
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_b
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_b
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_b
    
    ------Add Vdd=1.26 for supply test
    ---Change VDD to 1.26V for measure second set
        RegWrite(SER_ID, SR_CTRL0, 1, 0,16#15, "SER_UART_Write")----Reg_enable = 1
        RegWrite(SER_ID,SR_CTRL2, 1, 0,16#14, "SER_UART_Write")  -----LDO =1
    set hcovi SER_VDD to fv 1.26 vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
    wait(2ms)
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas_b
   wait(2ms)
   
    if HDCP then  --- turn on HDCP from ser 
   
   --------- HDCP turn on -----------------------------------------------------------------------------
             if Link = "A" then
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 0x1695 ,1, 0x0, 0x43	, "SER_UART_Write")                
           elseif Link  = "B" then
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           else
               RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")                
               RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x43	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           end_if    
   
   ------------Measure current in HDCP mode
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas_hdcp_b
        measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_hdcp_b
        measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_hdcp_b
---Change VDD back to set value for measure second set
        RegWrite(SER_ID, SR_CTRL0, 1, 0,16#02, "SER_UART_Write")----Reg_enable = 0
        RegWrite(SER_ID,SR_CTRL2, 1, 0,16#04, "SER_UART_Write")  -----LDO =0
        set hcovi SER_VDD to fv Vdd vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
        wait(5ms)
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_hdcp_b
        
        
        -----Turn off HDCP
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0xC0	, "SER_UART_Write")                
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0xC0	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x2	, "SER_UART_Write")  
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x2	, "SER_UART_Write")
    
    end_if
  
------------------------------------- Done Link B --------------------------------------------------------------------
------------------------------------- Vmax Set -----------------------------------------------------       
       --Set_SER_Voltages(vio, vdd, vdd18)
        Set_SER_Voltages( 3.6, 1.05, 1.9)    
        wait(2ms)
        
     measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_b_vmax
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_b_vmax
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_b_vmax
    
    ------Add Vdd=1.26 for supply test
    ---Change VDD to 1.26V for measure second set
        RegWrite(SER_ID, SR_CTRL0, 1, 0,16#15, "SER_UART_Write")----Reg_enable = 1
        RegWrite(SER_ID,SR_CTRL2, 1, 0,16#14, "SER_UART_Write")  -----LDO =1
    set hcovi SER_VDD to fv 1.26 vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
    wait(2ms)
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas_b_vmax
   wait(2ms)
   
   
 if HDCP then  --- turn on HDCP from ser  
   --------- HDCP turn on -----------------------------------------------------------------------------
             if Link = "A" then
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 0x1695 ,1, 0x0, 0x43	, "SER_UART_Write")                
           elseif Link  = "B" then
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           else
               RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")                
               RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x43	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           end_if    
   
   ------------Measure current in HDCP mode
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas_hdcp_b_vmax
        measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_hdcp_b_vmax
        measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_hdcp_b_vmax
---Change VDD back to set value for measure second set
        RegWrite(SER_ID, SR_CTRL0, 1, 0,16#02, "SER_UART_Write")----Reg_enable = 0
        RegWrite(SER_ID,SR_CTRL2, 1, 0,16#04, "SER_UART_Write")  -----LDO =0
        set hcovi SER_VDD to fv Vdd vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
        wait(5ms)
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_hdcp_b_vmax
        
                -----Turn off HDCP
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0xC0	, "SER_UART_Write")                
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0xC0	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x2	, "SER_UART_Write")  
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x2	, "SER_UART_Write")
    
    end_if
  
    
------------------------------------ Vmax Done --------------------------------------------------------
  ----------------------------------- Link A Vmax -----------------------------------------------------  
       -- set Link A
    Link = "A" 
    RegWrite(SER_ID, SR_CTRL0, 1, 16#30, 16#21, "SER_UART_Write")                           ---Set auto link config and one shot; auto link will select both links for HS89 
        wait(20ms )   --NEEDED to see LOCK bits on both SER/DES at 3G serial links !!!
    RegRead(SER_ID, 16#13, 1, upperword, lowword,"SER_UART_Read")    -- for SER lock bit, good if 0xCA
    wait(0)
    
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        ilinklock_vmax[site]  = integer(lowword[site])       
    end_for   

      
    -- ---Turn off Adapter EQ periodic
    RegWrite(SER_ID, SR_RLMS4_A ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMS4_B ,1, 0x00 , 0x28, "SER_UART_Write" )---------0x15A4

    RegWrite(SER_ID, SR_RLMSA4_A ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x14A4
    RegWrite(SER_ID, SR_RLMSA4_B ,1, 0x00 , 0x00, "SER_UART_Write" )---------0x15A4
    --z GenerateColorBar_max96755H(Link)
    
    wait(20ms)  ----Need about 10ms for readout correctly
    --RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0,"SER_UART_Read")    ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    desrx8_1_vmax  = fpga_UART_Read("FPGA1", "DES", DESA_ID, DR_VIDEO_RX8_0, 1)      -- lockbit expect 0x62
    RegRead(SER_ID, SR_VIDEO_TX2_0, 1, upperword, RegTx2_0_vmax,"SER_UART_Read")     -- ----Read PCLK dectect bit expect 0xCA. second read will be 0x8A
    
    for idxs = 1 to len(active_sites) do
        site = active_sites[idxs]
        idesrx8_1_vmax[site]  = integer(desrx8_1_vmax[site])       
        iRegTx2_0_vmax[site]  = integer(RegTx2_0_vmax[site])
        if Link ="AB" or Link = "ab"    then
            idesrx8_2[site]  = integer(desrx8_2[site])       
            iRegTx2_1[site]  = integer(RegTx2_1[site])
       end_if  
    end_for
    
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_vmax
    measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_vmax
    measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_vmax
    
    ------Add Vdd=1.26 for supply test
    ---Change VDD to 1.26V for measure second set
        RegWrite(SER_ID, SR_CTRL0, 1, 0,16#15, "SER_UART_Write")----Reg_enable = 1
        RegWrite(SER_ID,SR_CTRL2, 1, 0,16#14, "SER_UART_Write")  -----LDO =1
    set hcovi SER_VDD to fv 1.26 vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
    wait(2ms)
    measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas_vmax
   wait(2ms)
   
   
 if HDCP then  --- turn on HDCP from ser  
   --------- HDCP turn on -----------------------------------------------------------------------------
             if Link = "A" then
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 0x1695 ,1, 0x0, 0x43	, "SER_UART_Write")                
           elseif Link  = "B" then
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           else
               RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0x40	, "SER_UART_Write")                
               RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0x40	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x43	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x43	, "SER_UART_Write")
           end_if    
   
   ------------Measure current in HDCP mode
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_1p26_meas_hdcp_vmax
        measure hcovi i on SER_VDD18 for 20 samples every 10us averaged into i_vdd18_meas_hdcp_vmax
        measure hcovi i on SER_VDDIO for 20 samples every 10us averaged into i_vddio_meas_hdcp_vmax
---Change VDD back to set value for measure second set
        RegWrite(SER_ID, SR_CTRL0, 1, 0,16#02, "SER_UART_Write")----Reg_enable = 0
        RegWrite(SER_ID,SR_CTRL2, 1, 0,16#04, "SER_UART_Write")  -----LDO =0
        set hcovi SER_VDD to fv Vdd vmax 4V measure i max 500mA clamp imax 500mA imin 500mA  ---- reduce current
        wait(5ms)
        measure hcovi i on SER_VDD for 20 samples every 10us averaged into i_vdd_meas_hdcp_vmax
        
                -----Turn off HDCP
                RegWrite(SER_ID, 16#16B7 ,1, 0x0, 0xC0	, "SER_UART_Write")                
                RegWrite(SER_ID, 16#17B7 ,1, 0x0, 0xC0	, "SER_UART_Write")
                RegWrite(SER_ID, 16#1695 ,1, 0x0, 0x2	, "SER_UART_Write")  
                RegWrite(SER_ID, 16#1795 ,1, 0x0, 0x2	, "SER_UART_Write")
    
    end_if
  
    
    
    
    
  --------------------------------- Link A Vmax Done -----------------------------------------------------------------  
    
    if (POWERDOWN) then

------- turn off MIPI clocks from DES
            fpga_UART_Write("FPGA1","DES", DESA_ID, 16#0330, 1, 0x04)         
         fpga_Set_DNUT_Pins("FPGA1", 0,0, 0, 0, TRUE)  -- UART/TP/GMSL2=1/RATE=0(6 Gig link)    
--          powerup_dnut_vdd_vterm(0.0,0.0) 
--           wait(20mS)
            set digital pin ALL_PATTERN_PINS   - FPGA_CSB-FPGA_SCLK-FPGA_SDIN-FPGA_SDOUT   levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
            open cbit  CB2_SLDC + COAXB_M_RELAY         --OVI_RELAYS 
            open cbit  FB_RELAY
            powerdown_device(POWERDOWN)

      end_if 


--------Data log
    test_value ilinklock with LinkLock
    
    test_value msfloat(TX_SPD) with FW_SPD     
    test_value msfloat(RX_SPD) with RW_SPD  
    test_value msfloat(MIPI_SPD) with CSI_SPD
    test_value number_of_lanes_test with NUMBER_LANES
    
    test_value idesrx8_1 with DesRx8_1
    test_value iRegTx2_0 with SerTx2_0
    if Link = "AB" or Link = "ab" then
        test_value idesrx8_2 with DesRx8_2
        test_value iRegTx2_1 with SerTx2_1    
    end_if     
    test_value i_vddio_meas with VddioI  
    test_value i_vdd18_meas with Vdd18I
    test_value i_vdd_meas with VddI
    test_value i_vdd_1p26_meas with VddI_1p26
    if HDCP then    
        test_value i_vddio_meas_hdcp with VddioI_HDCP  
        test_value i_vdd18_meas_hdcp with Vdd18I_HDCP
        test_value i_vdd_meas_hdcp with VddI_HDCP
        test_value i_vdd_1p26_meas_hdcp with VddI_1p26_HDCP  
          
     end_if
     
 
     
     
     ----- Link B ------------------
     test_value ilinklock_b with LinkLock_B
     test_value idesrx8_1 with DesRx8_1_B
     test_value iRegTx2_0 with SerTx2_0_B
     
     test_value i_vddio_meas_b with VddioI_B  
     test_value i_vdd18_meas_b with Vdd18I_B
     test_value i_vdd_meas_b with VddI_B
     test_value i_vdd_1p26_meas_b with VddI_1p26_B
    
     if HDCP then 
        
        test_value i_vddio_meas_hdcp_b with VddioI_HDCP_B  
        test_value i_vdd18_meas_hdcp_b with Vdd18I_HDCP_B
        test_value i_vdd_meas_hdcp_b with VddI_HDCP_B
        test_value i_vdd_1p26_meas_hdcp_b with VddI_1p26_HDCP_B  
          
     end_if
     
     ---- Link B Vmax
     
        test_value i_vddio_meas_b_vmax with VddioI_Vmax_B  
        test_value i_vdd18_meas_b_vmax with Vdd18I_Vmax_B
        test_value i_vdd_meas_b_vmax with VddI_Vmax_B
        test_value i_vdd_1p26_meas_b_vmax with VddI_1p26_Vmax_B
    
     if HDCP then 
        
        test_value i_vddio_meas_hdcp_b_vmax with VddioI_HDCP_Vmax_B  
        test_value i_vdd18_meas_hdcp_b_vmax with Vdd18I_HDCP_Vmax_B
        test_value i_vdd_meas_hdcp_b_vmax with VddI_HDCP_Vmax_B
        test_value i_vdd_1p26_meas_hdcp_b_vmax with VddI_1p26_HDCP_Vmax_B  
     
     end_if
     
     ---------Link A Vmax -------------------------------------------------
     test_value ilinklock_vmax with LinkLock_Vmax
     test_value idesrx8_1_vmax with DesRx8_1_Vmax
     test_value iRegTx2_0_vmax with SerTx2_0_Vmax
     
     test_value i_vddio_meas_vmax with VddioI_Vmax  
     test_value i_vdd18_meas_vmax with Vdd18I_Vmax
     test_value i_vdd_meas_vmax with VddI_Vmax
     test_value i_vdd_1p26_meas_vmax with VddI_1p26_Vmax
    
     if HDCP then 
        
        test_value i_vddio_meas_hdcp_vmax with VddioI_HDCP_Vmax  
        test_value i_vdd18_meas_hdcp_vmax with Vdd18I_HDCP_Vmax
        test_value i_vdd_meas_hdcp_vmax with VddI_HDCP_Vmax
        test_value i_vdd_1p26_meas_hdcp_vmax with VddI_1p26_HDCP_Vmax  
          
     end_if
     
  
     
 end_body






procedure WS_trim_info(vdd, vdd18, vio, vterm, DEVICE_ADDR_ID,POWERUP,POWERDOWN,WFRNUM,XLOC,YLOC,LOTNUM1, LOTNUM2, LOTNUM3, LOTNUM4, LOTNUM5, LOTNUM6, LOTNUM7, LOTNUM8, LOTNUM9, stuckdetectlim)
--------------------------------------------------------------------------------
--  
in float            : vdd, vdd18, vio, vterm
in word             : DEVICE_ADDR_ID      -- SER_ID or DES_ID
in boolean          : POWERUP,POWERDOWN
in_out integer_test :  XLOC, YLOC, WFRNUM
in_out integer_test : LOTNUM1, LOTNUM2, LOTNUM3, LOTNUM4, LOTNUM5, LOTNUM6, LOTNUM7, LOTNUM8, LOTNUM9
in_out array of integer_test: stuckdetectlim



local


lword               : addr, bit
integer             : idx,q,trim_fail_count
word                : siteidx, thissite

multisite lword     : reg_data,reg_data1
multisite integer   : regvalue
word                :  DEV_ID 






multisite lword     :  otp_addr
integer             : array_index
word                :  sites, site, begin_sites

multisite lword     :  ws_read_value[8]
multisite integer       : lot_chr1, lot_chr2, lot_chr3, lot_chr4, lot_chr5, lot_chr6, lot_chr7, lot_chr8, lot_chr9
multisite integer       : x_rslt, y_rslt, wafer_rslt, x_coord_rd, y_coord_rd



  word list[16]         : current_active_sites_retest
  word LIST[MAX_SITES]  : local_active_sites
  word                  : Csite, local_sites, c
  word                  : inx
  multisite integer     : DevIdCalc
  multisite integer     : IntDieID, IntDieRev
  multisite integer     : WAFERHEX, XHEX, YHEX, foundStuck, n
  boolean               : StuckDetect

end_local






body

static    lword     : serial_number =  0


  current_active_sites = get_active_sites()
  sites = word(len(current_active_sites))

   DEV_ID = DEVICE_ADDR_ID


------------ Power Up HS89 -----------------------
-- 
--     active_sites = get_active_sites
--     sites = word(len(active_sites))  

    --POWER_CONNECT    -- need this for reseting device
    
    -- can take out later but keep for now to make sure all MFP pins connected to DPs
      open cbit MFP_LT_RELAY  

    --make sure RSVD pin float (HVVI disconnect)
    disconnect hvvi chan SER_RSVD    -- need to float RSVD, important!!
    connect digital pin ALL_PATTERN_PINS to dcl
    disconnect digital pin SER_CAPVDD from dcl                 -- need to float CAP_VDD pin  
    wait(3ms) 

        -----Dut power up function
   DutPowerUp(vio, vdd18, vdd, "UART", "TP_GMSL2",POWERUP)

 wait(0ms) 

----Check WS INFO
            OTP_Reg_Write(DEV_ID, OTP0,1, mlw(0x40), 0,mlw(0))---Enable OPT read 
            OTP_Reg_Write(DEV_ID, OTP1,1, mlw(0x00), 0, mlw(0))---Select GMSL section        
   
       for  addr =0  to  0x4 do ---  ws info
            otp_addr =  32*(addr)	   
            OTP_Reg_Write(DEV_ID, 16#1802,2, otp_addr, 0,mlw(0x00) )---set address to read from
            array_index = array_index + 1 
            reg_data = OTP_Reg_Read(DEV_ID, 16#1814, 4)
            for siteidx = 1 to sites do  
                thissite =current_active_sites [siteidx]                   
                ws_read_value[thissite,addr + 1] = reg_data[thissite]
            end_for    
       end_for
       

----Process and decode data
    for siteidx = 1 to sites do
        thissite = current_active_sites[siteidx]

--         lot_id_scramble[thissite] = chr(ws_trim_info[1])+chr(ws_trim_info[2])+chr(ws_trim_info[3])+chr(ws_trim_info[4])+chr(ws_trim_info[5])+chr(ws_trim_info[6])+chr(ws_trim_info[7])+chr(ws_trim_info[8])+chr(ws_trim_info[9])
        lot_chr1[thissite] = integer((ws_read_value[thissite,2] & 16#0000FF00)>>8)
        lot_chr2[thissite] = integer((ws_read_value[thissite,2] & 16#00FF0000)>>16)
        lot_chr3[thissite] = integer((ws_read_value[thissite,2] & 16#FF000000)>>24)
        lot_chr4[thissite] = integer((ws_read_value[thissite,3] & 16#000000FF)>>0)
        lot_chr5[thissite] = integer((ws_read_value[thissite,3] & 16#0000FF00)>>8)
        lot_chr6[thissite] = integer((ws_read_value[thissite,3] & 16#00FF0000)>>16)
        lot_chr7[thissite] = integer((ws_read_value[thissite,3] & 16#FF000000)>>24)
        lot_chr8[thissite] = integer((ws_read_value[thissite,4] & 16#000000FF)>>0)
        lot_chr9[thissite] = integer((ws_read_value[thissite,4] & 16#0000FF00)>>8)
        wafer_rslt[thissite] = integer((ws_read_value[thissite,2] & 16#000000FF) >> 0)
        x_coord_rd[thissite] = integer((ws_read_value[thissite,1] & 16#0000FFFF) >> 0)
        y_coord_rd[thissite] = integer((ws_read_value[thissite,1] & 16#FFFF0000) >> 16)

    if (x_coord_rd[thissite] >> 15 = 1) then
        x_rslt[thissite] = integer((x_coord_rd[thissite] & 16#7FFF)*(-1))
    else
        x_rslt[thissite] = x_coord_rd[thissite]
    end_if
    
    if (y_coord_rd[thissite] >> 15 = 1) then
        y_rslt[thissite] = integer((y_coord_rd[thissite] & 16#7FFF)*(-1))
    else
        y_rslt[thissite] = y_coord_rd[thissite]
    end_if
    
    end_for




wait(0)


---------------- Power Off -------------------
--   disconnect digital pin OTP_FAIL_PIN + OTP_DONE_PIN from ppmu
--   connect digital pin OTP_FAIL_PIN + OTP_DONE_PIN to dcl
  wait(200us)
--------  DutPowerDown
 ------ Power Off ----
  set digital pin ALL_PATTERN_PINS - fpga_pattern_pins levels to vil 0V vih 100mV iol 0uA ioh 0uA vref 0V
  wait(100us)
  
  set digital pin ALL_PATTERN_PINS modes to comparator enable all fails
  set hcovi SER_VDD+SER_VDDIO +SER_VDD18 to fv 0V vmax 4V clamp imax 600mA imin -600mA   

  wait(3ms)     -- extra for 47uF cap on SER_VDD    
  -- Initialize for set_SER_Voltages(vio, vcore, v18) routine
  vdd_global[1] = 0V   --SER_VDDIO
  vdd_global[2] = 0V   --SER_VDD  
  vdd_global[3] = 0V   --SER_VDDA(VDD18)

----Datalog out



get_expr("OpVar_StuckDetect", StuckDetect)       
if (OptoolModeCheckStatic == 0) then
local_active_sites = get_active_sites()
local_sites = word(len(local_active_sites))

    for inx = 1 to local_sites do
    Csite = local_active_sites[inx]
    WAFERHEX[Csite] = (wafer_rslt[Csite] << 16)
        if (x_rslt[Csite] < 0) then
            XHEX[Csite] = ((abs(x_rslt[Csite]) + 128) << 8)
            else
            XHEX[Csite] = (x_rslt[Csite] << 8)
            end_if
        if (y_rslt[Csite] < 0) then
            YHEX[Csite] = (abs(y_rslt[Csite]) + 128)
            else
            YHEX[Csite] = y_rslt[Csite]
            end_if
        CurDevCode[Csite] = WAFERHEX[Csite] + XHEX[Csite] + YHEX[Csite]
        if (CurDevCode[Csite] == 0) or (wafer_rslt[Csite]>50) then  -- hcu 04/30/2020 added preconditional for wafer bogus data to avoid invalid stuck alarm
            foundStuck[Csite] = 1
        else_if (CurDevCode[Csite] <> PrevDevCode[Csite]) then
            foundStuck[Csite] = 0
            StuckCounter[Csite] = 0
        else
            foundStuck[Csite] = (-1)
            StuckCounter[Csite] = StuckCounter[Csite] + 1
        end_if
        PrevDevCode[Csite] = CurDevCode[Csite]  -- 01/13/2020 hcu added missing code to get the previous value
    end_for

  if StuckDetect then
        test_value foundStuck with stuckdetectlim
    else
        n = foundStuck
        c = word(n[1] + n[2] + n[3] +n[4])
        if c = local_sites*(-1) then
            LoopCntr = LoopCntr + 1
        else
            ChDevIns = TRUE
        end_if
    end_if

end_if    




    test_value wafer_rslt           with WFRNUM
    test_value x_rslt               with XLOC
    test_value y_rslt               with YLOC
    test_value lot_chr1             with LOTNUM1
    test_value lot_chr2             with LOTNUM2
    test_value lot_chr3             with LOTNUM3
    test_value lot_chr4             with LOTNUM4
    test_value lot_chr5             with LOTNUM5
    test_value lot_chr6             with LOTNUM6
    test_value lot_chr7             with LOTNUM7
    test_value lot_chr8             with LOTNUM8
    test_value lot_chr9             with LOTNUM9
    


end_body

function Ucase (UsrStr) :   string[132]
  in string[132]: UsrStr

local
  string[132]: UcaseStr
  integer    : Sidx, StrLen
end_local

body
  StrLen = len(UsrStr)
  for Sidx = 1 to StrLen do
    if asc(UsrStr[Sidx]) > 96 and asc(UsrStr[Sidx]) < 123 then
      UcaseStr = UcaseStr + chr(asc(UsrStr[Sidx]) - 32)
    else
      UcaseStr = UcaseStr + UsrStr[Sidx]
    endif
  endfor

  return(UcaseStr)
end_body


