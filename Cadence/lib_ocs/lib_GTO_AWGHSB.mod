
-------------------------------------------------------------------------------------------
--                                                                                       --
--                                  REVISION LOG                                         --
--                                                                                       --
-- Revision         Who     Comments                                                     --
--                          
--
-- Oct 11 2005      BS      Rev 0   Original Code                                        --
-- 
-- RCS Revision level: $Id: GTO_AWGHSB.mod,v 1.1 2006/05/18 12:44:54 wdc Exp wdc $       --
--
-- June 13 2008    BS       Rev 2   Added Spread Spectrum Clocking                       --
--
-- Oct 10 2008      BS      Rev 3    Added PRBS7_20CID data pattern                      --
--
-- Oct 27 2008      BS      Rev 3.1    Added PRBS7_96CID data pattern                      --
-- May 27 2011      PLA     Rev 3.2    Updated "use module" statements to reflect 
--                                     renamed modules called in this module

-------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------
--                              MODULE DESCRIPTION 
--

--  This module contains procedures for controlling GTO Front End clocks, jitter injection
-- and jitter related testing.  Included within this module are the following procedures:


--  ********************  "CalibrateJitClkRJ" ***************************
-- This procedure is intended to calibrate the random jitter generated by the VXGTO transmitter output and
-- should be used as a focused calibration executed once during program load for each required magnitude of 
-- Random Jitter.  
-- Amplitude of the VXGTO/S Jitter Clock input affects the magnitude of the random jitter generated by
-- the VXGTO/S onto its transmitted data.  A repeating 1010..10 pattern should be used as the calibration
-- waveform.  Iteratively, the random jitter is measured and the Jitter Clock's amplitude is adjusted until 
-- the measured random jitter has the specified magnitude. A Spec Mask parameter has to be defined in an
-- enVision Spec Object so that the derived Jitter Clock amplitude can be stored in the Spec Mask parameter.
-- Then later in DUT testing the Jitter Clock's amplitude is set to the value stored in the Spec Mask parameter
-- to inject the required magnitude of random jitter.


--  ********************  "GenerateAndCalSinusoidalJitter" ***************************
-- This procedure is intended to calibrate injected sinusoidal jitter generated by the VXGTO transmitter output and
-- should be used as a focused calibration executed once during program load for each required injected jitter waveform. 
-- Up to 3 Jitter tones may be included in a single waveform.  Maximum frequency of injected Jitter is limited by the
-- maximum sampling rate of the AWGHS to below 60MHz.  Each individual jitter waveform is identified by a unique string name
-- passed into this procedure.  The string identifier can later be used by other procedures within this module to inject the 
-- specified jitter waveform. 


--  ********************  "JitterTransfer" ***************************
-- This procedure causes the VXGTO transmitted output to apply predefined injected jitter to a DUT's input
-- and measure that jitter transferred to the DUT's output.  Measurement results are compared to limits and
-- datalogged.  The applied input waveform must be a square pattern, such as a repeating 1010...10 pattern 
-- or a repeating 11001100...1100 data pattern.


--  ********************  "JitterTransfer3dBBandwidth" ***************************
-- This procedure reads in the jitter transfer of two sinusoidal jitter tones and derives the frequency of the
-- jitter transfer 3dB bandwidth.  The jitter transfer 3dB bandwidth is compared to limits and datalogged.  One of the 
-- tested jitter tones should be at or below the specified low frequency limit and the other jitter tone should be at 
-- or above the high frequency limit.


--  ********************  "JitterPeaking" ***************************
-- This procedure measures jitter peaking, compares to limits and datalogs the measurement.
-- The procedure reads in two jitter transfer measurements, which should have use the same jitter at two different
-- magnitudes.  The difference between the two measurements is the result of jitter peaking measurement.  


--  ********************  "JitterToleranceSetup" ***************************
-- This procedure sets up the VXGTO transmitted output with programmed injected jitter on a specified data pattern.
--  Sinusoidal jitter is provided by IQ modulation of the jitter clock with a specified jitter tone. Random Jitter 
-- is controlled by Jitter Clock level.  Data Dependent Jitter is provided by an Inter-Symbol-Interference generator 
-- from a  selected custom user path. 


--  ********************  "ReadPrbsBitErrorRate" ***************************
--  This procedure causes the VXGTO/S to test PRBS data from a device under
--  test and derive Bit Error Rate from selected pattern.


--  ********************  "GtoSilent" ***************************
--  This procedure is used to generate a silent or no data output from the VXGTO transmitter output/


--  ********************  "GenerateSpreadSpectrum" ***************************
--  This procedure generates Spread Spectrum clocking to specified frequency spread percentage at at 
--  specified modulation frequency.
 
--  ********************  "GtoAwghsInit" ***************************
-- The Initialize entry point is called when the program is loaded. It is normally used for
-- all one-time instrument setups, 


-------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------
--                                                                                       --
--                              TEST PROGRAM  MODULES                                    --
--                                                                                       --
  use module "../lib/lib_gtoFrontEndCtrl.mod"
  use module "../lib/lib_gtoFrontEndConsts.mod"
  use module "../lib/lib_clkCtrl.mod"
  use module "lib_SamplerDighs.mod"
  use module "lib_Dist.mod"

-------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------
--                                                                                       --                           
--                             GENERAL CONSTANTS                                         --                                       
--                                                                                       --

const    
    MAX_GTOS                          = 4         -- Maximum Number of VXGTO-S channels
    MAX_AWGHS                         = 2         -- Maximum Number of AWGHS channels
    MAX_NO_JITTER_TONES               = 3         -- Maximum number of concurrent jitter tones
    MAX_NO_OF_JITTER_NAMES            = 30        -- Maximum number Injected Jitter Modulation Names
    AWGHS_I_CHAN                      = 1         -- AWSHS channel used for in phase modulation
    AWGHS_Q_CHAN                      = 2         -- AWSHS channel used for quadrature modulation
    AWGHSB_I_CHAN                     = 1         -- AWSHS channel used for in phase modulation
    AWGHSB_Q_CHAN                     = 2         -- AWSHS channel used for quadrature modulation
    AWGHSB_JITTER_TONE_SAMPLES        = 32768               -- Number of waveform samples should equal that of measuring digitizer
    AWGHSB_SAMPLING_FREQ              = SAMP_DIGHS_SPECTRUM_CLK_FREQ * 2.0            -- Sampling frequency for jitter tone generation
    AWGHSB_TONE_BIN_SIZE              = AWGHSB_SAMPLING_FREQ/AWGHSB_JITTER_TONE_SAMPLES -- Jitter Tone Bin Size
    AWGHSB_SS_SAMPLING_FREQ           = 245.76MHz
    AWGHSB_SS_SAMPLES                 = 65536   --
    GTB_SRC                           = 0         -- Normal GTO source connection constant
    
    AWG520_ADDR                         = 23
    -- VXGTO AND MODULATION CLOCKS SELECTION CONSTANTS --
    JIT_CLK                          = 1        -- Jitter Clock
    SYS_CLK                          = 2        -- System Clock
    TX_ODD_WORD                      = 3        -- Word Clock out from VXGTO TX odd Channel
    TX_EVEN_WORD                     = 4        -- Word Clock out from VXGTO TX even Channel
    DUT_CLK                          = 5        -- Clock imported from DUT Board
    AUX_CLK                          = 6        -- Reference or Auxillary Clock
    SAMP_CLK                         = 7        -- Sampler Clock
    TX_WORD                          = 8        -- Word Clock out from same Channel TX
    JIT_CLK_INV                      = 9        -- Inverted Jitter Clock

end_const
static
     boolean      : NyquistSampling = true
     boolean      : use_awghsb = true   -- Set this boolean false to use awghs instead of awghsb, otherwise set true
     boolean      : use_awg520 = false   -- Set this boolean false to use awghs instead of awghsb, otherwise set true
     boolean      : SpreadSpecGenPass1 = true
     float        : apex
     float        : ph
    string[32]    : JitterName[MAX_NO_OF_JITTER_NAMES]
     float        : OffsetC[MAX_NO_OF_JITTER_NAMES] 
     float        : OffsetS[MAX_NO_OF_JITTER_NAMES] 
     float        : RangeC[MAX_NO_OF_JITTER_NAMES]
     float        : RangeS[MAX_NO_OF_JITTER_NAMES]
     float        : AwghsbTone[MAX_NO_OF_JITTER_NAMES]
     float        : AwghsbRolloff[80]
     boolean      : FullSpectrum       = false -- Set true to observe the full spectrum in status display
     boolean      : DataviewerCharText = false -- Set true to print characterization data in text format
    
     float        : apexCorrect [ 100 ]
     float        : magCorrect [ 100 ]
     double       : exSamplingFreq
     lword        : Comma_K28_5_pattern[20]
     lword        : Comma_2XK28_5_pattern[20]
     lword        : Comma_4XK28_5_pattern[20]
     lword        : Comma_8XK28_5_pattern[20]
     lword        : prbs_7_2bit_pattern[508]
     lword        : prbs_7_4bit_pattern[508]
     lword        : prbs_7_8bit_pattern[508]
     lword        : prbs_7Inv_8bit_pattern[508]
     lword        : prbs_7Inv_2bit_pattern[508]
     lword        : prbs_7Inv_4bit_pattern[508]
     lword        : GtoTenthRate_pattern[20]
     lword        : GtoTenthRate_4bit_pattern[20] 
     lword        :  prbs7_20cid_pattern[588]   
     lword        :  prbs7_96cid_pattern[892]   
end_static

static word       : awg520waveFileAry [ 2^20 ]
procedure GtoAwghsbInit
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- The Initialize entry point is called when the program is loaded. It is normally used for
-- all one-time instrument setups, 
------------------------------------------------------------------------------------------------------------

local
   lword           : GtoHalfRate_pattern[8]
   lword           : GtoQuarterRate_pattern[8]
   lword           : GtoEighthRate_pattern[8]
   lword           : GtoSixteenthRate_pattern[8]
   lword           : GtoThirtysecondRate_pattern[8]
   lword           : GtoSixtyFourthRate_pattern[8]
   lword           : GtoOneTwentyEighthRate_pattern[8]
   lword           : Silent_pattern[20]
   integer         : i
 set[MAX_GTOS]     : GtoS_Pins
end_local
body

    -- INITIALIZE JITTER CLOCK
    InitJitterClk   
    -- INITIALIZE AWGHSB
    JitterName = ""
    println(stdout,"Initializing AWGHS chans")

    SpectrumCal102 = 1.0
    SpectrumCal51 = 1.0
    SpectrumCal25 = 1.0
    if use_awghsb then
        initialize awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> 
        set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> offset to ground
        set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to max  1.0 lpf 100MHz
        AwghsbRolloff = 1.0

    elseif use_awg520 then
    
    else

        initialize awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> hardware and memory
        set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> common offset to gnd
        set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> range to 1.0
    endif
          
        -- INITIALIZE VXGTO-S
           GtoS_Pins = inventory_all_chans("vx_gto")
           reset vx_gto GtoS_Pins 
  
           GtoHalfRate_pattern = 16#aaaaaaaa
           load vx_gto GtoS_Pins output pattern GtoHalfRate_pattern identified by "HalfRate" 

           GtoQuarterRate_pattern = 16#cccccccc
           load vx_gto GtoS_Pins output pattern GtoQuarterRate_pattern identified by "QuarterRate" 

           GtoEighthRate_pattern = 16#f0f0f0f0
           load vx_gto GtoS_Pins output pattern GtoEighthRate_pattern identified by "EighthRate" 

           GtoSixteenthRate_pattern = 16#ff00ff00
           load vx_gto GtoS_Pins output pattern GtoSixteenthRate_pattern identified by "SixteenthRate" 

           GtoThirtysecondRate_pattern = 16#ffff0000
           load vx_gto GtoS_Pins output pattern GtoThirtysecondRate_pattern identified by "32ndRate" 

           for i = 1 to 8 do
               if i mod 2 = 1 then
                   GtoSixtyFourthRate_pattern[i] = 16#ffffffff
               else
                   GtoSixtyFourthRate_pattern[i] = 16#00000000
               end_if
           end_for
           load vx_gto GtoS_Pins output pattern GtoSixtyFourthRate_pattern identified by "64thRate" 

           GtoOneTwentyEighthRate_pattern[1:2] = 16#ffffffff
           GtoOneTwentyEighthRate_pattern[3:4] = 16#00000000
           GtoOneTwentyEighthRate_pattern[5:8] = GtoOneTwentyEighthRate_pattern[1:4]
           load vx_gto GtoS_Pins output pattern GtoOneTwentyEighthRate_pattern identified by "128thRate" 

           MakeTenthRatePattern
           load vx_gto GtoS_Pins output pattern GtoTenthRate_pattern identified by "TenthRate"
            
           Make4BitTenthRatePattern
           load vx_gto GtoS_Pins output pattern GtoTenthRate_4bit_pattern identified by "X4TenthRate" 
 
           MakeComma_K28_5_pattern
           load vx_gto GtoS_Pins output pattern Comma_K28_5_pattern identified by "K28_5" 

           Make_2XK28_5_pattern
           load vx_gto GtoS_Pins output pattern Comma_2XK28_5_pattern identified by "X2K28_5" 

           Make_4XK28_5_pattern
           load vx_gto GtoS_Pins output pattern Comma_4XK28_5_pattern identified by "X4K28_5" 

           Make_8XK28_5_pattern
           load vx_gto GtoS_Pins output pattern Comma_8XK28_5_pattern identified by "X8K28_5" 

           Make2BitPrbs7Pattern
           load vx_gto GtoS_Pins output pattern prbs_7_2bit_pattern identified by "X2PRBS7" 

           Make2BitPrbs7InvPattern
           load vx_gto GtoS_Pins output pattern prbs_7Inv_2bit_pattern identified by "X2PRBS7Inv" 

           Make4BitPrbs7Pattern
           load vx_gto GtoS_Pins output pattern prbs_7_4bit_pattern identified by "X4PRBS7" 

           Make4BitPrbs7InvPattern
           load vx_gto GtoS_Pins output pattern prbs_7Inv_4bit_pattern identified by "X4PRBS7Inv" 

           Make8BitPrbs7Pattern
           load vx_gto GtoS_Pins output pattern prbs_7_8bit_pattern identified by "X8PRBS7" 

           Make8BitPrbs7InvPattern
           load vx_gto GtoS_Pins output pattern prbs_7Inv_8bit_pattern identified by "X8PRBS7Inv" 

           Silent_pattern = 0
           load vx_gto GtoS_Pins output pattern Silent_pattern identified by "Silent"
           
           MakePrbs7_20CidPattern
           load vx_gto GtoS_Pins output pattern prbs7_20cid_pattern identified by "PRBS7_20CID"
         
           MakePrbs7_96CidPattern
           load vx_gto GtoS_Pins output pattern prbs7_96cid_pattern identified by "PRBS7_96CID"

end_body
procedure GenerateJitterTones(JitPatName,JitTone,JitToneAmp,AWG_FiltFreq) 
------------------------------------------------------------------------------------------------------------
in string[32]       : JitPatName                    -- A string identifier for selected Injected Sinusoidal Jitter Tones
in float            : JitTone[?]                    -- Array of Injected Jitter Tone Frequencies  -- Maximum size set to 3 Tones
in float            : JitToneAmp[?]                 -- Array of Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
out float           : AWG_FiltFreq                  -- Reconstruction Filter frequency defined by this procedure
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure generates IQ modulation waveforms for jitter injection and loads them into the AWGHS channels. 
-- The waveforms are identified by the input string identifier, which can later be used to modulate the selected 
-- clock with the specified injected jitter
------------------------------------------------------------------------------------------------------------
local 
     float        : JitterCosPattern[AWGHSB_JITTER_TONE_SAMPLES]
     float        : JitterSinPattern[AWGHSB_JITTER_TONE_SAMPLES]
     float        : InitPolarJitter[AWGHSB_JITTER_TONE_SAMPLES*2]
     float        : CartesianArray[AWGHSB_JITTER_TONE_SAMPLES*2]
     float        : CorrectionAry[AWGHSB_JITTER_TONE_SAMPLES]
     integer      : NoOfInjectedTones
     integer      : i,j
     integer      : JitPat
     float        : MaxFreq
     double       : SamplingFreq
     float        : ToneBinSize
     integer      : harmonic[MAX_NO_JITTER_TONES]
     float        : ToneAmp[MAX_NO_JITTER_TONES]
     float        : PhaseShift
     float        : TonePhaseShift[MAX_NO_JITTER_TONES]
     float        : TonePhase
     float        : CorrectionSinx_x 
     float        : CosXtrmAry[4]   
     float        : SinXtrmAry[4]
     float        : maxOut
     float        : waveformSz     
    integer       : numSamp
end_local         
static float     : Sinx_xAry[AWGHSB_JITTER_TONE_SAMPLES]
const          Pi  = 3.14159265359

body


    if use_awg520 then
        waveformSz = 8.0
        SamplingFreq = double ( waveformSz * JitTone [ 1 ] )
    else 
        waveformSz = float ( AWGHSB_JITTER_TONE_SAMPLES )
        SamplingFreq = double ( AWGHSB_SAMPLING_FREQ )
    endif
    
    
    if use_awg520 then    
        for i = 1 to 8 do
            if SamplingFreq > 500MHz or waveformSz > 512.0 then
                break
            endif
            waveformSz = waveformSz * 2.0
            SamplingFreq = double ( waveformSz * JitTone [ 1 ] )
        endfor
    endif
    
    numSamp = integer ( waveformSz )

    if Sinx_xAry[1] <> 1.0 then
        Sinx_xAry = 0.0
        for i = 1 to numSamp/2 - 1 do
            CorrectionSinx_x  = Pi*float(i)/float(numSamp)/sin(Pi*float(i)/float(numSamp))
            Sinx_xAry[2*i]    = CorrectionSinx_x
            Sinx_xAry[2*i+ 1] = CorrectionSinx_x
        end_for
        Sinx_xAry[1] = 1.0
    end_if

    NoOfInjectedTones = dimsize(JitTone,1)
    MaxFreq = 0.0
    for i = 1 to NoOfInjectedTones do
        if MaxFreq < JitTone[i] then 
            MaxFreq = JitTone[i]
        end_if
    end_for
    
    AWG_FiltFreq = JitTone [ 1 ] * ( 1.0 + JitToneAmp [ 1 ] * 3.141592 )

    i = 1
    while  (JitterName[i] <> JitPatName) and (i <= MAX_NO_OF_JITTER_NAMES) do
        if JitterName[i] = "" then  
            JitterName[i] = JitPatName          
        else
            i = i + 1
       end_if
    end_while
    JitPat = i
    AwghsbTone[JitPat] = JitTone[1]
    

    if use_awg520 then
        ToneBinSize = JitTone [ 1 ]
    else 
        if MaxFreq < (AWGHSB_SAMPLING_FREQ/16.0 - AWGHSB_TONE_BIN_SIZE) then
            SamplingFreq = AWGHSB_SAMPLING_FREQ/2.0
            ToneBinSize = AWGHSB_TONE_BIN_SIZE/2.0
        else_if MaxFreq < (AWGHSB_SAMPLING_FREQ/2.0 - 2.0 * AWGHSB_TONE_BIN_SIZE) then
            SamplingFreq =  AWGHSB_SAMPLING_FREQ
            ToneBinSize = AWGHSB_TONE_BIN_SIZE
            if (not use_awghsb) or (not use_awg520) then
                SamplingFreq = SamplingFreq/2.0
                ToneBinSize = ToneBinSize/2.0
            end_if
        end_if
    endif

    PhaseShift        = Pi/4.0

    --******** Note:  Number of array element for TonePhaseShift must equal environment constant MAX_NO_JITTER_TONES ********
    TonePhaseShift[1] = 0.0     
    TonePhaseShift[2] = Pi/3.0
    TonePhaseShift[3] = 4.0*Pi/3.0
    
    if use_awghsb then
        stop awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:>
    elseif use_awg520 then
        talk cx to gpib adr AWG520_ADDR with "AWGCONTROL:STOP:IMMEDIATE"
    else
        stop awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:>
    end_if

    for i = 1 to NoOfInjectedTones do
        harmonic[i] = integer(JitTone[i]/ToneBinSize +0.5)        
        if (not use_awghsb) and (ToneBinSize = AWGHSB_TONE_BIN_SIZE) then
            harmonic[i] = 2 * harmonic[i]
        end_if
        if harmonic[i] = 0 then
            ToneAmp[i] = 0.0
        else
            ToneAmp[i] = Pi * JitToneAmp[i] * (Pi*float(harmonic[i])/float( numSamp ))/sin(Pi*float(harmonic[i])/float( numSamp )) -- reference to UI with sinx/x correction
        end_if
    end_for

    if NyquistSampling and  use_awghsb then
        if (MaxFreq > (AWGHSB_SAMPLING_FREQ/6.0)) and (MaxFreq <= (AWGHSB_SAMPLING_FREQ/5.0)) then
            SamplingFreq = double(harmonic[1]) * AWGHSB_TONE_BIN_SIZE * 32768.0/6554.0
            harmonic[1] = 6554
        else_if (MaxFreq > (AWGHSB_SAMPLING_FREQ/5.0)) and (MaxFreq <= (AWGHSB_SAMPLING_FREQ/4.0)) then
            SamplingFreq = double(harmonic[1]) * AWGHSB_TONE_BIN_SIZE * 32768.0/8192.0
            harmonic[1] = 8192
        else_if (MaxFreq > (AWGHSB_SAMPLING_FREQ/4.0)) and (MaxFreq <= (AWGHSB_SAMPLING_FREQ/3.0)) then
            SamplingFreq = double(harmonic[1]) * AWGHSB_TONE_BIN_SIZE * 32768.0/10923.0
            harmonic[1] = 10923
        end_if
    endif

    for i = 1 to  numSamp  do
        InitPolarJitter[2*i] = PhaseShift
        for j = 1 to NoOfInjectedTones do
            TonePhase  = ToneAmp[j] * sin(float(harmonic[j] * i) * 2.0 * Pi/float( numSamp ) + TonePhaseShift[j])
            InitPolarJitter[2*i] =  (InitPolarJitter[2*i] + TonePhase)
        end_for
        InitPolarJitter[2*i] = InitPolarJitter[2*i] * 180.0/Pi
        InitPolarJitter[2*i-1] = 1.0
    end_for
    
    CartesianArray = polar_to_cartesian(InitPolarJitter)

    for i = 1 to  numSamp  do
        JitterCosPattern[i] = 1.0 * CartesianArray[2*i-1]
        JitterSinPattern[i] = 1.0 *  CartesianArray[2*i]
    end_for
    
    CorrectionSinx_x = Pi*JitTone[1]/float(SamplingFreq)/sin(Pi*JitTone[1]/float(SamplingFreq))
    CorrectionAry [ 1 : numSamp ] = fft(JitterCosPattern [ 1 : numSamp ] )
    CorrectionAry = CorrectionAry * Sinx_xAry 
    JitterCosPattern [ 1 : numSamp ] = inverse_fft(CorrectionAry [ 1 : numSamp ] )
    CorrectionAry [ 1 : numSamp ] = fft(JitterSinPattern [ 1 : numSamp ] )
    CorrectionAry = CorrectionAry * Sinx_xAry 
    JitterSinPattern [ 1 : numSamp ] = inverse_fft(CorrectionAry [ 1 : numSamp ] )
     -- a -g JitterCosPattern[1:100]
     -- a -g JitterSinPattern[1:100]

    RangeC[JitPat] = 1.0
    RangeS[JitPat] = 1.0
    OffsetC[JitPat] = 0.0 
    OffsetS[JitPat] =  0.0
    
    if JitTone [ 1 ] = 52.0MHz and use_awghsb then
        SineJitterTest ( JitToneAmp [ 1 ] , JitterCosPattern , JitterSinPattern )
    endif
    
    
    maxOut = max ( abs ( JitterCosPattern )  )
    if maxOut > 0.999 then 
        JitterCosPattern = 0.999 * JitterCosPattern / maxOut
        JitterSinPattern = 0.999 * JitterSinPattern / maxOut
    endif
    maxOut = max ( abs ( JitterSinPattern )  )
    if maxOut > 0.999 then 
        JitterCosPattern = 0.999 * JitterCosPattern / maxOut
        JitterSinPattern = 0.999 * JitterSinPattern / maxOut
    endif

    while numSamp < 256 do
        JitterCosPattern [ 1 + numSamp : 2 * numSamp ] = JitterCosPattern [ 1 : numSamp ]  
        JitterSinPattern [ 1 + numSamp : 2 * numSamp ] = JitterSinPattern [ 1 : numSamp ]  
        numSamp = 2 * numSamp
    endwhile

    if use_awghsb then   
        load  awghsb AWGHSB_I_CHAN pattern JitPatName  with JitterCosPattern 
        load  awghsb AWGHSB_Q_CHAN pattern JitPatName  with JitterSinPattern
        set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> sample rate to SamplingFreq 
        set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> clock to internal 
        
         -- ag plots; a -g JitterCosPattern ; grid
         -- ag plots; a -g JitterSinPattern ; grid
         wait(0ms)
         
    elseif use_awg520 then
        WriteAwg520WaveformFile ( JitPatName + "Cos" , JitterCosPattern [ 1 : numSamp ] , SamplingFreq , i , awg520waveFileAry )
        WriteAwg520WaveformFile ( JitPatName + "Sin" , JitterSinPattern [ 1 : numSamp ] , SamplingFreq , i , awg520waveFileAry )
    else
        set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> sample rate to SamplingFreq 
        load  awghs chan AWGHS_I_CHAN pattern JitPatName  with JitterCosPattern 
        load  awghs chan AWGHS_Q_CHAN pattern JitPatName  with JitterSinPattern
    end_if       
       
       exSamplingFreq = SamplingFreq
endbody
------------------------------------------------------------------------------------------------------------
procedure GenerateAndCalSinisoidalJitter(GTO_S_Chans,SampDighsPins,JitPatName,DataPatName,BitsPerWaveform,DataRate,MeasLevelMax,MeasurementScale,SourceClock,ModulateClock, DutClockFreq,SamplerConnection,JitTone,JitToneAmp)
 in pin list[MAX_GTOS]  : GTO_S_Chans                  -- Selected VXGTO-S Channels           
 in pin list[MAX_DIGHS] : SampDighsPins                -- Selected DIGHS Channels                
 in string[32]          : JitPatName                   -- A string identifier for selected Injected Sinusoidal Jitter Tones
 in string[32]          : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
 in integer             : BitsPerWaveform              -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
 in double              : DataRate                     -- Data Rate of Transmitted data
 in  float              : MeasLevelMax                 -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
 in  float              : MeasurementScale                -- Scale factor to correct for attenuation in measurement path  
 in integer             : SourceClock                  -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
 in integer             : ModulateClock                -- Selected Clock to Apply Jitter Enter JIT_CLK for Jitter Clock, AUX_CLK for reference (Aux) Clock, or SAMP_CLK for Sampler Clock
 in double              : DutClockFreq                 -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock
 in multisite integer   : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float                : JitTone[?]                   -- Array of Injected Jitter Tone Frequencies  -- Maximum size set to 3 Tones
in float                : JitToneAmp[?]                -- Array of Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure is intended to calibrate injected sinusoidal jitter generated by the VXGTO transmitter output and
-- should be used as a focused calibration executed once during program load for each required injected jitter waveform. 
-- Up to 3 Jitter tones may be included in a single waveform.  Maximum frequency of injected Jitter is limited by the
-- maximum sampling rate of the AWGHS to below 60MHz.  Each individual jitter waveform is identified by a unique string name
-- passed into this procedure.  The string identifier can later be used by other procedures within this module to inject the 
-- specified jitter waveform. 
------------------------------------------------------------------------------------------------------------
local
    float              : JitToneScale[MAX_NO_JITTER_TONES]          -- Scaled injected jitter tone amplitudes for calibration
    multisite  float   : JitToneMeas[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Measured jitter tone amplitudes
    multisite  float   : JitToneAvg[MAX_DIGHS*MAX_NO_JITTER_TONES]  -- Measured jitter tone amplitudes
    float              : FreqBinSize                                -- Frequency Bin Size in jitter injection spectrum 
    float              : AWG_FiltFreq                               -- Reconstruction Filter Selection also used for sampling rate selection.
    float              : DiffLevel = 0.9999                         -- Differential VXGTO-S output level used during injected jitter calibration
    float              : MaxFreq
    float              : JitMeasUI
    float              : JitAmpRef
    double             : ScopeSyncFreq
    integer            : NoOfInjectedTones                          -- Number of periodic jitter tones frequencies to be processed
    integer            : i
    integer            : TxConnection = BALANCED
    multisite double   : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysisend_local 
    boolean            : ScopeView 
end_local
body


    print(stdout,"Calibrating SJ  ",JitPatName:20," at ",DataRate!fu=GHz:12:6," with ",JitToneAmp:8:4,"UI")

    if tester_simulated then
        return
    end_if

    JitAmpRef = JitToneAmp[1]
    SelectGtoSrcClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq) 
    GenerateJitterTones(JitPatName,JitTone,JitToneAmp,AWG_FiltFreq) 
    StartJitterModulation(JitPatName,ModulateClock,AWG_FiltFreq)

    NoOfInjectedTones = dimsize(JitTone,1)
    MaxFreq = 0.0
    for i = 1 to NoOfInjectedTones do
        if MaxFreq < JitTone[i] then 
            MaxFreq = JitTone[i]
        end_if
    end_for


    if JitTone <> 52MHz then
        StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)
        FullSpectrum = true
        SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,MaxFreq * 2.0)
        wait(100.0ms)
        JitToneAvg = 0.0
        for i = 1 to 16 do
            JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)
            JitToneAvg = JitToneAvg + JitToneMeas
        end_for
        JitToneMeas = JitToneAvg/16.0


        --***** Adjust Tone Gain **********

        for i = 1 to NoOfInjectedTones do
            JitToneScale[i] = JitToneAmp[i]/(JitToneMeas[1,i] * float(DataRate)) 
            JitToneAmp[i] = JitToneScale[i] * JitToneAmp[i]
            print(stdout,"  Tone#",i,"  JitToneScale : ",JitToneScale[i])
        end_for
        GenerateJitterTones(JitPatName,JitTone,JitToneAmp,AWG_FiltFreq)  
    endif

    println(stdout,"")

    --******* Verify Generated Injected Jitter Tines
    if DisplayMode then   --   **** Set DisplayMode true to observe Spectrum in Status Display ****        
         StartJitterModulation(JitPatName,ModulateClock,AWG_FiltFreq)
         SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,MaxFreq * 2.0)
         wait(100.0ms)
         FullSpectrum = true
         JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)
         JitMeasUI = JitToneMeas[1,1] * float(DataRate)
         FullSpectrum = false
         if MaxFreq * 2.0 < (SAMP_DIGHS_SPECTRUM_CLK_FREQ/4.0 - SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES) then
             FreqBinSize = SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES/2.0
         else
             FreqBinSize = SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES
         end_if
                   
            
                          -- a -g  SpectrumRef; grid   
                                 --**** Enter Numeric values -- scale -mult FreqBinSize  -offset 0.0                   
                          -- units -x MHz
                          -- units -y dB                

                    wait(0mS)   -- SET BREAKPOINT HERE TO OBSERVE WAVEFORM ON STATUS DISPLAY
   end_if

    ScopeView = false
    if ScopeView then
        ScopeSyncFreq = DataRate/double(BitsPerWaveform)/double(integer(DataRate/double(BitsPerWaveform)/500MHz)+1)
        SetSampleClkFrequency(ScopeSyncFreq)
        --GTB_SetSampleClockDivider ( 1 , 4 )
        wait(1ms)  -- SET BREAKPOINT HERE TO OBSERVE WAVEFORM ON OSCILLOSCOPE
    end_if

end_body
procedure SelectGtoSrcClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq)
---------------------------------------------------------------------------------------------------------------
in pin list[MAX_GTOS]   : GTO_S_Chans  -- Selected VXGTO-S Channels           
in double               : DataRate               -- Data Rate of Transmitted data
in integer              : SourceClock            -- JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
in double               : DutClockFreq           -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock

body
---------------------------------------------------------------------------------------------------------------
-- This procedure selects the source of VXGTO transmitter channel input clock.  If the clock selected isa the Jitter Clock
-- then the Jitter Clock's frequency will be set to the specified Data Rate.
---------------------------------------------------------------------------------------------------------------
    if SourceClock = JIT_CLK then
       EnableJitterClk("on",DataRate)      
       set vx_gto GTO_S_Chans output bit rate frequency to DataRate   
       set vx_gto GTO_S_Chans output clock mode to jitter_clk
    else_if SourceClock = SYS_CLK then
       set vx_gto GTO_S_Chans output bit rate frequency to DataRate   
       set vx_gto GTO_S_Chans output clock mode to normal
    else_if SourceClock = DUT_CLK then
       set vx_gto GTO_S_Chans output bit rate frequency to DataRate   
       --set vx_gto GTO_S_Chans output clock mode to dut_clk  frequency to DutClockFreq
       println (stdout , "Error! dut_clk is no longer suppported. From: GTO_AWGHSB.mod/SelectGtoSrcClk ")
       halt
       --********* NOTE: Source of DUT Clock must be programmed to provid a clock at frequency "DutClockFreq" *******
       --*********  where "DutClockFreq" must be an inter subdivision of "DataRate" and in the range of 70MHz to 800MHz *******
    else
        println(stdout, "Illegal VXGTO-S transmit clock selection in procedure 'SelectGtoSrcClk'") 
        println(stdout, "SourceClock Argument to procedure 'SelectGtoSrcClk' must be 'JIT_CLK', 'SYS_CLK' or 'DUT_CLK'")
        println(stdout, "Halted from procedure 'SelectGtoSrcClk'")
        halt
    endif
                          
endbody
---------------------------------------------------------------------------------------------------------------
procedure StartJitterModulation(JitPatName,ModulateClock,AWG_FiltFreq)
in string[32] : JitPatName      -- Name of selected jitter injection AWGHS waveforms  -- Waveforms generated by procedure GenerateJitterTone
in INTEGER    : ModulateClock   -- Enter JIT_CLK for Jitter Clock or AUX_CLK for Auxiliary Clock
in float      : AWG_FiltFreq    -- AWGHS' reconstruction filter low pass cutoff frequence 
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- This procedure causes the specified clock source to be modulated with the jitter waveform
-- defined by input string identifier (JitPatName).  The jitter waveform defined by the string 
-- identifier has be previously generated and is stored in the AWGHS memory.
-------------------------------------------------------------------------------------------
local
    integer      : i
    integer      : JitPat
    float        : OffsetScale
    string [ 256 ]: str
end_local
body

        if  ModulateClock = JIT_CLK then
            if use_awghsb then
--error            
                connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to output b single ended pos -- Needed before R14.4
                connect awghsb <:AWGHSB_I_CHAN,AWGHS_Q_CHAN:> to system coax
            elseif use_awg520 then
                
            else
                connect awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> to system coax        
            end_if
            SetJitterClkModulation("iq")
        else_if ModulateClock  = AUX_CLK then
            if use_awghsb then
                connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to user coax -- Needed before R14.4
            else
                connect awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> to user coax            
            end_if
            SetAuxiliaryClkIQ ( "on" )
           -- SetAuxiliaryClkMod ( "on" )
        else
            println(stdout,"ERROR : Invalid ModulateClock selected")
            println(stdout,"Valid options are : JIT_CLK or AUX_CLK")
            println(stdout,"Halting from procedure : StartJitterModulation")
            halt
        end_if

     i = 1
     while  (JitterName[i] <> JitPatName) and (i <= MAX_NO_OF_JITTER_NAMES) do
        i = i + 1
     end_while
     JitPat = i

        if RangeC [ JitPat ] < RangeS [ JitPat ] then
            RangeC [ JitPat ] = RangeS [ JitPat ]
        endif
        RangeC = 1.0
        RangeS = 1.0
        if use_awghsb then
            stop awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:>
        elseif use_awg520 then
            talk cx to gpib adr AWG520_ADDR with "AWGCONTROL:STOP:IMMEDIATE"
            talk cx to gpib adr AWG520_ADDR with "SOURCE1:VOLTAGE:LEVEL:IMMEDIATE 1.0"
            talk cx to gpib adr AWG520_ADDR with "SOURCE2:VOLTAGE:LEVEL:IMMEDIATE 1.0"
            talk cx to gpib adr AWG520_ADDR with "SOURCE1:VOLTAGE:LEVEL:IMMEDIATE:OFFSET 0.0"
            talk cx to gpib adr AWG520_ADDR with "SOURCE2:VOLTAGE:LEVEL:IMMEDIATE:OFFSET 0.0"
        else
            if  RangeC[JitPat] >= 250.0mV then
                if RangeC[JitPat] > 1.00 then
                    RangeC[JitPat] = 0.99999
                end_if
                set awghs chan AWGHS_I_CHAN range to v1
                set awghs chan AWGHS_I_CHAN gain to RangeC[JitPat] 
            else
                set awghs chan AWGHS_I_CHAN range to mv250
                set awghs chan AWGHS_I_CHAN gain to RangeC[JitPat] * 4.0 
            end_if
            if  RangeS[JitPat] >= 250.0mV then
                if RangeS[JitPat] > 1.00 then
                    RangeS[JitPat] = 0.99999
                end_if
                set awghs chan AWGHS_Q_CHAN range to v1
                set awghs chan AWGHS_Q_CHAN gain to RangeS[JitPat] 
            else
                set awghs chan AWGHS_Q_CHAN range to mv250
                set awghs chan AWGHS_Q_CHAN gain to RangeS[JitPat] * 4.0 
            end_if
            stop awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:>
        end_if
                             
  
        if use_awghsb then
            if AWG_FiltFreq > 100MHz then
                AWG_FiltFreq = 100MHz
            endif
            set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to max RangeC[JitPat] lpf AWG_FiltFreq
        elseif use_awg520 then
            talk cx to gpib adr AWG520_ADDR with "OUTPUT1:FILTER:FREQUENCY " + sprint ( AWG_FiltFreq:8:9 )
            talk cx to gpib adr AWG520_ADDR with "OUTPUT2:FILTER:FREQUENCY " + sprint ( AWG_FiltFreq:8:9 )
        else
            set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> filter to wideband        
        end_if
        
        OffsetScale = 0.0
        AwghsbRolloff = 1.0
        if AwghsbTone[JitPat] >= 1.0MHz then
            OffsetScale = 1.0/AwghsbRolloff[integer(AwghsbTone[JitPat]/1.0MHz)]
        else
             OffsetScale = 1.0/AwghsbRolloff[1]
        end_if
         OffsetScale = 0.1
       
        if use_awghsb then
            set awghsb AWGHSB_I_CHAN  offset to   (OffsetS[JitPat] * OffsetScale) * 2.0 
            set awghsb AWGHSB_Q_CHAN  offset to  (OffsetS[JitPat] * OffsetScale) * 2.0 
            initialize cx sync        
            connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> trigger to sync3  
            start awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> pattern JitPatName  -- triggered 
        elseif use_awg520 then
            talk cx to gpib adr AWG520_ADDR with "SOURCE1:VOLTAGE:LEVEL:IMMEDIATE 1.0"
            talk cx to gpib adr AWG520_ADDR with "SOURCE2:VOLTAGE:LEVEL:IMMEDIATE 1.0"
            talk cx to gpib adr AWG520_ADDR with "SOURCE1:VOLTAGE:LEVEL:IMMEDIATE:OFFSET 0.0"
            talk cx to gpib adr AWG520_ADDR with "SOURCE2:VOLTAGE:LEVEL:IMMEDIATE:OFFSET 0.0"
 --           talk cx to gpib adr AWG520_ADDR with "AWGCONTROL:FG:STATE OFF"
            talk cx to gpib adr AWG520_ADDR with "AWGCONTROL:RMODE CONTINUOUS"
            talk cx to gpib adr AWG520_ADDR with "SOURCE1:FUNCTION:USER" + " '" + JitPatName + "Cos.wfm','NET1'"
            talk cx to gpib adr AWG520_ADDR with "SOURCE2:FUNCTION:USER" + " '" + JitPatName + "Sin.wfm','NET1'"
            talk cx to gpib adr AWG520_ADDR with "AWGCONTROL:RUN:IMMEDIATE"
            talk cx to gpib adr AWG520_ADDR with "SOURCE1:FREQUENCY:CW " + sprint ( exSamplingFreq:8:9 )
            talk cx to gpib adr AWG520_ADDR with "SOURCE2:FREQUENCY:CW " + sprint ( exSamplingFreq:8:9 )
            talk cx to gpib adr AWG520_ADDR with "OUTPUT1:STATE ON"
            talk cx to gpib adr AWG520_ADDR with "OUTPUT2:STATE ON"
--            talk cx to gpib adr AWG520_ADDR with "STATUS:QUES:EVENT?"
--            listen cx to gpib adr AWG520_ADDR into str for 255 bytes
        else
            set awghs chan AWGHS_I_CHAN common offset to  (OffsetC[JitPat] * OffsetScale) 
            set awghs chan AWGHS_Q_CHAN common offset to  (OffsetS[JitPat] * OffsetScale) 
            initialize cx sync        
            set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> to arm with sync3 trigger 
            start awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> pattern JitPatName trigger on sync3 
        end_if
        generate cx sync3 trigger

    wait(0.0ms)
end_body

procedure SelectGtoRcvrClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq)
in pin list[MAX_GTOS ] : GTO_S_Chans  -- Selected VXGTO-S Channels           
in double    : DataRate               -- Data Rate of Transmitted data
in integer   : SourceClock            -- JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
                                      -- TX_ODD_WORD for odd channels TX word clock out or TX_EVEN_WORD for even TX word clock out
in double    : DutClockFreq           -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock
local
   integer            : ChanPtr
   integer            : PortCount
   integer            : SitePtr
   integer            : SiteCount
   word list[16]      : SiteList
 word list[MAX_DIGHS] : GtoPins
end_local
body
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
-- This procedure selects the source of VXGTO receiver channel input clock.  If the clock selected isa the Jitter Clock
-- then the Jitter Clock's frequency will be set to the specified Data Rate.
---------------------------------------------------------------------------------------------------------------
     GtoPins    = vxgto_ptc(GTO_S_Chans)
     SiteList   = get_active_sites
     SiteCount  = len( SiteList)
     PortCount  = len(GTO_S_Chans)

     set vx_gto GTO_S_Chans input bit rate frequency to DataRate   

       if SourceClock = JIT_CLK then
            set vx_gto GTO_S_Chans input clock mode to jitter_clk
            EnableJitterClk("on",DataRate)      
       else_if SourceClock = JIT_CLK_INV then
            set vx_gto GTO_S_Chans input clock mode to jitter_clk inverted
       else_if SourceClock = TX_ODD_WORD then
            set vx_gto GTO_S_Chans input clock mode to word_clk from tx1
       else_if SourceClock = TX_EVEN_WORD then
            set vx_gto GTO_S_Chans input clock mode to word_clk from tx2
       else_if SourceClock = TX_WORD then
          for SitePtr = 1 to SiteCount do
             for ChanPtr = 1 to PortCount do 
                 if GtoPins[(SitePtr-1) * PortCount + ChanPtr] mod 2 = 1 then
                     set vx_gto GtoPins[(SitePtr-1) * PortCount + ChanPtr]  input clock mode to word_clk from tx1
                 else
                     set vx_gto GtoPins[(SitePtr-1) * PortCount + ChanPtr]  input clock mode to word_clk from tx2
                 end_if
             end_for
         end_for
     else_if SourceClock = SYS_CLK then
       set vx_gto GTO_S_Chans input clock mode to normal
    else_if SourceClock = DUT_CLK then
       --set vx_gto GTO_S_Chans input clock mode to dut_clk  frequency to DutClockFreq
       println (stdout , "Error! dut_clk is no longer suppported. From: GTO_AWGHSB.mod/SelectGtoRcvrClk ")
       halt
       --********* NOTE: Source of DUT Clock must be programmed to provid a clock at frequency "DutClockFreq" *******
       --*********  where "DutClockFreq" must be an inter subdivision of "DataRate" and in the range of 70MHz to 800MHz *******
    else
        println(stdout, "Illegal VXGTO-S receiver clock selection in procedure 'SelectGtoSrcClk'") 
        println(stdout, "SourceClock Argument to procedure 'SelectGtoSrcClk' must be 'JIT_CLK', 'SYS_CLK' or 'DUT_CLK'")
        println(stdout, "Halted from procedure 'SelectGtoSrcClk'")
        halt
    end_if
                          
end_body
procedure StartGtoDataOutput(GTO_S_Chans,DataPatName,TxOutLevel,TxConnection,forceHighRange)
------------------------------------------------------------------------------------------------
in pin list[MAX_GTOS] : GTO_S_Chans  -- Selected VXGTO-S Channels           
in string[32]          : DataPatName  -- A string identifier for selected VXGTO TX Data pattern
in float               : TxOutLevel   -- Programmed VXGTO-S TX output level
in integer             : TxConnection --  GTO Front End TX output connection mode  -- Enter BALANCED for Differential,SE_PLUS for non-inverting output, or SE_MINUS for the inverting output
in boolean             : forceHighRange
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- This procedure starts the VXGTO TX output to transmit the specified pattern at the specified
-- output level and mode.
------------------------------------------------------------------------------------------------
local
  word list[MAX_DIGHS] : GtoPins
end_local
body

    GtoPins = vxgto_ptc(GTO_S_Chans)
    stop vx_gto GTO_S_Chans output
    wait ( 0.02 )
    GTB_SetSourceLevel (GtoPins ,TxConnection ,TxOutLevel, forceHighRange )
    
    if TxOutLevel >= 1.0 then
        GTB_SelectSourceMUXPath ( <: 1 :> , <: 1 :> ) -- ****CJH 05/11/06 TEMPORARY FIX!!!
    end_if
    
    if  DataPatName = "alignment" then
        start vx_gto GTO_S_Chans output with alignment pattern 
    else_if DataPatName[1:4] = "prbs" then
        if DataPatName = "prbs7" then
            start vx_gto GTO_S_Chans output with prbs7 pattern
        else_if DataPatName = "prbs15" then
            start vx_gto GTO_S_Chans output with prbs15 pattern
        else_if DataPatName = "prbs23" then
            start vx_gto GTO_S_Chans output with prbs23 pattern
        else_if DataPatName = "prbs31" then
            start vx_gto GTO_S_Chans output with prbs31 pattern
        else_if DataPatName = "prbs7Inv" then
            start vx_gto GTO_S_Chans output with prbs7 pattern inverted
        else_if DataPatName = "prbs15Inv" then
            start vx_gto GTO_S_Chans output with prbs15 pattern inverted
        else_if DataPatName = "prbs23Inv" then
            start vx_gto GTO_S_Chans output with prbs23 pattern inverted
        else_if DataPatName = "prbs31Inv" then
            start vx_gto GTO_S_Chans output with prbs31 pattern inverted
        end_if
    else 
        start vx_gto GTO_S_Chans output with user pattern  DataPatName   
    end_if 
    wait(1.0ms)   
    
end_body
------------------------------------------------------------------------------------------------
procedure JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)
in pin list[MAX_DIGHS] : SampDighsPins                              -- Selected DIGHS Channels           
in integer             : BitsPerWaveform                            -- Length in bits in the waveform (e.g. 2 for repeating 1010...10 data pattern)
in double              : DataRate                                   -- Data rate of waveform being tested
in float               : MeasLevelMax                               -- Maximum differential voltage expected in measured waveform 
in float               : JitTone[?]                                 -- Frequency of jitter tone   
out multisite float    : JitToneMeas[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Peak to Peak (UI) magnitude of jitter Tone.
out multisite double   : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysis
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure measures the amplitude of injected jitter of up to three known jitter frequencies.  
-- Measured amplitude of the specified input frequencies, as well as the random jitter's measured magnitude is returned
------------------------------------------------------------------------------------------------------------

local
   float               : NoiseFreqMin                               -- Low Noise frequency High Pass Brick wall cutoff 
   float               : NoiseFreqHP_Corner                         -- Low Noise frequency High Pass 3dB cutoff
   float               : FiltFreq                                   -- Antialiasing Filter frequency
   float               : MaxBinSize
   float               : BinSize
   float               : MaxFreq
   float               : TestAlias
   boolean             : StartOnTrigger = false                     -- Waveform capture starts on detection of sync1 from digital pattern
   multisite float     : JitterTones[MAX_DIGHS,MAX_NUM_TONES]       -- Periodic Jitter Tone Frequencies measured by procedure SpectrumAnalysis
   multisite float     : PP_Jitter[MAX_DIGHS,MAX_NUM_TONES]         -- Periodic Tone's Jitter P-P measured by procedure SpectrumAnalysis 
   integer             : NoOfInjectedTones                          -- Number of Jitter Tones Injected
   integer             : SitePtr
   integer             : ChanPtr
   integer             : PortCount
   integer             : Tone
   integer             : TonePosition
   integer             : ToneCount
   integer             : CountTone
   integer             : AliasPtr
   integer             : SiteCount
   word list[16]       : SiteList
end_local
body
  
     SiteList          = get_active_sites
     SiteCount         = len(SiteList)
     PortCount         = len(SampDighsPins)
     NoOfInjectedTones = dimsize(JitTone,1)
     MaxBinSize        = SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES
     NoiseFreqMin      = 20MHz                              -- Low Noise frequency High Pass Brick wall cutoff 

   MaxFreq = 0.0
    for Tone = 1 to NoOfInjectedTones do
        if MaxFreq < JitTone[Tone] then 
            MaxFreq = JitTone[Tone]
        end_if
    end_for

    if MaxFreq * 2.0 < (SAMP_DIGHS_SPECTRUM_CLK_FREQ/4.0 - SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES) then
        if FullSpectrum then
            FiltFreq = SAMP_DIGHS_SPECTRUM_CLK_FREQ/4.0 - SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES *3/2 
            NoiseFreqMin = 12.0KHz
         else
            FiltFreq = MaxFreq * 2.0
        end_if
        BinSize = MaxBinSize/2.0
    else
        if FullSpectrum then
            FiltFreq = SAMP_DIGHS_SPECTRUM_CLK_FREQ/2.0 - SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES  
            NoiseFreqMin = 50.0KHz
        else
            FiltFreq =  MaxFreq * 2.0
        end_if
        BinSize = MaxBinSize
    end_if


  
    for Tone = 1 to NoOfInjectedTones do
        if JitTone[Tone] < (NoiseFreqMin - 45KHz) then
            NoiseFreqMin = JitTone[Tone] - 45KHz
        end_if
        JitTone[Tone] = float(integer(JitTone[Tone]/BinSize + 0.5)) * BinSize                                        
    end_for
    if NoiseFreqMin < BinSize*4.0 then
         NoiseFreqMin = BinSize*4.0
    end_if
    NoiseFreqHP_Corner = NoiseFreqMin

    SpectrumAnalysis(SampDighsPins,BitsPerWaveform,DataRate,StartOnTrigger,MeasLevelMax,NoiseFreqMin,NoiseFreqHP_Corner,FiltFreq,MAX_NUM_TONES, RandomJitter,JitterTones,PP_Jitter)

    --JitToneMeas[1,1] = PP_Jitter[1,1,1] --WYANG????
    
--     ????????????????????????????? WYANG 2/4/2009
    for SitePtr = 1 to SiteCount do
      for ChanPtr = 1 to PortCount do
        Tone     = 0
        ToneCount = 0
        while (Tone < MAX_NUM_TONES) and (ToneCount < NoOfInjectedTones) do
            Tone = Tone + 1
            for CountTone = 1 to NoOfInjectedTones do
                TestAlias = abs(SAMP_DIGHS_SPECTRUM_CLK_FREQ -2.0 * MaxBinSize - JitTone[CountTone] - JitterTones[SitePtr,ChanPtr,Tone])
                if (JitTone[CountTone]  < (SAMP_DIGHS_SPECTRUM_CLK_FREQ/2.0 - MaxBinSize)) and (JitTone[CountTone] = JitterTones[SitePtr,ChanPtr,Tone]) then
                    TonePosition = (ChanPtr - 1) * NoOfInjectedTones + CountTone
                    JitToneMeas[SitePtr,TonePosition] = PP_Jitter[SitePtr,ChanPtr,Tone]
                    ToneCount = ToneCount + 1
                else_if (JitTone[CountTone] >= (SAMP_DIGHS_SPECTRUM_CLK_FREQ/2.0 - MaxBinSize)) and (TestAlias < 20.0) then
                    TonePosition = (ChanPtr - 1) * NoOfInjectedTones + CountTone
                    AliasPtr = integer((SAMP_DIGHS_SPECTRUM_CLK_FREQ - JitTone[CountTone])/BinSize + 0.5) * 2 + 1
                    JitToneMeas[SitePtr,TonePosition] = PP_Jitter[SitePtr,ChanPtr,Tone] * SpectrumCal102[(SitePtr -1) * PortCount + ChanPtr,AliasPtr]
                    ToneCount = ToneCount + 1
                end_if
            end_for
        end_while
      end_for
    end_for
    
end_body
procedure StopJitterModulation(ModulateClock)
in INTEGER    : ModulateClock   -- Enter JIT_CLK for Jitter Clock or  AUX_CLK for Auxiliary Clock
------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- This procedure disable IQ modulation of the specified clock, stopping jitter injection to
-- that clock.
-------------------------------------------------------------------------------------------
body

    if  ModulateClock = JIT_CLK then
        SetJitterClkModulation("off")
    elseif ModulateClock  = AUX_CLK then
        SetAuxiliaryClkIQ ( "off" )
       -- SetAuxiliaryClkMod ( "off" )
    else
        println(stdout,"ERROR : Invalid ModulateClock selected")
        println(stdout,"Valid options are : JIT_CLK or AUX_CLK")
        println(stdout,"Halting from procedure : StopJitterModulation")
        halt
    endif
    
    if use_awghsb then
        stop awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:>
    elseif use_awg520 then
        talk cx to gpib adr AWG520_ADDR with "AWGCONTROL:STOP:IMMEDIATE"
    else
        stop awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:>
    endif

end_body


procedure JitterToleranceSetup(GTO_S_Chans,JitPatName,DataPatName,DataRate,DiffLevel,TxConnection,DutClockFreq,JitTone,GTO_SrcPath)
in pin list[MAX_GTOS]  : GTO_S_Chans                  -- Selected VXGTO-S Channels           
in string[32]          : JitPatName                   -- A string identifier for selected Injected Sinusoidal Jitter Tones
in string[32]          : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
in double              : DataRate                     -- Data Rate of Transmitted data
in float               : DiffLevel                    -- Differential VXGTO-S output level used during injected jitter testing
in integer             : TxConnection                 -- Select BALANCED, SE_PLUS or SE_MINUS  for VXGTO Source Output Connection
in double              : DutClockFreq                 -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock
in float               : JitTone[?]                   -- Array of Injected Jitter Tone Frequencies  -- Maximum size set to 3 Tones
in integer             : GTO_SrcPath                  -- Select GTB_SRC if not using custom user source path, otherwise
                                                      -- select 1 of 3 custome user paths with GTB_SRC_USER1,GTB_SRC_USER2 or GTB_SRC_USER3
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure sets up the VXGTO transmitted output with programmed injected jitter on a specified data pattern.
--  Sinusoidal jitter is provided by IQ modulation of the jitter clock with a specified jitter tone. Random Jitter 
-- is controlled by Jitter Clock level.  Data Dependent Jitter is provided by an Inter-Symbol-Interference generator 
-- from a  selected custom user path. 
------------------------------------------------------------------------------------------------------------
local
    float              : AWG_FiltFreq                               -- Used for sampling rate selection.
    float              : MaxFreq                                    -- Highest frequency injected jitter tone
    integer            : NoOfInjectedTones                          -- Number of periodic jitter tones frequencies to be processed
    integer            : i
end_local
body

if JitTone[1] = 52MHz then
wait(0ms)
end_if
 
    set vx_gto GTO_S_Chans output bit rate frequency to DataRate   
    set vx_gto GTO_S_Chans output clock mode to jitter_clk
    EnableJitterClk("on",DataRate)      

    NoOfInjectedTones = dimsize(JitTone,1)

    MaxFreq = 0.0
    for i = 1 to NoOfInjectedTones do
        if MaxFreq < JitTone[i] then 
            MaxFreq = JitTone[i]
        end_if
    end_for

    if MaxFreq < 12.5MHz then
        AWG_FiltFreq = 50.0MHz
    else
        AWG_FiltFreq = MaxFreq * 4.0
   end_if

if use_awghsb then
    if MaxFreq < (AWGHSB_SAMPLING_FREQ/16.0 - AWGHSB_TONE_BIN_SIZE) then
        set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ/2.0
    else
        set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ
    end_if
elseif use_awg520 then

wait ( 0.0 )
else
    set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ/2.0
end_if

    StartJitterModulation(JitPatName,JIT_CLK,AWG_FiltFreq)
    
    SetJitterClkModulation("iq")
    
    if (GTO_SrcPath < GTB_SRC_USER1) or (GTO_SrcPath > GTB_SRC_USER3) then
        StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)
    else
        StartUserSrcOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTO_SrcPath)
    end_if
-- GTB_SelectSampleClockOutput ( <:1:> , 1 )
-- GTB_SetSampleClockDivider ( 1 , 4 )
-- SetSampleClkFrequency(DataRate/16.0)
-- GTB_SelectSampleClockOutput ( <:1:> , DIVIDED_CLOCK )

    wait(1ms)
end_body




procedure CalibrateJitClkRJ(GTO_S_Chans,SampDighsPins,ClkLevelName,DataPatName,DiffLevel,BitsPerWaveform,DataRate,MeasLevelMax,MeasurementScale,BitErrorRate,SamplerConnection,NoiseFreqMax,NoiseFreqMin,NoiseFreqHP_Corner)
in pin list[MAX_GTOS]   : GTO_S_Chans                  -- Selected VXGTO-S Channels           
in pin list[MAX_DIGHS]  : SampDighsPins                -- Selected DIGHS Channels                
in string[32]           : ClkLevelName                 -- Identerfier for measured P-P Random Jitter
in string[32]           : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
in float                : DiffLevel                    -- Differential VXGTo-S output level used during injected jitter calibration
in integer              : BitsPerWaveform              -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
in double               : DataRate                     -- Data Rate of Transmitted data
in float                : MeasLevelMax                 -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
in  float               : MeasurementScale             -- Scale factor to correct for attenuation in measurement path  
in float                : BitErrorRate                 -- Test Bit Error Rate Test
in multisite integer    : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float                : NoiseFreqMax                 -- High Noise frequency Low Pass Brick wall cutoff 
in float                : NoiseFreqMin                 -- Low Noise frequency High Pass Brick wall cutoff 
in float                : NoiseFreqHP_Corner           -- Low Noise frequency High Pass 3dB cutoff
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure is intended to calibrate the random jitter generated by the VXGTO transmitter output and
-- should be used as a focused calibration executed once during program load for each required magnitude of 
-- Random Jitter.  
-- Amplitude of the VXGTO/S Jitter Clock input affects the magnitude of the random jitter generated by
-- the VXGTO/S onto its transmitted data.  A repeating 1010..10 pattern should be used as the calibration
-- waveform.  Iteratively, the random jitter is measured and the Jitter Clock's amplitude is adjusted until 
-- the measured random jitter has the specified magnitude. A Spec Mask parameter has to be defined in an
-- enVision Spec Object so that the derived Jitter Clock amplitude can be stored in the Spec Mask parameter.
-- Then later in DUT testing the Jitter Clock's amplitude is set to the value stored in the Spec Mask parameter
-- to inject the required magnitude of random jitter.
------------------------------------------------------------------------------------------------------------


local float                 : P_P_Jitter[MAX_DIGHS]                -- P-P Random Jitter for Specified Execution time
local integer               : SourceClock = JIT_CLK                -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock
local integer               : TxConnection = BALANCED
local integer               : NumOfTones = 6
local float                 : RjReference
local float                 : RjMeasured
local multisite float       : JitterTones[MAX_DIGHS,MAX_NUM_TONES] -- Periodic Jitter Tone Frequencies
local multisite float       : PP_Jitter[MAX_DIGHS,MAX_NUM_TONES]   -- Periodic Tone's Jitter P-P 
local multisite double      : RandomJitter[MAX_DIGHS]              -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysisend_local 
local boolean               : StartOnTrigger = false
local integer               : PortCount
local integer               : ChanPtr
local integer               : SitePtr
local integer               : SiteCount
local word list[16]         : SiteList
local word list[MAX_DIGHS]  : DigPorts
 
body

    print(stdout,"Calibrating RJ  ",ClkLevelName:20," at ",DataRate!fu=GHz:12:6," at ",DiffLevel!fu=mV:8:1," with ",DataPatName:10," pattern")

if tester_simulated then
return
end_if

     PortCount       = len(SampDighsPins) 
     SiteList        = get_active_sites
     SiteCount       = len(SiteList)
    if use_dighsb then
        DigPorts   = dighsb_ptc(SampDighsPins)
    else
        DigPorts   = dighs_ptc(SampDighsPins)
    end_if 
    RjMeasured = 0.0
    set vx_gto GTO_S_Chans output bit rate frequency to DataRate   
    set vx_gto GTO_S_Chans output clock mode to jitter_clk
    EnableJitterClkForRJ("on",DataRate)
    SetJitterClkModulation("off")
    StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)
    
    SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,NoiseFreqMax)
    wait(100ms)
    SpectrumAnalysis(SampDighsPins,BitsPerWaveform,DataRate,StartOnTrigger,MeasLevelMax,NoiseFreqMin,NoiseFreqHP_Corner,NoiseFreqMax,NumOfTones, RandomJitter,JitterTones,PP_Jitter)
        for SitePtr = 1 to SiteCount do  
        for ChanPtr = 1 to PortCount do
            RjMeasured = float(RandomJitter[SitePtr,ChanPtr]) * float(DataRate)
           P_P_Jitter[DigPorts[(SitePtr -1) * PortCount + ChanPtr]] = Pk_pk_from_rms(RjMeasured,1.0/BitErrorRate)
        end_for
    end_for
    set_expr(ClkLevelName + ".Meas",P_P_Jitter)

    println(stdout,"  Meas Pk-Pk  RJ = ",P_P_Jitter:8:4,"UI")
    
endbody
------------------------------------------------------------------------------------------------------------
procedure JitterTransfer(GTO_S_Chans,SampDighsPins,JitPatName,DataPatName,BitsPerWaveform,DataRate,DiffLevel,MeasLevelMax,MeasurementScale,TxConnection,SourceClock,ModulateClock,DutClockFreq,SamplerConnection,JitTone,JitToneSrcAmp,JitTrans)--,jitter_trans_limits)
in pin list[MAX_GTOS]  : GTO_S_Chans                  -- Selected VXGTO-S Channels           
in pin list[MAX_DIGHS] : SampDighsPins                -- Selected DIGHS Channels                
in string[32]          : JitPatName                   -- A string identifier for selected Injected Sinusoidal Jitter Tones
in string[32]          : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
in integer             : BitsPerWaveform              -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
in double              : DataRate                     -- Data Rate of Transmitted data
in  float              : DiffLevel                    -- Differential VXGTo-S output level used during injected jitter testing
in  float              : MeasLevelMax                 -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
in  float              : MeasurementScale                -- Scale factor to correct for attenuation in measurement path  
in  integer            : TxConnection                 -- Select BALANCED, SE_PLUS or SE_MINUS  for VXGTO Source Output Connection
in integer             : SourceClock                  -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
in integer             : ModulateClock                -- Selected Clock to Apply Jitter Enter JIT_CLK for Jitter Clock, REF_CLK for reference (Aux) Clock, or SAMP_CLK for Sampler Clock
in double              : DutClockFreq                 -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock
in multisite integer   : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float               : JitTone[?]                   -- Array of Injected Jitter Tone Frequencies  -- Maximum size set to 3 Tones
in float               : JitToneSrcAmp[?]             -- Array of Source Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
out multisite float    : JitTrans[MAX_DIGHS*MAX_NO_JITTER_TONES]  -- Measured Jitter Transfer
--in_out array of float_test : jitter_trans_limits 
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure causes the VXGTO transmitted output to apply predefined injected jitter to a DUT's input
-- and measure that jitter transferred to the DUT's output.  Measurement results are compared to limits and
-- datalogged.  The applied input waveform must be a square pattern, such as a repeating 1010...10 pattern 
-- or a repeating 11001100...1100 data pattern.
------------------------------------------------------------------------------------------------------------
local
    multisite  float   : JitToneMeas[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Measured jitter tone amplitudes
    multisite  float   : JitToneMeasAvg[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Measured jitter tone amplitudes
    float              : FreqBinSize                                -- Frequency Bin Size in jitter injection spectrum 
    float              : AWG_FiltFreq                               -- Reconstruction Filter Selection also used for sampling rate selection.
    float              : MaxFreq                                    -- Highest frequency injected jitter tone
    integer            : NoOfInjectedTones                          -- Number of periodic jitter tones frequencies to be processed
    integer            : i
    integer            : Avg = 15
    integer            : ChanPtr
    integer            : PortCount
    integer            : TonePosition
    multisite double   : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysis
    multisite  float   : JitTransRefLevel[MAX_DIGHS*MAX_NO_JITTER_TONES]
end_local
body

    stop vx_gto GTO_S_Chans output
    stop awghsb
    SelectGtoSrcClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq) 
  
    NoOfInjectedTones = dimsize(JitTone,1)
    MaxFreq = 0.0
    for i = 1 to NoOfInjectedTones do
        if MaxFreq < JitTone[i] then 
            MaxFreq = JitTone[i]
        end_if
    end_for
    if MaxFreq < 12.5MHz then
        AWG_FiltFreq = 50.0MHz
    else 
        AWG_FiltFreq =  MaxFreq * 4.0
    end_if

    if use_awghsb then
        if MaxFreq < (AWGHSB_SAMPLING_FREQ/16.0 - AWGHSB_TONE_BIN_SIZE) then
            set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ/2.0
        else 
            set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ
        end_if
    elseif  use_awg520 then

    else
        if MaxFreq < (AWGHSB_SAMPLING_FREQ/16.0 - AWGHSB_TONE_BIN_SIZE) then
            set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ/2.0
        else 
            set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ
        end_if
    end_if
        
    StartJitterModulation(JitPatName,ModulateClock,AWG_FiltFreq)
    StartJitterModulation(JitPatName,ModulateClock,AWG_FiltFreq)

    wait(100ms)
    StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)


    SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,MaxFreq * 2.0)
    wait(10ms)

    JitToneMeasAvg = 0.0
    for i = 1 to Avg do
         JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)
         JitToneMeasAvg = JitToneMeasAvg + JitToneMeas
    end_for
    JitToneMeas = JitToneMeasAvg/float(Avg)
    JitTrans = JitToneMeas  -- WYANG 02/04/2009

    println(stdout, "Averaged JitToneMeas = ", JitToneMeas[1,1]!e:12:3 )
    println(stdout, "@n")
        


--     --***** Calculate Jitter Transfer **********
--     NoOfInjectedTones = dimsize(JitTone,1)
--     PortCount  = len(SampDighsPins)
--      
--     for ChanPtr = 1 to PortCount do 
--         for i = 1 to NoOfInjectedTones do
--             TonePosition = (ChanPtr - 1) * NoOfInjectedTones + i
--             JitTrans[1,TonePosition] =  amp_dB(1.0e-18 +JitToneMeas[1,TonePosition]*float(DataRate)/JitToneSrcAmp[i])
-- 
--             if JitTrans[1,TonePosition] > 1.0 then
--                 wait(0ms)
--                 --error
--             end_if
--         end_for
--     end_for
--     
--     --Added for 2 pass measurement to improve accuarcy
--     --Really need to fix the calibration so this is not necessary
--     GTB_ConnectSamplerToDigitizer ( 1 , AUX_SAMPLER , 1 )
--     wait(10ms)
-- 
--     JitToneMeasAvg = 0.0
--     for i = 1 to Avg do
--          JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)
--          JitToneMeasAvg = JitToneMeasAvg + JitToneMeas
--          println(stdout, "JitToneMeas = ", JitToneMeas[1,1]!e:12:3 )
--          println(stdout, "@n")
--     end_for
--     JitToneMeas = JitToneMeasAvg/float(Avg)


--     --***** Calculate Jitter Transfer **********
--     NoOfInjectedTones = dimsize(JitTone,1)
--     PortCount  = len(SampDighsPins)
--      
--     for ChanPtr = 1 to PortCount do 
--         for i = 1 to NoOfInjectedTones do
--             TonePosition = (ChanPtr - 1) * NoOfInjectedTones + i
--             JitTransRefLevel[1,TonePosition] =  amp_dB(1.0e-18 +JitToneMeas[1,TonePosition]*float(DataRate)/JitToneSrcAmp[i])
-- 
-- if JitTrans[1,TonePosition] > 1.0 then
-- wait(0ms)
-- --error
-- end_if
-- 
--         end_for
--     end_for
--     
--     JitTrans = JitTrans - JitTransRefLevel
--     --test_value JitTrans with jitter_trans_limits mode TVM_PINS
--     
-- 
--    --******* Verify Generated Injected Jitter Tones
--     if DisplayMode then   --   **** Set DisplayMode true to observe Spectrum in Status Display ****        
--         JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)
-- 
-- 
--         if AWG_FiltFreq < (AWGHSB_SAMPLING_FREQ/4.0 - AWGHSB_TONE_BIN_SIZE) then
--             FreqBinSize = AWGHSB_TONE_BIN_SIZE/2.0
--         else
--             FreqBinSize = AWGHSB_TONE_BIN_SIZE
--         end_if
--                    
--             
--         -- a -g  SpectrumRef; grid   
--                 --**** Enter Numeric values -- scale -mult FreqBinSize  -offset 0.0                   
--                         -- units -x MHz
--                         -- units -y dB                
-- 
--          wait(0mS)   -- SET BREAKPOINT HERE TO OBSERVE WAVEFORM ON STATUS DISPLAY
--     end_if
--  


end_body
procedure JitterTransfer2(GTO_S_Chans,SampDighsPins,JitPatName,JitPatName2,DataPatName,BitsPerWaveform,DataRate,DiffLevel,MeasLevelMax,MeasurementScale,TxConnection,SourceClock,ModulateClock,DutClockFreq,SamplerConnection,JitTone,JitToneSrcAmp,JitToneSrcAmp2,JitTrans,jitter_trans_limits)
in pin list[MAX_GTOS]  : GTO_S_Chans                  -- Selected VXGTO-S Channels           
in pin list[MAX_DIGHS] : SampDighsPins                -- Selected DIGHS Channels                
in string[32]          : JitPatName                   -- A string identifier for selected Injected Sinusoidal Jitter Tones
in string[32]          : JitPatName2                  -- A string identifier for selected 2nd Injected Sinusoidal Jitter level
in string[32]          : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
in integer             : BitsPerWaveform              -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
in double              : DataRate                     -- Data Rate of Transmitted data
in  float              : DiffLevel                    -- Differential VXGTo-S output level used during injected jitter testing
in  float              : MeasLevelMax                 -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
in  float              : MeasurementScale                -- Scale factor to correct for attenuation in measurement path  
in  integer            : TxConnection                 -- Select BALANCED, SE_PLUS or SE_MINUS  for VXGTO Source Output Connection
in integer             : SourceClock                  -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
in integer             : ModulateClock                -- Selected Clock to Apply Jitter Enter JIT_CLK for Jitter Clock, REF_CLK for reference (Aux) Clock, or SAMP_CLK for Sampler Clock
in double              : DutClockFreq                 -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock
in multisite integer   : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float               : JitTone[?]                   -- Array of Injected Jitter Tone Frequencies  -- Maximum size set to 3 Tones
in float               : JitToneSrcAmp[?]             -- Array of Source Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
in float               : JitToneSrcAmp2[?]            -- Array of Source 2nd Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
out multisite float    : JitTrans[MAX_DIGHS*MAX_NO_JITTER_TONES]  -- Measured Jitter Transfer
in_out array of float_test : jitter_trans_limits 
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure causes the VXGTO transmitted output to apply predefined injected jitter to a DUT's input
-- and measure that jitter transferred to the DUT's output.  Measurement results are compared to limits and
-- or a repeating 11001100...1100 data pattern.
------------------------------------------------------------------------------------------------------------
local
    multisite  float   : JitToneMeas[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Measured jitter tone amplitudes
    multisite  float   : JitToneMeas2[MAX_DIGHS*MAX_NO_JITTER_TONES]-- Measured 2nd jitter tone amplitudes
    float              : FreqBinSize                                -- Frequency Bin Size in jitter injection spectrum 
    float              : AWG_FiltFreq                               -- Reconstruction Filter Selection also used for sampling rate selection.
    float              : MaxFreq                                    -- Highest frequency injected jitter tone
    integer            : NoOfInjectedTones                          -- Number of periodic jitter tones frequencies to be processed
    integer            : i
    integer            : ChanPtr
    integer            : PortCount
    integer            : TonePosition
    multisite double   : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysis
end_local
body

  SelectGtoSrcClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq) 
  
  NoOfInjectedTones = dimsize(JitTone,1)
   MaxFreq = 0.0
    for i = 1 to NoOfInjectedTones do
        if MaxFreq < JitTone[i] then 
            MaxFreq = JitTone[i]
        end_if
    end_for
    if MaxFreq < 12.5MHz then
        AWG_FiltFreq = 50.0MHz
    else 
        AWG_FiltFreq =  MaxFreq * 4.0
    end_if

    if use_awghsb then
        if MaxFreq < (AWGHSB_SAMPLING_FREQ/16.0 - AWGHSB_TONE_BIN_SIZE) then
            set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ/2.0
        else 
            set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ
        end_if
    elseif  use_awg520 then

    else
        if MaxFreq < (AWGHSB_SAMPLING_FREQ/16.0 - AWGHSB_TONE_BIN_SIZE) then
            set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ/2.0
        else 
            set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> sample rate to AWGHSB_SAMPLING_FREQ
        end_if
    end_if
        
    StartJitterModulation(JitPatName,ModulateClock,AWG_FiltFreq)


    StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)

    SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,MaxFreq * 2.0)
    wait(100ms)
    JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)

    StartJitterModulation(JitPatName2,ModulateClock,AWG_FiltFreq)
    JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas2,RandomJitter)

    JitToneMeas  = JitToneMeas2 - JitToneMeas
    JitToneSrcAmp = JitToneSrcAmp2 - JitToneSrcAmp
   
    --***** Calculate Jitter Transfer **********
    NoOfInjectedTones = dimsize(JitTone,1)

     PortCount  = len(SampDighsPins)
     
         for ChanPtr = 1 to PortCount do 
             for i = 1 to NoOfInjectedTones do
                 TonePosition = (ChanPtr - 1) * NoOfInjectedTones + i

                 JitTrans[1,TonePosition] =  amp_dB(JitToneMeas[1,TonePosition]*float(DataRate)/JitToneSrcAmp[i])
             end_for
         end_for
    test_value JitTrans with jitter_trans_limits mode TVM_PINS 


   --******* Verify Generated Injected Jitter Tones
   if DisplayMode then   --   **** Set DisplayMode true to observe Spectrum in Status Display ****        
         JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)

         if AWG_FiltFreq < (AWGHSB_SAMPLING_FREQ/4.0 - AWGHSB_TONE_BIN_SIZE) then
             FreqBinSize = AWGHSB_TONE_BIN_SIZE/2.0
         else
             FreqBinSize = AWGHSB_TONE_BIN_SIZE
         end_if
                   
            
                          -- a -g  SpectrumRef; grid   
                                 --**** Enter Numeric values -- scale -mult FreqBinSize  -offset 0.0                   
                          -- units -x MHz
                          -- units -y dB                

                    wait(0mS)   -- SET BREAKPOINT HERE TO OBSERVE WAVEFORM ON STATUS DISPLAY
           end_if
 


end_body
procedure JitterPeaking(SampDighsPins,JitterTrans1,JitterTrans2,jitter_peaking_limits)
in pin list[MAX_DIGHS] : SampDighsPins                -- Selected DIGHS Channels                
in multisite float    : JitterTrans1[MAX_DIGHS*MAX_NO_JITTER_TONES]  -- Measured Jitter Transfer at first jitter tone level
in multisite float    : JitterTrans2[MAX_DIGHS*MAX_NO_JITTER_TONES]  -- Measured Jitter Transfer at second jitter tone level
in_out array of float_test : jitter_peaking_limits 
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure measures jitter peaking, compares to limits and datalogs the measurement.
-- The procedure reads in two jitter transfer measurements, which should have use the same jitter at two different
-- magnitudes.  The difference between the two measurements is the result of jitter peaking measurement.  
------------------------------------------------------------------------------------------------------------
local
    integer            : ChanPtr
    integer            : PortCount
    integer            : SitePtr
    integer            : SiteCount
    word list[16]      : SiteList
    multisite float    : JitterPeaking[MAX_DIGHS]
end_local
------------------------------------------------------------------------------------------------------------
body
    --***** Calculate Jitter Peaking **********

    PortCount  = len(SampDighsPins)
     
     PortCount  = len ( SampDighsPins )
     SiteList   = get_active_sites
     SiteCount  = len(SiteList)
     
    for SitePtr = 1 to SiteCount do
        for ChanPtr = 1 to PortCount do 
            JitterPeaking[SiteList[SitePtr],ChanPtr] = abs(JitterTrans2[SiteList[SitePtr],ChanPtr] - JitterTrans1[SiteList[SitePtr],ChanPtr])
        end_for
    end_for
    test_value JitterPeaking with jitter_peaking_limits mode TVM_PINS 

end_body
procedure JitterTransfer3dbBandwidth(SampDighsPins,JitterTone1,JitterTone2,JitterTrans1,JitterTrans2,jit_trans_bandwidth_limits)
in pin list[MAX_DIGHS] :  SampDighsPins              -- Selected DIGHS Channels                
in float              : JitterTone1[?]
in float              : JitterTone2[?]
in multisite float    : JitterTrans1[MAX_DIGHS]  -- Measured Jitter Transfer of JitterTone1
in multisite float    : JitterTrans2[MAX_DIGHS]  -- Measured Jitter Transfer of JitterTone2
in_out array of float_test : jit_trans_bandwidth_limits 
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
-- This procedure reads in the jitter transfer of two sinusoidal jitter tones and derives the frequency of the
-- jitter transfer 3dB bandwidth.  The jitter transfer 3dB bandwidth is compared to limits and datalogged.  One of the 
-- tested jitter tones should be at or below the specified low frequency limit and the other jitter tone should be at 
-- or above the high frequency limit.
--------------------------------------------------------------------------------------------------------------------
local
    integer            : ChanPtr
    integer            : PortCount
    integer            : SitePtr
    integer            : SiteCount
    word list[16]      : SiteList
    multisite float    : Loop3dB_Bandwidth[MAX_DIGHS]
end_local
--------------------------------------------------------------------------------------------------------------------
body
    --***** Calculate Jitter Transfer Bandwidth **********
  
     PortCount  = len ( SampDighsPins )
     SiteList   = get_active_sites
     SiteCount  = len(SiteList)
     
     for SitePtr = 1 to SiteCount do
         for ChanPtr = 1 to PortCount do 
            Loop3dB_Bandwidth[SiteList[SitePtr],ChanPtr] = JitterTone1[1] + (3.0 + JitterTrans1[SiteList[SitePtr],ChanPtr])/(JitterTrans1[SiteList[SitePtr],ChanPtr] -JitterTrans2[SiteList[SitePtr],ChanPtr]) * (JitterTone2[1] - JitterTone1[1])       
       end_for
    end_for
    
    test_value Loop3dB_Bandwidth with jit_trans_bandwidth_limits mode TVM_PINS 

end_body

procedure ReadPrbsBitErrorRate(GtoInputChans,DataRate,PrbsPattern,BertTime,GtoRxClockMode,BitErrorRate,bit_error_rate_limits)
-----------------------------------------------------------------------------------------
in pin list[MAX_GTOS] : GtoInputChans            --  VXGTO input channels
in double             : DataRate                 --  Device's serial data rate
in string[32]         : PrbsPattern              --  String identifier for expected VXGTO PRBS pattern
in float              : BertTime                 -- Time interval for Bit Error Rate Test
in integer            : GtoRxClockMode           -- See VXGTO AND MODULATION CLOCKS SELECTION CONSTANTS in modules environment
out multisite double  : BitErrorRate [MAX_GTOS]  -- Measured Bit Error Rate
in_out array of float_test : bit_error_rate_limits 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
--  This procedure causes the VXGTO/S to test PRBS data from a device under
--  test and derive Bit Error Rate from selected pattern.
-------------------------------------------------------------------------

local
   multisite boolean  : SyncFail[MAX_GTOS]
   integer            : ChanPtr
   integer            : PortCount
   multisite double   : TotalCount[MAX_GTOS]
   float              : PhaseSetting
   double             : BerAry[800]
   double             : BerMax = 1.0e-9
   integer            : i
   integer            : SitePtr
   integer            : SiteCount
   word list[16]      : SiteList
   word list[MAX_DIGHS] : GtoPins
end_local

body

     GtoPins    = vxgto_ptc(GtoInputChans)
     SiteList   = get_active_sites
     SiteCount  = len( SiteList)
     PortCount  = len(GtoInputChans)
     
     i = 0
     BitErrorRate = 1.0
     while (i < 2) and (BitErrorRate > BerMax) do
     i = i + 1
       stop vx_gto GtoInputChans input 
       set vx_gto GtoInputChans input bit rate frequency to DataRate
       if GtoRxClockMode = JIT_CLK then
            set vx_gto GtoInputChans input clock mode to jitter_clk
       else_if GtoRxClockMode = JIT_CLK_INV then
            set vx_gto GtoInputChans input clock mode to jitter_clk inverted
       else_if GtoRxClockMode = TX_ODD_WORD then
            set vx_gto GtoInputChans input clock mode to word_clk from tx1
       else_if GtoRxClockMode = TX_EVEN_WORD then
            set vx_gto GtoInputChans input clock mode to word_clk from tx2
       else_if GtoRxClockMode = TX_WORD then
          for SitePtr = 1 to SiteCount do
             for ChanPtr = 1 to PortCount do 
                 if GtoPins[(SitePtr-1) * PortCount + ChanPtr] mod 2 = 1 then
                     set vx_gto GtoPins[(SitePtr-1) * PortCount + ChanPtr]  input clock mode to word_clk from tx1
                 else
                     set vx_gto GtoPins[(SitePtr-1) * PortCount + ChanPtr]  input clock mode to word_clk from tx2
                 end_if
             end_for
         end_for
       end_if
      wait(100ms)
      if PrbsPattern = "prbs7" then
           start vx_gto GtoInputChans input pattern prbs7 
       else_if PrbsPattern = "prbs15" then
           start vx_gto GtoInputChans input pattern prbs15 
       else_if PrbsPattern = "prbs23" then
           start vx_gto GtoInputChans input pattern prbs23 
       else_if PrbsPattern = "prbs31" then
           start vx_gto GtoInputChans input pattern prbs31 
       end_if
    clear vx_gto GtoInputChans input prbs count
    wait(BertTime)
    stop vx_gto GtoInputChans input 
    read vx_gto GtoInputChans input fail count into BitErrorRate loss of sync into SyncFail
    read vx_gto GtoInputChans input prbs word count into TotalCount  
    TotalCount = TotalCount * 32.0
      for SitePtr = 1 to SiteCount do
         for ChanPtr = 1 to PortCount do  
            TotalCount[SitePtr,ChanPtr] = TotalCount[SitePtr,ChanPtr]
            BitErrorRate[SitePtr,ChanPtr] = BitErrorRate[SitePtr,ChanPtr]/TotalCount[SitePtr,ChanPtr]
         end_for
       end_for
     end_while    
         
    test_value BitErrorRate with bit_error_rate_limits mode TVM_PINS     
       
 end_body

procedure StartGtoDataOutputOnTrigger(GTO_S_Chans,DataPatName,TxOutLevel,TxConnection,SyncBusLine)
in pin list[MAX_GTOS] : GTO_S_Chans  -- Selected VXGTO-S Channels           
in string[32]          : DataPatName  -- A string identifier for selected VXGTO TX Data pattern
in float               : TxOutLevel   -- Programmed VXGTO-S TX output level
in integer             : TxConnection --  GTO Front End TX output connection mode
in integer             : SyncBusLine  --  Sync Bus Line -- Select from Lines 1 to 8
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- This procedure starts the VXGTO TX output to transmit the specified pattern at the specified
-- output level and mode.  Transmission of data starts upon receipt of trigger on the specified
-- Sync Bus Line
------------------------------------------------------------------------------------------------
local
  word list[MAX_DIGHS] : GtoPins
end_local
body

    GtoPins = vxgto_ptc(GTO_S_Chans)
    stop vx_gto GTO_S_Chans output
    GTB_SetSourceLevelOnTrigger (GtoPins,TxConnection,TxOutLevel,word(SyncBusLine)) 

     if  DataPatName = "alignment" then
        start vx_gto GTO_S_Chans output with alignment pattern 
    else_if DataPatName[1:4] = "prbs" then
        if DataPatName = "prbs7" then
            start vx_gto GTO_S_Chans output with prbs7 pattern
        else_if DataPatName = "prbs15" then
            start vx_gto GTO_S_Chans output with prbs15 pattern
        else_if DataPatName = "prbs23" then
            start vx_gto GTO_S_Chans output with prbs23 pattern
        else_if DataPatName = "prbs31" then
            start vx_gto GTO_S_Chans output with prbs31 pattern
        else_if DataPatName = "prbs7Inv" then
            start vx_gto GTO_S_Chans output with prbs7 pattern inverted
        else_if DataPatName = "prbs15Inv" then
            start vx_gto GTO_S_Chans output with prbs15 pattern inverted
        else_if DataPatName = "prbs23Inv" then
            start vx_gto GTO_S_Chans output with prbs23 pattern inverted
        else_if DataPatName = "prbs31Inv" then
            start vx_gto GTO_S_Chans output with prbs31 pattern inverted
        end_if
    else 
        start vx_gto GTO_S_Chans output with user pattern  DataPatName        
    end_if 
    wait(1.0ms)   


end_body
procedure GtoSilent(GTO_S_Chans)
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
--  This procedure is used to generate a silent or no data output from the VXGTO transmitter output/
--------------------------------------------------------------------------------------------------
in pin list[MAX_GTOS]  : GTO_S_Chans  -- Selected VXGTO-S Channels           
body
    StartGtoDataOutput(GTO_S_Chans,"Silent",GTB_SRC_ATTEN_PATH_MIN,BALANCED,GTB_NORMAL_SOURCE_RANGING)
end_body

procedure StartUserSrcOutput(GTO_S_Chans,DataPatName,TxOutLevel,TxConnection,GTO_SrcPath)
in pin list[MAX_GTOS] : GTO_S_Chans  -- Selected VXGTO-S Channels           
in string[32]          : DataPatName  -- A string identifier for selected VXGTO TX Data pattern
in float               : TxOutLevel   -- Programmed VXGTO-S TX output level
in integer             : TxConnection -- GTO Front End TX output connection mode  -- Enter BALANCED for Differential,SE_PLUS for non-inverting output, or SE_MINUS for the inverting output
in integer             : GTO_SrcPath  -- Select 1 of 3 custome user paths with GTB_SRC_USER1,GTB_SRC_USER2 or GTB_SRC_USER3
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- This procedure starts the VXGTO TX output to transmit the specified data pattern, and route the 
-- transmitted signal throuyh the specified user connection within the GTO Front End.  Typically 
-- the user path is a known source of Inter-Symbol-Interference.  But that connection path may
-- instead contain a user's custom function.
------------------------------------------------------------------------------------------------
local
  word list[MAX_DIGHS] : GtoPins
  integer              : ChanCount
  integer              : Chan
end_local
body

    GtoPins = vxgto_ptc(GTO_S_Chans)
    ChanCount = len(GtoPins)
    stop vx_gto GTO_S_Chans output
    set vx_gto GtoPins output level to TxOutLevel force
    for Chan = 1 to ChanCount do
         GTB_SelectSourcePath (integer(GtoPins[Chan]),GTO_SrcPath,TxConnection)
    end_for    

     if  DataPatName = "alignment" then
        start vx_gto GTO_S_Chans output with alignment pattern 
    else_if DataPatName[1:4] = "prbs" then
        if DataPatName = "prbs7" then
            start vx_gto GTO_S_Chans output with prbs7 pattern
        else_if DataPatName = "prbs15" then
            start vx_gto GTO_S_Chans output with prbs15 pattern
        else_if DataPatName = "prbs23" then
            start vx_gto GTO_S_Chans output with prbs23 pattern
        else_if DataPatName = "prbs31" then
            start vx_gto GTO_S_Chans output with prbs31 pattern
        else_if DataPatName = "prbs7Inv" then
            start vx_gto GTO_S_Chans output with prbs7 pattern inverted
        else_if DataPatName = "prbs15Inv" then
            start vx_gto GTO_S_Chans output with prbs15 pattern inverted
        else_if DataPatName = "prbs23Inv" then
            start vx_gto GTO_S_Chans output with prbs23 pattern inverted
        else_if DataPatName = "prbs31Inv" then
            start vx_gto GTO_S_Chans output with prbs31 pattern inverted
        end_if
    else 
        start vx_gto GTO_S_Chans output with user pattern  DataPatName        
    end_if 
    wait(1.0ms)   


end_body


function IncrementClockPhaseAngle ( iChan , qChan , steps , increment , init , enabled ) : integer
--------------------------------------------------------------------------------
in word             : iChan
in word             : qChan
in integer          : steps         -- The number of steps in 2 PI Radians (360 deg).
in integer          : increment     -- The number of steps to increment.
in boolean          : init          -- Set true to reset to initial phase
in boolean          : enabled       -- Set true to enable the IQ signals

local integer       : j , k
local float         : x , y , z , i , q
local float         : angle, degrees
static integer      : currentStep
static float        : lastI
static float        : lastQ
const                TWO_PI = 2.0 * 3.14159265359
body

    if init then
        currentStep = 0
        lastI = 1.0
        lastQ = 0.0
    elseif abs ( increment ) > steps / 8 then
        println ( stdout , "ERROR: the increment must be less than 1/8 of the step size." )
        println ( stdout , "from: VXGTO_Sampler.mod/IncrementClockPhaseAngle" )
    else
        currentStep = ( currentStep + increment ) mod steps
    endif

    angle = TWO_PI * float ( currentStep ) / float ( steps )
    degrees = angle / TWO_PI * 360.0
    i = cos ( angle )
    q = sin ( angle )
    --println ( stdout , i:6:4 , "   ", q:6:4 , "   " )
    if not enabled then
        set awghsb <: iChan , qChan :> offset to 0.0
        set awghsb <: iChan , qChan :> offset to ground
    elseif abs ( i ) >= abs ( lastI ) then
        set awghsb qChan offset to q
        set awghsb iChan offset to i
    else                
        set awghsb iChan offset to i
        set awghsb qChan offset to q
    endif               
    
    lastI = i
    lastQ = q
    
    return ( currentStep )

endbody
--------------------------------------------------------------------------------

procedure EnablePhaseControl ( modulateClock )
in integer      : modulateClock   -- Enter JIT_CLK for Jitter Clock, AUX_CLK for Auxiliary Clock
-------------------------------------------------------------------------------------------

body
        if  modulateClock = JIT_CLK then
--error        
            connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to output b single ended pos -- Needed before R14.4
            connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to system coax
            SetJitterClkModulation("iq")
        else_if modulateClock  = AUX_CLK then
            connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to user coax
            SetAuxiliaryClkIQ ( "on" )
        else
            println(stdout,"ERROR : Invalid ModulateClock selected")
            println(stdout,"Valid options are : JIT_CLK or AUX_CLK")
            println(stdout,"Halting from procedure : EnablePhaseControl")
            halt
        end_if

        set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to max 1.0 lpf 50MHz
   
        IncrementClockPhaseAngle ( AWGHSB_I_CHAN,AWGHSB_Q_CHAN , 1 , 0 , true , true )

end_body
-------------------------------------------------------------------------------------------

procedure CalibrateSpectrum(GTO_S_Chans,SampDighsPins,DataPatName,BitsPerWaveform,DataRate,MeasLevelMax,MeasurementScale,SamplerConnection)
in pin list[MAX_GTOS]   : GTO_S_Chans                  -- Selected VXGTO-S Channels           
in pin list[MAX_DIGHS]  : SampDighsPins                -- Selected DIGHS Channels                
in string[32]           : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
in integer              : BitsPerWaveform              -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
in double               : DataRate                     -- Data Rate of Transmitted data
in float                : MeasLevelMax                 -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
in  float               : MeasurementScale             -- Scale factor to correct for attenuation in measurement path  
in multisite integer    : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
local
    float              : NoiseFreqMax = 100MHz                -- High Noise frequency Low Pass Brick wall cutoff 
    float              : DiffLevel = 0.9999                   -- Differential VXGTO-S output level used during injected jitter calibration
    float              : SampleSize                           -- Number of waveform samples
    integer            : SourceClock = JIT_CLK                -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock
    integer            : TxConnection = BALANCED
    double             : BinSize
    float              : SpectrumScale[MAX_DIGHS,11]
    float              : SpectrumScale2[MAX_DIGHS,3]
    float              : ScaleRef
    float              : SpectrumTone[SAMP_DIGHS_SPECTRUM_SAMPLES/2+1]
    float              : XtrmAry[4]
    float              : Gain
    integer            : i,j,k
    integer            : Port
    integer            : ChanPtr
    integer            : PortCount
    integer            : Site
    integer            : SiteCount
    word list[16]      : SiteList
  word list[MAX_DIGHS] : DigPorts
    boolean            : t [ 4]
end_local
body
---------------------------------------------------------------------------------------------------------------
  
  
    if use_dighsb then
        DigPorts   = dighsb_ptc(SampDighsPins)
    else
        DigPorts   = dighs_ptc(SampDighsPins)
    end_if 
    SiteList   = get_active_sites
    SiteCount  = len(SiteList)
    PortCount  = len(SampDighsPins)

    println(stdout,"Calibrating DIGHS spectrum")

if tester_simulated then
return
end_if

    SelectGtoSrcClk(GTO_S_Chans,DataRate,JIT_CLK,0.0) 

    set vx_gto GTO_S_Chans output bit rate frequency to DataRate   
    set vx_gto GTO_S_Chans output clock mode to jitter_clk
    EnableJitterClk("on",DataRate)
    SetJitterClkModulation("off")
    wait(500mS)
    StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)
    
    SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,NoiseFreqMax)
    
    BinSize = SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES*2
    
    i = 0
    j = 1
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(1000.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for
    
    i = 64
    j = 2
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)    
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for

    i = 128
    j = 3
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for

    i = 256
    j = 4
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for

    i = 512
    j = 5
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for

    i = 1024
    j = 6
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for

    i = 2048
    j = 7
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for

    i = 4096
    j = 8
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for

    i = 5334
    j = 9
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for

    i = 6668
    j = 10
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for

    i = 8190
    j = 11
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[i+2]
        end_for
    end_for

-- *****************************************8*
    i = 16382
    k = 16384 - i
    j = 1
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale2[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[k]
        end_for
    end_for
    
    i = 12800
    k = 16384 - i
    j = 2
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale2[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[k]
        end_for
    end_for
    
    i = 8193
    k = 16384 - i
    j = 3
    EnableJitterClk("on",DataRate + BinSize*double(i))
    wait(300.0ms)
    if use_dighsb then
        define dighsb DigPorts capture "a" at 0 as SAMP_DIGHS_SPECTRUM_SAMPLES points
        start dighsb DigPorts capture "a"
        wait for dighsb DigPorts timeout 100ms into  t
        read dighsb DigPorts capture "a" for SAMP_DIGHS_SPECTRUM_SAMPLES points into BifSpectrumData
    else
         measure dighs chan DigPorts for SAMP_DIGHS_SPECTRUM_SAMPLES points into memory adr 1
         for Site = 1 to SiteCount do  
            for ChanPtr = 1 to PortCount do
               read  dighs chan DigPorts[(Site -1) * PortCount + ChanPtr] for SAMP_DIGHS_SPECTRUM_SAMPLES points from memory adr 1 into BifSpectrumData[(Site -1) * PortCount + ChanPtr,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
            end_for
        end_for    
    end_if
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            SpectrumTone = mag_fft(BifSpectrumData[(Site -1) * PortCount + Port,1:SAMP_DIGHS_SPECTRUM_SAMPLES])
            SpectrumScale2[DigPorts[(Site -1) * PortCount + Port],j] = SpectrumTone[k]
        end_for
    end_for
 
    for Site = 1 to SiteCount do
        for Port = 1 to PortCount do
            k = integer(DigPorts[(Site -1) * PortCount + Port])
            XtrmAry = xtrm(SpectrumScale[k,1:11])
            SpectrumScale[k,1:11] = XtrmAry[1]/SpectrumScale[k,1:11]                        
            ScaleRef =  XtrmAry[1]
            SpectrumScale2[k,1:3] = XtrmAry[1]/SpectrumScale2[k,1:3]            
            for i = 1 to 8191 do
                if i < 64 then
                    Gain = float(i-1)/64.0*(SpectrumScale[k,2]-SpectrumScale[k,1]) + SpectrumScale[k,1]
                    SpectrumCal51[k,2*i +1] = Gain
                    SpectrumCal51[k,2*i +2] = Gain
                else_if i < 128 then
                    Gain = float(i-64)/(128.0 - 64.0)*(SpectrumScale[k,3]-SpectrumScale[k,2]) + SpectrumScale[k,2]
                    SpectrumCal51[k,2*i +1] = Gain
                    SpectrumCal51[k,2*i +2] = Gain
                else_if i < 256 then
                    Gain = float(i-128)/(256.0 - 128.0)*(SpectrumScale[k,4]-SpectrumScale[k,3]) + SpectrumScale[k,3]
                    SpectrumCal51[k,2*i +1] = Gain
                    SpectrumCal51[k,2*i +2] = Gain
                else_if i < 512 then
                    Gain = float(i-256)/(512.0 - 256.0)*(SpectrumScale[k,5]-SpectrumScale[k,4]) + SpectrumScale[k,4]
                    SpectrumCal51[k,2*i +1] = Gain
                    SpectrumCal51[k,2*i +2] = Gain
                else_if i < 1024 then
                    Gain = float(i-512)/(1024.0 - 512.0)*(SpectrumScale[k,6]-SpectrumScale[k,5]) + SpectrumScale[k,5]
                    SpectrumCal51[k,2*i +1] = Gain
                    SpectrumCal51[k,2*i +2] = Gain
                 else_if i < 2048 then
                    Gain = float(i-1024)/(2048.0 - 1024.0)*(SpectrumScale[k,7]-SpectrumScale[k,6]) + SpectrumScale[k,6]
                    SpectrumCal51[k,2*i +1] = Gain
                    SpectrumCal51[k,2*i +2] = Gain
                 else_if i < 4096 then
                    Gain = float(i-2048)/(4096.0 - 2048.0)*(SpectrumScale[k,8]-SpectrumScale[k,7]) + SpectrumScale[k,7]
                    SpectrumCal51[k,2*i +1] = Gain
                    SpectrumCal51[k,2*i +2] = Gain
                 else_if i < 5334 then
                    Gain = float(i-4095)/(5334.0 - 4096.0)*(SpectrumScale[k,9]-SpectrumScale[k,8]) + SpectrumScale[k,8]
                    SpectrumCal51[k,2*i +1] = Gain
                    SpectrumCal51[k,2*i +2] = Gain
                 else_if i < 6668 then
                    Gain = float(i-5334)/(6668.0 - 5334.0)*(SpectrumScale[k,10]-SpectrumScale[k,9]) + SpectrumScale[k,9]
                    SpectrumCal51[k,2*i +1] = Gain
                    SpectrumCal51[k,2*i +2] = Gain
                 else_if i < 8192 then
                    Gain = float(i-6668)/(8192.0 - 6668.0)*(SpectrumScale[k,11]-SpectrumScale[k,10]) + SpectrumScale[k,10]
                    SpectrumCal51[k,2*i +1] = Gain
                    SpectrumCal51[k,2*i +2] = Gain
                end_if   
                if i < 3584 then
                    Gain = float(i-1)/3584.0*(SpectrumScale2[k,2]-SpectrumScale2[k,1]) + SpectrumScale2[k,1]
                    SpectrumCal102[k,2*i +1] = Gain
                    SpectrumCal102[k,2*i +2] = Gain
                else_if i < 8192 then
                    Gain = float(i-3584)/(8192.0 - 3584.0)*(SpectrumScale2[k,3]-SpectrumScale2[k,2]) + SpectrumScale2[k,2]
                    SpectrumCal102[k,2*i +1] = Gain
                    SpectrumCal102[k,2*i +2] = Gain
                end_if   
            end_for
            
            SpectrumCal102[k,2] = SpectrumScale2[k,3]   
            SpectrumCal51[k,2] = SpectrumScale[k,10]   
            SpectrumCal25[k,2] = SpectrumScale[k,10]
            SpectrumCal25[k,3] = SpectrumScale[k,1]
            SpectrumCal25[k,4] = SpectrumScale[k,1]
            for i = 2 to  4096 do
                SpectrumCal25[k,4*i] = SpectrumCal51[k,2*i]
                SpectrumCal25[k,4*i-1] = SpectrumCal51[k,2*i]
                SpectrumCal25[k,4*i-2] = (SpectrumCal51[k,2*i] + SpectrumCal25[k,4*i-4])/2.0
                SpectrumCal25[k,4*i-3] = (SpectrumCal51[k,2*i] + SpectrumCal25[k,4*i-4])/2.0
            end_for
            SpectrumCal102[k,1:SAMP_DIGHS_SPECTRUM_SAMPLES] = SpectrumCal102[k,1:SAMP_DIGHS_SPECTRUM_SAMPLES]/SpectrumCal51[k,1:SAMP_DIGHS_SPECTRUM_SAMPLES]
        end_for
    end_for
    wait(1ms)
    
end_body
------------------------------------------------------------------------------------------------------------
procedure CalibrateISI(GTO_S_Chans,SampDighsPins,IsiLevelName,SamplerConnection,DataRate,DataPatName,DiffLevel,BitsPerWaveform,EdgesPerWaveform,MeasLevelMax,MeasurementScale,StartOnTrigger,EqualLength,EyeMaskData,GTO_SrcPath)
in pin list[MAX_GTOS]  : GTO_S_Chans                   -- Selected VXGTO-S Channels           
in pin list[MAX_DIGHS] : SampDighsPins                 -- Selected DIGHS Channels            
in string[32]          : IsiLevelName                  -- Identerfier for measured ISI
in multisite integer   : SamplerConnection[MAX_DIGHS]  -- "DataInOdd", "DataInEven", AltInOdd" or "AltInEven"
in double              : DataRate                      -- Data rate of waveform being tested
in string[32]          : DataPatName                   -- A string identifier for selected VXGTO TX Data pattern
in float               : DiffLevel                     -- Differential VXGTo-S output level used during injected jitter calibration
in integer             : BitsPerWaveform               -- Length in bits in the waveform (e.g. 127 for prbs2^7-1)
in integer             : EdgesPerWaveform              -- Number of edge transitions in the waveform (e.g. 64 for prbs2^7-1)
in float               : MeasLevelMax                  --  Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
in  float              : MeasurementScale              -- Scale factor to correct for attenuation in measurement path  
in boolean             : StartOnTrigger                -- Waveform capture starts on detection of sync1 from digital pattern
in float               : EqualLength                   -- Total trace length in DUT output measurement path to be equalized if boolean UseEq is set true
in float               : EyeMaskData[6]                -- Eye Pattern mask's Early Zero Crossing Bit Cell marker point
in integer             : GTO_SrcPath                   -- Select GTB_SRC if not using custom user source path, otherwise
                                                       -- select 1 of 3 custome user paths with GTB_SRC_USER1,GTB_SRC_USER2 or GTB_SRC_USER3
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

local
    boolean            : UseEq = true       
    integer            : DecimationFactor    -- Another Scale factor for undersampling ( This parameter is to be passed to procedure DdjEyePattern
    float              : MaxEqualFreq        -- Frequency of maximum equalization if boolean UseEq is set true
    multisite double   : DDJ[MAX_DIGHS]      -- P-P Data Dependent jitter
    multisite double   : EyeWidth[MAX_DIGHS] -- Eye pattern opening at zero volt crossing
    multisite float    : EyeTest[MAX_DIGHS]  -- Eye pattern test result with respect to mask
    multisite float    : DdjPtsOut[MAX_DIGHS,SAMP_DIGHS_MAX_EYE_EDGES]  -- Array of zero volt crossing data transition poiunts
    integer            : ResultTest[3]        
    double             : ISI[MAX_DIGHS] 
    double             : syncDatarate
    double             : x , y , z
    integer            : PortCount
    integer            : ChanPtr
    integer            : SitePtr
    integer            : SiteCount
    word list[16]      : SiteList
    word list[MAX_DIGHS] : DigPorts
end_local

body

    print(stdout,"Calibrating ISI ",IsiLevelName:20," at ",DataRate!fu=GHz:12:6," at ",DiffLevel!fu=mV:8:1," with ",DataPatName:10," pattern")

if tester_simulated then
return
end_if
     PortCount       = len(SampDighsPins) 
     SiteList        = get_active_sites
     SiteCount       = len(SiteList)
    if use_dighsb then
        DigPorts   = dighsb_ptc(SampDighsPins)
    else
        DigPorts   = dighs_ptc(SampDighsPins)
    end_if 

    -- find data rate that makes strictly synchronous sampling possible with 0.1 Hz resolution clocks.
    syncDatarate = double ( integer ( double ( ( DataRate * 10.0 ) / double ( BitsPerWaveform ) ) ) ) *  double ( BitsPerWaveform ) / 10.0

    stop vx_gto GTO_S_Chans output
    SelectGtoSrcClk ( GTO_S_Chans , syncDatarate , JIT_CLK , 0.0 ) 
    SetJitterClkModulation( "off" )

    if EqualLength > 100.0  then
        UseEq = false
    endif
    
    if (GTO_SrcPath < GTB_SRC_USER1) or (GTO_SrcPath > GTB_SRC_USER3) then
        StartGtoDataOutput( GTO_S_Chans , DataPatName , DiffLevel , BALANCED , GTB_NORMAL_SOURCE_RANGING )
    else
        StartUserSrcOutput ( GTO_S_Chans , DataPatName , DiffLevel , BALANCED , GTO_SrcPath )
    end_if

    MaxEqualFreq = float ( syncDatarate * 1.5 )
    SetupDdjEyePattern(SamplerConnection,SampDighsPins,syncDatarate,BitsPerWaveform,MeasLevelMax/MeasurementScale,DecimationFactor)
    wait(20ms)
    DdjEyePattern(SampDighsPins,BitsPerWaveform,EdgesPerWaveform,DecimationFactor,syncDatarate,MeasurementScale,StartOnTrigger,SamplerConnection,UseEq,MaxEqualFreq,EqualLength,EyeMaskData,0,DDJ,EyeWidth,EyeTest,DdjPtsOut) 
    for SitePtr = 1 to SiteCount do  
        for ChanPtr = 1 to PortCount do
           ISI[DigPorts[(SitePtr -1) * PortCount + ChanPtr]] = DDJ[SitePtr,ChanPtr] * syncDatarate
        end_for
    end_for
    set_expr(IsiLevelName + ".Meas",ISI)

    println(stdout,"  Meas Pk-Pk ISI = ",ISI:8:4,"UI")
    
end_body
procedure CharacterizeJitterTolerance(GTO_S_Chans,SampDighsPins,DataPatName,DataRate,DiffLevel,DifInputScale,SourceClock,ModulateClock, DutClockFreq,SamplerConnection,JitTone,JitToneAmpStart,JitToneAmpStop,StepSize,GTO_SrcPath,BertTime,RJ,ISI,BerTest,Vcc,Minor_id,CommentData)
--------------------------------------------------------------------------------
 in pin list[MAX_GTOS]  : GTO_S_Chans                  -- Selected VXGTO-S Channels           
 in pin list[MAX_DIGHS] : SampDighsPins                -- Selected DIGHS Channels                
 in string[32]          : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
 in double              : DataRate                     -- Data Rate of Transmitted data
 in float               : DiffLevel                    -- Differential VXGTO-S output level used during injected jitter testing
 in float               : DifInputScale                -- VCGTO-S output to DUT input ratio
 in integer             : SourceClock                  -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
 in integer             : ModulateClock                -- Selected Clock to Apply Jitter Enter JIT_CLK for Jitter Clock, AUX_CLK for reference (Aux) Clock, or SAMP_CLK for Sampler Clock
 in double              : DutClockFreq                 -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock
 in multisite integer   : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float                : JitTone[?]                   -- Array of Injected Jitter Tone Frequencies  -- Maximum size set to 3 Tones
in float                : JitToneAmpStart              -- Array of Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
in float                : JitToneAmpStop               -- Array of Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
in float                : StepSize[?]                  -- Step size in characterization
in integer              : GTO_SrcPath                  -- Select GTB_SRC if not using custom user source path, otherwise
                                                       -- select 1 of 3 custom user paths with GTB_SRC_USER1,GTB_SRC_USER2 or GTB_SRC_USER3
in float                : BertTime                     -- Time interval for Bit Error Rate Testend_local
in float                : RJ
in float                : ISI
in float                : BerTest  
in float                : Vcc                                                    
in integer              : Minor_id                     --  Minor test ID Number
in string[32]           : CommentData
local
    float              : JitToneScale                               -- Scaled injected jitter tone amplitudes for calibration
    multisite  float   : JitToneMeas[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Measured jitter tone amplitudes
    string[32]         : JitPatName                                 -- A string identifier for selected Injected Sinusoidal Jitter Tones
    string[32]         : CalPatName 
    float              : FreqBinSize                                -- Frequency Bin Size in jitter injection spectrum 
    float              : AWG_FiltFreq                               -- Reconstruction Filter Selection also used for sampling rate selection.
    float              : MeasLevelMax = 249mV                       -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
    float              : MeasurementScale = 2.0 
    integer            : CalBPW                    
    integer            : i,j,k
    float              : MaxFreq                                    -- Highest frequency injected jitter tone
    float              : JitAmp[1]
    float              : JitAmpScaled[1]
    integer            : TxConnection = BALANCED
    multisite double   : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysisend_local 
   multisite boolean   : SyncFail[MAX_GTOS]
   integer             : ChanPtr
   integer             : PortCount
   multisite double    : TotalCount[MAX_GTOS]
   double              : BerAry[800]
   double              : BerMax 
    multisite double   : BitErrorRate [MAX_GTOS]    -- Measured Bit Error Rate
   integer             : GtoRxClockMode = JIT_CLK   -- Select JIT_CLK for JitGtoRxClockModeter Clock (Bit Clock, TX_ODD_WORD, TX_EVEN_WORD
   double              : BERvsJit[400]
   double              : hi_lim
   double              : low_lim
   integer             : n
   integer             : mu
   boolean             : has_failed
end_local

body

  DataviewerCharText = true

--SetJitterClkLevel( 3.0 )


    has_failed = false

    JitAmp = JitToneAmpStart 
    
    hi_lim  =  double(BerTest)
    low_lim =  0.0
    if Minor_id > 1000000 then
        Minor_id = 0
    end_if
    BerMax = double(BerTest)
    FullSpectrum = true
    JitPatName = "Characterization"
    if JitToneAmpStart < 0.7 then
        CalPatName = "HalfRate"
        CalBPW = 2
    else_if JitToneAmpStart < 1.4 then
        CalPatName = "QuarterRate"
        CalBPW = 4
    else_if JitToneAmpStart < 2.8 then
        CalPatName = "EighthRate"
        CalBPW = 8
    else
        CalPatName = "SixteenthRate"
        CalBPW = 16
    end_if
    
    SelectGtoSrcClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq) 
    
    GenerateJitterTones(JitPatName,JitTone,JitAmp,AWG_FiltFreq) 
    StartJitterModulation(JitPatName,ModulateClock,AWG_FiltFreq)

    if (GTO_SrcPath < GTB_SRC_USER1) or (GTO_SrcPath > GTB_SRC_USER3) then
        StartGtoDataOutput(GTO_S_Chans,CalPatName,DiffLevel*DifInputScale,TxConnection,GTB_NORMAL_SOURCE_RANGING)
    else
        StartUserSrcOutput(GTO_S_Chans,CalPatName,DiffLevel*DifInputScale,TxConnection,GTO_SrcPath)
    end_if
    
    MaxFreq = 0.0
    if MaxFreq < JitTone[1] then 
        MaxFreq = JitTone[1]
    endif

    SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,CalBPW,MeasLevelMax,MaxFreq * 2.0)
    wait(100.0ms)
    JitterToneMeasurements(SampDighsPins,CalBPW,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)

    --***** Adjust Tone Gain **********
    if DataRate < 50.0MHz then  -- Can't cal above 50MHz
        JitToneScale = JitAmp[1]/(JitToneMeas[1,1] * float(DataRate)) 
    else
        JitToneScale = 1.0
    endif

    j = 0 
    k = 0
    BitErrorRate = 0.0

    if DataviewerCharText then
        println(stdout,"VCC                    ",Vcc:4:3!u=V)
        println(stdout,"Data Rate              ",DataRate:10:8!u=GHz)
        println(stdout,"Diff Input Level       ",DiffLevel:5:3!U=V)
        println(stdout,"Data Pattern           ",DataPatName)
        if JitTone[1] < 1.0e6 then
            println(stdout,"Jitter Tone Frequency  ",JitTone[1]:4:2!u=KHz)
        else
            println(stdout,"Jitter Tone Frequency  ",JitTone[1]:4:2!u=MHz)
        end_if
        println(stdout,"Test Bit Error Rate   ",BerTest) 
        println(stdout,"Measured Input ISI     ",ISI:6:5,"UI")
        println(stdout,"Measured Random Jitter ",RJ:6:5,"UI P-P")
        println(stdout," ")
        println (stdout,"JItter Magnitude      Bit Error Rate " )
    endif
    
    mu = 8
    k = 0
    while (JitAmp < JitToneAmpStop) and (k< 3) do  
        j = j + 1 * mu
        JitAmp = (JitToneAmpStart + StepSize[1] * float(j-mu))
        JitAmpScaled = JitAmp * JitToneScale
        GenerateJitterTones(JitPatName,JitTone,JitAmpScaled,AWG_FiltFreq)  
        set vx_gto GTO_S_Chans output bit rate frequency to DataRate   
        set vx_gto GTO_S_Chans output clock mode to jitter_clk
        EnableJitterClk("on",DataRate)      
        StartJitterModulation(JitPatName,JIT_CLK,AWG_FiltFreq)
        SetJitterClkModulation("iq")
    
        if (GTO_SrcPath < GTB_SRC_USER1) or (GTO_SrcPath > GTB_SRC_USER3) then
            StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel*DifInputScale,TxConnection,GTB_NORMAL_SOURCE_RANGING)
        else
            StartUserSrcOutput(GTO_S_Chans,DataPatName,DiffLevel*DifInputScale,TxConnection,GTO_SrcPath)
        end_if

        PortCount  = len(GTO_S_Chans)
        i = 0
        BitErrorRate = 1.0
        while (i < 1) and (BitErrorRate > BerMax) do
            i = i + 1 
            stop vx_gto GTO_S_Chans input 
            set vx_gto GTO_S_Chans input bit rate frequency to DataRate
            if GtoRxClockMode = JIT_CLK then
                set vx_gto GTO_S_Chans input clock mode to jitter_clk
            else_if GtoRxClockMode = TX_ODD_WORD then
             set vx_gto GTO_S_Chans input clock mode to word_clk from tx1
            else_if GtoRxClockMode = TX_EVEN_WORD then
                set vx_gto GTO_S_Chans input clock mode to word_clk from tx2
            end_if

            wait(100mS)

            if DataPatName = "prbs7" then
                start vx_gto GTO_S_Chans input pattern prbs7 
            else_if DataPatName = "prbs15" then
                start vx_gto GTO_S_Chans input pattern prbs15 
            else_if DataPatName = "prbs23" then
                start vx_gto GTO_S_Chans input pattern prbs23 
            else_if DataPatName = "prbs31" then
                start vx_gto GTO_S_Chans input pattern prbs31 
            end_if
    
            wait(BertTime)
            stop vx_gto GTO_S_Chans input 
            read vx_gto GTO_S_Chans input fail count into BitErrorRate loss of sync into SyncFail
            read vx_gto GTO_S_Chans input prbs word count into TotalCount  
            TotalCount = TotalCount * 32.0
     
            for ChanPtr = 1 to PortCount do  
                TotalCount[1,ChanPtr] = TotalCount[1,ChanPtr]
                BitErrorRate[1,ChanPtr] = BitErrorRate[1,ChanPtr]/TotalCount[1,ChanPtr]
            end_for
        end_while
         
        if BitErrorRate[1,1] > double(BerTest) then -- 0.25 then
            k = k + 1
        else_if BitErrorRate[1,1] <= double(BerTest) then -- 0.125 then
            k = 0
        end_if
        BERvsJit[j] = BitErrorRate[1,1]

        if DataviewerCharText then
            print (stdout,"      ",JitAmp:5:4,"@tUI P-P     @t",BitErrorRate[1,1])
        end_if

        if mu = 1 and BitErrorRate[1,1] > double(BerTest) and not(has_failed) then 
            println (stdout,"@t@t<------ first failure : test# ",100000000+Minor_id)
            has_failed = true
            test_value JitAmp lo 0.0 hi 10.0 units "BER" pins GTO_S_Chans  test 100000000+Minor_id  comment  sprint(JitTone[1]:4:2!u=KHz)+" "+sprint(DiffLevel:5:1!U=mV)+ " at "+sprint(DataRate/1.0e9:5)+"GB/s First Failure"
        else
            println (stdout,"")
        end_if

        if mu = 8 and   BERvsJit[j]  > 0.0 then
            j = j - 2 * mu
            if j < 0 then
                j = 0
            endif
            mu = 1
        else 

            Minor_id = Minor_id + 1
            if JitTone[1] < 1.0e6 then
                test_value BitErrorRate[1,1] lo low_lim hi hi_lim units "BER" pins GTO_S_Chans  test Minor_id  comment  sprint(JitTone[1]:4:2!u=KHz)+" "+sprint(JitAmp[1]:4:2)+"UI SJ "+sprint(DiffLevel:5:1!U=mV)+ " at "+sprint(DataRate/1.0e9:5)+"GB/s "+CommentData
            else
                test_value BitErrorRate[1,1] lo low_lim hi hi_lim units "BER" pins GTO_S_Chans  test Minor_id  comment  sprint(JitTone[1]:4:2!u=MHz)+" "+sprint(JitAmp[1]:4:2)+"UI SJ "+sprint(DiffLevel:5:1!U=mV)+ " at "+sprint(DataRate/1.0e9:5)+"GB/s "+CommentData
            end_if
            if j mod 10 = 0 then
                wait(1ms) 
            end_if
        endif
    end_while
    if DataviewerCharText then
        println (stdout," ")
        println (stdout," ")
    end_if

endbody
--------------------------------------------------------------------------------

procedure JitterToneMeasurementsTest(GTO_S_Chans,SampDighsPins,DataPatName,SamplerConnection,TxOutLevel,TxConnection,DataRate,BitsPerWaveform,MeasLevelMax,JitterTone, NoiseFreqMax,jitter_tone_limits)
in pin list[MAX_GTOS]  : GTO_S_Chans  -- Selected VXGTO-S Channels           
in pin list[MAX_DIGHS] : SampDighsPins                -- Selected DIGHS Channels                
in string[32]          : DataPatName  -- A string identifier for selected VXGTO TX Data pattern
in multisite integer   : SamplerConnection[MAX_DIGHS] -- AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float               : TxOutLevel   -- Programmed VXGTO-S TX output level
in integer             : TxConnection --  GTO Front End TX output connection mode  -- Enter BALANCED for Differential,SE_PLUS for non-inverting output, or SE_MINUS for the inverting output
in double              : DataRate                     -- Data rate of waveform being tested
in  integer            : BitsPerWaveform              -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
in float               : MeasLevelMax                 --  Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
in float               : JitterTone[?]                -- Jitter Tones being measured
in float               : NoiseFreqMax                 --  High Noise frequency Low Pass cutoff ( Selects DIGHS anti-aliasing filter -- no filter if > 65MHz,
in_out array of float_test : jitter_tone_limits 

local
   multisite float    : JitToneMeas[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Peak to Peak (UI) magnitude of jitter Tone.
   multisite double   : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysis

end_local
body
      StartGtoDataOutput(GTO_S_Chans,DataPatName,TxOutLevel,TxConnection,false)
      SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax,NoiseFreqMax)
      wait(10mS)
      JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitterTone,JitToneMeas,RandomJitter)
      test_value JitToneMeas with jitter_tone_limits mode TVM_PINS 

end_body
procedure CharacterizeJitClkRJ(GTO_S_Chans,SampDighsPins,DataPatName,ClkLevelName,ClkLevelArraySize,DiffLevel,SourceInputScale,BitsPerWaveform,DataRate,MeasLevelMax,MeasurementScale,BitErrorRate,SamplerConnection,NoiseFreqMax,NoiseFreqMin,NoiseFreqHP_Corner,Minor_id,CommentData)
in pin list[MAX_GTOS]   : GTO_S_Chans                  -- Selected VXGTO-S Channels           
in pin list[MAX_DIGHS]  : SampDighsPins                -- Selected DIGHS Channels                
in string[32]           : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
in string[32]           : ClkLevelName                 -- Identerfier for measured P-P Random Jitter
in integer              : ClkLevelArraySize            -- Size of Clock Level Array
in float                : DiffLevel                    -- Differential VXGTO-S output level used during injected jitter calibration
in float                : SourceInputScale             -- Differential VXGTO-S output level Scale Factor
in integer              : BitsPerWaveform              -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
in double               : DataRate                     -- Data Rate of Transmitted data
in float                : MeasLevelMax                 -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
in  float               : MeasurementScale             -- Scale factor to correct for attenuation in measurement path  
in float                : BitErrorRate                 -- Test Bit Error Rate Test
in multisite integer    : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float                : NoiseFreqMax                 -- High Noise frequency Low Pass Brick wall cutoff 
in float                : NoiseFreqMin                 -- Low Noise frequency High Pass Brick wall cutoff 
in float                : NoiseFreqHP_Corner           -- Low Noise frequency High Pass 3dB cutoff
in integer              : Minor_id                     --  Minor test ID Number
in string[32]           : CommentData
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure is intended to characterize the random jitter generated by the VXGTO transmitter output 
-- Amplitude of the VXGTO/S Jitter Clock input affects the magnitude of the random jitter generated by
-- the VXGTO/S onto its transmitted data.  A repeating 1010..10 pattern should be used as the characterization
-- waveform.  
------------------------------------------------------------------------------------------------------------
local
    float              : hi_lim
    float              : low_lim
    float              : ScaledDiffLevel
    float              : MaxRangeLevel
    float              : StepSize
    float              : RjArray[100]
    float              : P_P_Jitter                           -- P-P Random Jitter for Specified Execution time
    integer            : SourceClock = JIT_CLK                -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock
    integer            : TxConnection = BALANCED
    integer            : NumOfTones = 6
    integer            : i
    float              : RjReference
    float              : RjMeasured
    multisite float    : JitterTones[MAX_DIGHS,MAX_NUM_TONES] -- Periodic Jitter Tone Frequencies
    multisite float    : PP_Jitter[MAX_DIGHS,MAX_NUM_TONES]   -- Periodic Tone's Jitter P-P 
    multisite double   : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysisend_local 
    boolean            : StartOnTrigger = false
end_local
body
---------------------------------------------------------------------------------------------------------------
    ScaledDiffLevel = DiffLevel * SourceInputScale 
    hi_lim  =  1.0
    low_lim =  0.0
    if Minor_id > 1000000 then
        Minor_id = 0
    end_if

    if  ScaledDiffLevel < 100mv then
       StepSize = 0.001
       MaxRangeLevel = 99.999mV
    else 
       StepSize = 0.03 
       MaxRangeLevel = 0.99999V
    end_if
    ScaledDiffLevel = ScaledDiffLevel - StepSize * SourceInputScale
    i = 0

    if DataviewerCharText then
        println(stdout,"Data Rate              ",DataRate:10:8!u=GHz)
        println(stdout,"Data Pattern           ",DataPatName)
        println(stdout,"Test Bit Error Rate   ",BitErrorRate) 
        println(stdout," ")
        println (stdout,"Diff Input Level      Measured Random Jitter P-P " )
    end_if
    while (i < 100) and (ScaledDiffLevel < MaxRangeLevel) do
         i = i + 1
         ScaledDiffLevel = ScaledDiffLevel + StepSize * SourceInputScale
         RjMeasured = 0.0
         set vx_gto GTO_S_Chans output bit rate frequency to DataRate   
         set vx_gto GTO_S_Chans output clock mode to jitter_clk
         EnableJitterClkForRJ("on",DataRate)
         SetJitterClkModulation("off")
         StartGtoDataOutput(GTO_S_Chans,DataPatName,ScaledDiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)

        SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,NoiseFreqMax)
        wait(150ms)
        SpectrumAnalysis(SampDighsPins,BitsPerWaveform,DataRate,StartOnTrigger,MeasLevelMax,NoiseFreqMin,NoiseFreqHP_Corner,NoiseFreqMax,NumOfTones, RandomJitter,JitterTones,PP_Jitter)
        RjMeasured = float(RandomJitter[1,1]) * float(DataRate)
        RjArray[i] = Pk_pk_from_rms(RjMeasured,1.0/BitErrorRate)
        if DataviewerCharText then
            println(stdout,ScaledDiffLevel/SourceInputScale:5:3!U=mV,"     ",RjArray[i]:4:3,"UI P-P")
        end_if
        Minor_id = Minor_id + 1
        test_value RjArray[i] lo low_lim hi hi_lim units "UI" pins GTO_S_Chans  test Minor_id comment "RJ on "+sprint(ScaledDiffLevel/SourceInputScale:5:1!U=mV)+ " Signal at "+sprint(DataRate/1.0e9:5)+"GB/s "+CommentData
        wait(1ms)   
    end_while
    set_expr(ClkLevelName + ".Meas",RjArray[1:ClkLevelArraySize])
    if DataviewerCharText then
         println(stdout," ")
         println(stdout," ")
         println(stdout," ")
     end_if
   wait(1ms)   
end_body

procedure CharacterizeGtoSrcIsi(GTO_S_Chans,SampDighsPins,IsiLevelName,IsiLevelArraySize,DiffLevel,SourceInputScale,DataRate,MeasLevelMax,MeasurementScale,SamplerConnection,EqualLength,EyeMaskData,GTO_SrcPath,Minor_id,CommentData)
in pin list[MAX_GTOS]   : GTO_S_Chans                  -- Selected VXGTO-S Channels           
in pin list[MAX_DIGHS]  : SampDighsPins                -- Selected DIGHS Channels                
in string[32]           : IsiLevelName                 -- Identerfier for measured ISI
in integer              : IsiLevelArraySize            -- Size of ISI Level Array
in float                : DiffLevel                    -- Differential VXGTO-S output level used during injected jitter calibration
in float                : SourceInputScale             -- Differential VXGTO-S output level Scale Factor
in double               : DataRate                     -- Data Rate of Transmitted data
in float                : MeasLevelMax                 -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
in  float               : MeasurementScale             -- Scale factor to correct for attenuation in measurement path  
in multisite integer    : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float                : EqualLength                  -- Total trace length in DUT output measurement path to be equalized if boolean UseEq is set true
in float                : EyeMaskData[6]               -- Eye Pattern mask's Early Zero Crossing Bit Cell marker point
in integer              : GTO_SrcPath                  -- Select GTB_SRC if not using custom user source path, otherwise
                                                       -- select 1 of 3 custome user paths with GTB_SRC_USER1,GTB_SRC_USER2 or GTB_SRC_USER3
in integer              : Minor_id                     --  Minor test ID Number
in string[32]           : CommentData
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure is intended to characterize the random jitter generated by the VXGTO transmitter output 
-- Amplitude of the VXGTO/S Jitter Clock input affects the magnitude of the random jitter generated by
-- the VXGTO/S onto its transmitted data.  A repeating 1010..10 pattern should be used as the characterization
-- waveform.  
------------------------------------------------------------------------------------------------------------
local
  string[32]           : DataPatName = "prbs7"             -- A string identifier for selected VXGTO TX Data pattern
   integer             : BitsPerWaveform = 127             -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
   integer             : EdgesPerWaveform = 64             -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
    float              : ScaledDiffLevel
    float              : MaxRangeLevel
    float              : StepSize
    float              : IsiArray[100]
    float              : P_P_Jitter                           -- P-P Random Jitter for Specified Execution time
    integer            : SourceClock = JIT_CLK                -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock
    integer            : TxConnection = BALANCED
    integer            : i
    multisite float    : JitterTones[MAX_DIGHS,MAX_NUM_TONES] -- Periodic Jitter Tone Frequencies
    multisite float    : PP_Jitter[MAX_DIGHS,MAX_NUM_TONES]   -- Periodic Tone's Jitter P-P 
    multisite double   : RandomJitter[MAX_DIGHS]              -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysisend_local 
    boolean            : StartOnTrigger = false
    boolean            : UseEq = true       
    integer            : DecimationFactor    -- Another Scale factor for undersampling ( This parameter is to be passed to procedure DdjEyePattern
    float              : MaxEqualFreq        -- Frequency of maximum equalization if boolean UseEq is set true
    multisite double   : DDJ[MAX_DIGHS]      -- P-P Data Dependent jitter
    multisite double   : EyeWidth[MAX_DIGHS] -- Eye pattern opening at zero volt crossing
    multisite float    : EyeTest[MAX_DIGHS]  -- Eye pattern test result with respect to mask
    multisite float    : DdjPtsOut[MAX_DIGHS,SAMP_DIGHS_MAX_EYE_EDGES]  -- Array of zero volt crossing data transition poiunts
    integer            : ResultTest[3]        
    double             : ISI
    float              : hi_lim
    float              : low_lim
end_local
body
---------------------------------------------------------------------------------------------------------------
    ScaledDiffLevel = DiffLevel * SourceInputScale 
    hi_lim  =  1.0
    low_lim =  0.0
    if Minor_id > 1000000 then
        Minor_id = 0
    end_if
    if  ScaledDiffLevel < 100mv then
       StepSize = 0.001
       MaxRangeLevel = 99.999mV
    else 
       StepSize = 0.01 
       MaxRangeLevel = 0.99999V
    end_if
    ScaledDiffLevel = ScaledDiffLevel - StepSize * SourceInputScale
    i = 0

    if DataviewerCharText then
         println(stdout,"Data Rate              ",DataRate:10:8!u=GHz)
         println(stdout,"Data Pattern           ",DataPatName)
         println (stdout,"Diff Input Level      Measured ISI P-P " )
    end_if
    
    while (i < 100) and (ScaledDiffLevel < MaxRangeLevel) do
         i = i + 1
         ScaledDiffLevel = ScaledDiffLevel + StepSize * SourceInputScale
         set vx_gto GTO_S_Chans output bit rate frequency to DataRate   
         set vx_gto GTO_S_Chans output clock mode to jitter_clk
         EnableJitterClkForRJ("on",DataRate)
         SetJitterClkModulation("off")

    if EqualLength > 100.0 or EqualLength <= 0.0 then
        UseEq = false
    end_if
    if (GTO_SrcPath < GTB_SRC_USER1) or (GTO_SrcPath > GTB_SRC_USER3) then
        StartGtoDataOutput(GTO_S_Chans,DataPatName,ScaledDiffLevel,BALANCED,GTB_NORMAL_SOURCE_RANGING)
    else
        StartUserSrcOutput(GTO_S_Chans,DataPatName,ScaledDiffLevel,BALANCED,GTO_SrcPath)
    end_if

    MaxEqualFreq = float(DataRate * 1.5)
    SetupDdjEyePattern(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,DecimationFactor)
    wait(150ms)
    DdjEyePattern(SampDighsPins,BitsPerWaveform,EdgesPerWaveform,DecimationFactor,DataRate,MeasurementScale,StartOnTrigger,SamplerConnection,UseEq,MaxEqualFreq,EqualLength,EyeMaskData,0,DDJ,EyeWidth,EyeTest,DdjPtsOut) 
    IsiArray[i] = float(DDJ[1,1] * DataRate)
    if DataviewerCharText then
        println(stdout,ScaledDiffLevel/SourceInputScale:5:3!U=mV,"     ",IsiArray[i]:4:3,"UI P-P")
    end_if
        Minor_id = Minor_id + 1
        test_value IsiArray[i] lo low_lim hi hi_lim units "UI" pins GTO_S_Chans  test Minor_id comment "ISI on "+sprint(ScaledDiffLevel/SourceInputScale:5:1!U=mV)+ " Signal at "+sprint(DataRate/1.0e9:5)+"GB/s "+CommentData

        wait(1ms)   
    end_while
    set_expr(IsiLevelName + ".Meas",IsiArray[1:IsiLevelArraySize])
    if DataviewerCharText then
       println(stdout," ")
       println(stdout," ")
       println(stdout," ")
    end_if
   wait(1ms)   
end_body

procedure CalSinisoidalJitterRolloff(GTO_S_Chans,SampDighsPins,DataPatName,BitsPerWaveform,DataRate,MeasLevelMax,MeasurementScale,SourceClock,ModulateClock, DutClockFreq,SamplerConnection,JitToneAmp)
 in pin list[MAX_GTOS]  : GTO_S_Chans                  -- Selected VXGTO-S Channels           
 in pin list[MAX_DIGHS] : SampDighsPins                -- Selected DIGHS Channels                
 in string[32]          : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
 in integer             : BitsPerWaveform              -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
 in double              : DataRate                     -- Data Rate of Transmitted data
 in  float              : MeasLevelMax                 -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
 in  float              : MeasurementScale             -- Scale factor to correct for attenuation in measurement path  
 in integer             : SourceClock                  -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
 in integer             : ModulateClock                -- Selected Clock to Apply Jitter Enter JIT_CLK for Jitter Clock, AUX_CLK for reference (Aux) Clock, or SAMP_CLK for Sampler Clock
 in double              : DutClockFreq                 -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock
 in multisite integer   : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float                : JitToneAmp[?]                -- Array of Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure is intended to calibrate injected sinusoidal jitter generated by the VXGTO transmitter output and
-- should be used as a focused calibration executed once during program load for each required injected jitter waveform. 
-- Up to 3 Jitter tones may be included in a single waveform.  Maximum frequency of injected Jitter is limited by the
-- maximum sampling rate of the AWGHS to below 60MHz.  Each individual jitter waveform is identified by a unique string name
-- passed into this procedure.  The string identifier can later be used by other procedures within this module to inject the 
-- specified jitter waveform. 
------------------------------------------------------------------------------------------------------------
local
   float               : JitToneRef
   float               : JitTone[1]                   -- Array of Injected Jitter Tone Frequencies  -- Maximum size set to 3 Tones
   float               : Rolloff[6]
   string[32]          : JitPatName = "RolloffName"                 -- A string identifier for selected Injected Sinusoidal Jitter Tones
    float              : JitToneScale[MAX_NO_JITTER_TONES]          -- Scaled injected jitter tone amplitudes for calibration
    multisite  float   : JitToneMeas[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Measured jitter tone amplitudes
    float              : FreqBinSize                                -- Frequency Bin Size in jitter injection spectrum 
    float              : AWG_FiltFreq                               -- Reconstruction Filter Selection also used for sampling rate selection.
    float              : DiffLevel = 0.9999                         -- Differential VXGTO-S output level used during injected jitter calibration
    float              : MaxFreq
    integer            : NoOfInjectedTones                          -- Number of periodic jitter tones frequencies to be processed
    integer            : i,j,k
    integer            : CalPt[6]
    integer            : TxConnection = BALANCED
    integer            : CalPoints
    multisite double   : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysisend_local 
    
end_local
body

Rolloff=1.0
AwghsbRolloff = 1.0
JitToneRef = JitToneAmp[1]
CalPt[1] = 1
CalPt[2] = 30
CalPt[3] = 50
CalPt[4] = 60
CalPt[5] = 70
CalPt[6] = 80
if use_awghsb then
    CalPoints = 6
    CalPt[1] = 1
    CalPt[2] = 30
    CalPt[3] = 50
    CalPt[4] = 60
    CalPt[5] = 70
    CalPt[6] = 80
    Rolloff[1] = 2.06
    Rolloff[2] = 2.46
    Rolloff[3] = 4.85
    Rolloff[4] = 3.61
    Rolloff[5] = 3.51
    Rolloff[6] = 4.65
else
    CalPoints = 5
    CalPt[1] = 1
    CalPt[2] = 15
    CalPt[3] = 25
    CalPt[4] = 30
    CalPt[5] = 40
    Rolloff[1] = 1.0
    Rolloff[2] = 1.16
    Rolloff[3] = 1.25
    Rolloff[4] = 1.43
    Rolloff[5] = 1.43
    
end_if

if tester_simulated then
return
end_if

for k= 1 to CalPoints do
--    stop vx_gto 1 output
    j = CalPt[k]
    -- j = k
    JitToneAmp[1] = JitToneRef
    JitTone[1] = float(j) * 1.0MHz
    if k<> 1 then
    --    Rolloff[k] = Rolloff[k-1]
    end_if
    SelectGtoSrcClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq) 
    GenerateJitterTones(JitPatName,JitTone,JitToneAmp,AWG_FiltFreq) 
    AwghsbTone = AWGHSB_SAMPLING_FREQ/4.0 -3750.0
    OffsetC = OffsetC / Rolloff[k]
    OffsetS = OffsetS / Rolloff[k]
    StartJitterModulation(JitPatName,ModulateClock,101.0MHz)
    NoOfInjectedTones = 1
    MaxFreq = 0.0
    for i = 1 to NoOfInjectedTones do
        if MaxFreq < JitTone[i] then 
            MaxFreq = JitTone[i]
        end_if
    end_for
    
    StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)
    FullSpectrum = true
    SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,MaxFreq * 2.0)
    wait(100.0ms)
    JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)

if JitTone [ 1 ] <> 52MHz then
    --***** Adjust Tone Gain **********  
    JitToneScale[1] = JitToneAmp[1]/(JitToneMeas[1,1] * float(DataRate)) 
    Rolloff[k] = Rolloff[k] * (JitToneScale[1])  
    GenerateJitterTones(JitPatName,JitTone,JitToneAmp,AWG_FiltFreq)  
    AwghsbTone = AWGHSB_SAMPLING_FREQ/4.0 -3750.0
    OffsetC = OffsetC / Rolloff[k]
    OffsetS = OffsetS / Rolloff[k]
    StartJitterModulation(JitPatName,ModulateClock,101.0MHz)
    wait(100.0ms)
    JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)
endif
   --******* Verify Generated Injected Jitter Tones
    if DisplayMode then   --   **** Set DisplayMode true to observe Spectrum in Status Display ****        
        wait(100.0ms)
        FullSpectrum = true
        JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)
        FullSpectrum = false
        if MaxFreq * 2.0 < (SAMP_DIGHS_SPECTRUM_CLK_FREQ/4.0 - SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES) then
            FreqBinSize = SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES/2.0
        else
            FreqBinSize = SAMP_DIGHS_SPECTRUM_CLK_FREQ/SAMP_DIGHS_SPECTRUM_SAMPLES
        end_if
                   
            
                          -- a -g  SpectrumRef; grid   
                                 --**** Enter Numeric values -- scale -mult FreqBinSize  -offset 0.0                   
                          -- units -x MHz
                          -- units -y dB                

                    wait(0mS)   -- SET BREAKPOINT HERE TO OBSERVE WAVEFORM ON STATUS DISPLAY
    end_if
end_for 
     if use_awghsb then
         for i = 1 to 80 do
             if i < 30 then
                 AwghsbRolloff[i] = float(i-1)/30.0*(Rolloff[2]-Rolloff[1]) + Rolloff[1]
             else_if i < 50 then
                 AwghsbRolloff[i] = float(i-30)/(50.0 - 30.0)*(Rolloff[3]-Rolloff[2]) + Rolloff[2]
             else_if i < 60 then
                 AwghsbRolloff[i] = float(i-50)/(60.0 - 50.0)*(Rolloff[4]-Rolloff[3]) + Rolloff[3]
             else_if i < 70 then
                 AwghsbRolloff[i] = float(i-60)/(70.0 - 60.0)*(Rolloff[5]-Rolloff[4]) + Rolloff[4]
             else_if i <= 80 then
                 AwghsbRolloff[i] = float(i-70)/(80.0 - 70.0)*(Rolloff[6]-Rolloff[5]) + Rolloff[5]
             end_if
         end_for
    else
         for i = 1 to 40 do
             if i < 15 then
                 AwghsbRolloff[i] = float(i-1)/15.0*(Rolloff[2]-Rolloff[1]) + Rolloff[1]
             else_if i < 25 then
                 AwghsbRolloff[i] = float(i-15)/(25.0 - 15.0)*(Rolloff[3]-Rolloff[2]) + Rolloff[2]
             else_if i < 30 then
                 AwghsbRolloff[i] = float(i-25)/(30.0 - 25.0)*(Rolloff[4]-Rolloff[3]) + Rolloff[3]
             else_if i <= 40 then
                 AwghsbRolloff[i] = float(i-30)/(40.0 - 30.0)*(Rolloff[5]-Rolloff[4]) + Rolloff[4]
             end_if
         end_for
         AwghsbRolloff[41:80] = AwghsbRolloff[40]
    end_if
-- AwghsbRolloff = 1.0
    wait(1.0ms) 
end_body

procedure SineJitterTest ( deviation , cosAry , sinAry )
--------------------------------------------------------------------------------
in float                : deviation
in_out float            : cosAry [ ? ]
in_out float            : sinAry [ ? ]

const REAL              = 1
const IMAG              = 2
const MAGN              = 1
const PHAS              = 2
const PI                = rad ( 180.0 )
const ARY_SZ            = 1024

local integer           : length
local integer           : i , j , l , m
local float             : w , x , y , z
local float             : cartAry [ 2 , ARY_SZ ]
local float             : cartAry2 [ ARY_SZ , 2 ]
local float             : polrAry [ 2 , ARY_SZ ]
local float             : polrLimitedAry [ 2 , ARY_SZ ]
local float             : arySz
local float             : gScale
local float             : xT
local float             : yT
local float             : plrAry [ 2 ]
local float             : h1
local float             : dc1

body

deviation = 1.05 * deviation
    z = deviation
    ph = 60.0
    JitterCorrection52MHz ( z , apex )
    w = PI * z
    xT = cos ( w )
    yT = sin ( w )
    y = 0.5
    x = 0.5
    arySz = float ( ARY_SZ )
    gScale = 1.0
    plrAry [ 1 ] = 1.0
    for i = 1 to ARY_SZ do
        plrAry [ 2 ] = deg ( w * cos ( 2.0 * PI * float ( i - 1 ) / arySz ) )
        cartAry2 [ i ] = polar_to_cartesian ( plrAry )
    endfor
    for j = 1 to 1 do
        cartAry2 = complex_fft ( cartAry2 )
        cartAry2 [ 4 : 1022 ] = 0.0
        cartAry2 = inverse_complex_fft ( cartAry2 )
        z = ( apex - xT ) / ( cartAry2 [ 257 , 1 ] - cartAry2 [ 1 , 1 ] )
        for i = 1 to ARY_SZ do
            cartAry2 [ i , 1 ] = cartAry2 [ i , 1 ] * z
        endfor
        x = apex - cartAry2 [ 257 , 1 ]
        for i = 1 to ARY_SZ do
            cartAry2 [ i , 1 ] = cartAry2 [ i , 1 ] + x
        endfor
        y = yT / cartAry2 [ 1 , 2 ] 
        for i = 1 to ARY_SZ do
            cartAry2 [ i , 2 ] = cartAry2 [ i , 2 ] * y
        endfor
    endfor
    
    -- sinX/X correction
    cartAry2 = complex_fft ( cartAry2 )
    cartAry2 [ 1 ] = cartAry2 [ 1 ] / 1.3
    cartAry2 [ 2 ] = cartAry2 [ 2 ] / 1.0 
    cartAry2 [ ARY_SZ ] = cartAry2 [ ARY_SZ ]  / 1.0
    
    plrAry = cartesian_to_polar ( cartAry2 [ ARY_SZ ] )
    plrAry [ 2 ] = plrAry [ 2 ]  + ph
    cartAry2 [ ARY_SZ ] = polar_to_cartesian ( plrAry )
    
    plrAry = cartesian_to_polar ( cartAry2 [ 2 ] )
    plrAry [ 2 ] = plrAry [ 2 ]  - ph
    cartAry2 [ 2 ] = polar_to_cartesian ( plrAry )
    
    cartAry2 = inverse_complex_fft ( cartAry2 )
    
    for i = 1 to ARY_SZ do
        plrAry = cartesian_to_polar ( cartAry2 [ i ] )
        polrAry [ MAGN , i ] = plrAry [ MAGN ]
        polrAry [ PHAS , i ] = rad ( plrAry [ PHAS ] ) / PI
        polrLimitedAry [ PHAS , i ] = rad ( plrAry [ PHAS ] ) / PI
    endfor
        
   
    polrAry [ 2 ] = abs ( fft (  polrAry [ 2 ] ) )+ 0.00000001
   
    length = dimsize ( cosAry , 1 )
    for i = 1 to length do
        cosAry [ i ] = cartAry2 [ ( ( i - 1 ) & 3 ) * 256 + 1 , REAL ] * 0.5 --+ cartAry2 [ ( ( i - 1 ) & 3 ) * 256 + 1 , IMAG ]
        sinAry [ i ] = cartAry2 [ ( ( i - 1 ) & 3 ) * 256 + 1 , IMAG ] * 0.5 --- cartAry2 [ ( ( i - 1 ) & 3 ) * 256 + 1 , REAL ] 
    endfor
    
-- a -g cartAry [ 1 ] ; grid
-- a -g cartAry [ 2 ]

endbody
--------------------------------------------------------------------------------

procedure JitterCorrection52MHz ( magnitude , apex )
--------------------------------------------------------------------------------
in_out float                : magnitude
in_out float                : apex

local integer               : i
local float                 : m

body

    if magCorrect  [ 1  ] <>  0.01 then
        magCorrect  [ 1  ] = 0.01
        magCorrect  [ 2  ] = 0.02
        magCorrect  [ 3  ] = 0.03
        magCorrect  [ 4  ] = 0.04
        magCorrect  [ 5  ] = 0.05
        magCorrect  [ 6  ] = 0.06
        magCorrect  [ 7  ] = 0.07
        magCorrect  [ 8  ] = 0.08
        magCorrect  [ 9  ] = 0.09
        magCorrect  [ 10 ] = 0.10
        magCorrect  [ 11 ] = 0.11
        magCorrect  [ 12 ] = 0.12
        magCorrect  [ 13 ] = 0.13
        magCorrect  [ 14 ] = 0.14
        magCorrect  [ 15 ] = 0.15
        magCorrect  [ 16 ] = 0.16
        magCorrect  [ 17 ] = 0.17
        magCorrect  [ 18 ] = 0.18
        magCorrect  [ 19 ] = 0.19
        magCorrect  [ 20 ] = 0.20
        magCorrect  [ 21 ] = 0.208
        magCorrect  [ 22 ] = 0.216
        magCorrect  [ 23 ] = 0.224
        magCorrect  [ 24 ] = 0.232
        magCorrect  [ 25 ] = 0.24
        magCorrect  [ 26 ] = 0.248
        magCorrect  [ 27 ] = 0.256
        magCorrect  [ 28 ] = 0.264
        magCorrect  [ 29 ] = 0.272
        magCorrect  [ 30 ] = 0.28
        magCorrect  [ 31 ] = 0.292
        magCorrect  [ 32 ] = 0.304
        magCorrect  [ 33 ] = 0.316
        magCorrect  [ 34 ] = 0.328
        magCorrect  [ 35 ] = 0.34
        magCorrect  [ 36 ] = 0.348
        magCorrect  [ 37 ] = 0.356
        magCorrect  [ 38 ] = 0.364
        magCorrect  [ 39 ] = 0.372
        magCorrect  [ 40 ] = 0.38
        magCorrect  [ 41 ] = 0.39
        magCorrect  [ 42 ] = 0.40
        magCorrect  [ 43 ] = 0.41
        magCorrect  [ 44 ] = 0.42
        magCorrect  [ 45 ] = 0.43
        magCorrect  [ 46 ] = 0.436
        magCorrect  [ 47 ] = 0.442
        magCorrect  [ 48 ] = 0.448
        magCorrect  [ 49 ] = 0.454
        magCorrect  [ 50 ] = 0.46
        magCorrect  [ 51 ] = 0.466
        magCorrect  [ 52 ] = 0.472
        magCorrect  [ 53 ] = 0.478
        magCorrect  [ 54 ] = 0.484
        magCorrect  [ 55 ] = 0.49
        magCorrect  [ 56 ] = 0.50
        magCorrect  [ 57 ] = 0.51
        magCorrect  [ 58 ] = 0.52
        magCorrect  [ 59 ] = 0.53
        magCorrect  [ 60 ] = 0.54
        magCorrect  [ 61 ] = 0.548
        magCorrect  [ 62 ] = 0.556
        magCorrect  [ 63 ] = 0.564
        magCorrect  [ 64 ] = 0.572
        magCorrect  [ 65 ] = 0.58
        magCorrect  [ 66 ] = 0.59
        magCorrect  [ 67 ] = 0.60
        magCorrect  [ 68 ] = 0.61
        magCorrect  [ 69 ] = 0.62
        magCorrect  [ 70 ] = 0.63
        magCorrect  [ 71 ] = 0.646
        magCorrect  [ 72 ] = 0.662
        magCorrect  [ 73 ] = 0.678
        magCorrect  [ 74 ] = 0.694
        magCorrect  [ 75 ] = 0.71
        magCorrect  [ 76 ] = 0.73
                            
        apexCorrect [ 1  ] = 1.00
        apexCorrect [ 2  ] = 1.00
        apexCorrect [ 3  ] = 0.99
        apexCorrect [ 4  ] = 0.99
        apexCorrect [ 5  ] = 0.98
        apexCorrect [ 6  ] = 0.98
        apexCorrect [ 7  ] = 0.97
        apexCorrect [ 8  ] = 0.97
        apexCorrect [ 9  ] = 0.96
        apexCorrect [ 10 ] = 0.96
        apexCorrect [ 11 ] = 0.95
        apexCorrect [ 12 ] = 0.95
        apexCorrect [ 13 ] = 0.94
        apexCorrect [ 14 ] = 0.94
        apexCorrect [ 15 ] = 0.93
        apexCorrect [ 16 ] = 0.93
        apexCorrect [ 17 ] = 0.92
        apexCorrect [ 18 ] = 0.92
        apexCorrect [ 19 ] = 0.91
        apexCorrect [ 20 ] = 0.90
        apexCorrect [ 21 ] = 0.88
        apexCorrect [ 22 ] = 0.86
        apexCorrect [ 23 ] = 0.84
        apexCorrect [ 24 ] = 0.82
        apexCorrect [ 25 ] = 0.8
        apexCorrect [ 26 ] = 0.78
        apexCorrect [ 27 ] = 0.76
        apexCorrect [ 28 ] = 0.74
        apexCorrect [ 29 ] = 0.72
        apexCorrect [ 30 ] = 0.7
        apexCorrect [ 31 ] = 0.68
        apexCorrect [ 32 ] = 0.66
        apexCorrect [ 33 ] = 0.64
        apexCorrect [ 34 ] = 0.62
        apexCorrect [ 35 ] = 0.6
        apexCorrect [ 36 ] = 0.586
        apexCorrect [ 37 ] = 0.572
        apexCorrect [ 38 ] = 0.558
        apexCorrect [ 39 ] = 0.544
        apexCorrect [ 40 ] = 0.53
        apexCorrect [ 41 ] = 0.514
        apexCorrect [ 42 ] = 0.492
        apexCorrect [ 43 ] = 0.478
        apexCorrect [ 44 ] = 0.464
        apexCorrect [ 45 ] = 0.45
        apexCorrect [ 46 ] = 0.432
        apexCorrect [ 47 ] = 0.414
        apexCorrect [ 48 ] = 0.396
        apexCorrect [ 49 ] = 0.378
        apexCorrect [ 50 ] = 0.36
        apexCorrect [ 51 ] = 0.348
        apexCorrect [ 52 ] = 0.336
        apexCorrect [ 53 ] = 0.324
        apexCorrect [ 54 ] = 0.312
        apexCorrect [ 55 ] = 0.3
        apexCorrect [ 56 ] = 0.29
        apexCorrect [ 57 ] = 0.28
        apexCorrect [ 58 ] = 0.27
        apexCorrect [ 59 ] = 0.26
        apexCorrect [ 60 ] = 0.25
        apexCorrect [ 61 ] = 0.236
        apexCorrect [ 62 ] = 0.222
        apexCorrect [ 63 ] = 0.208
        apexCorrect [ 64 ] = 0.194
        apexCorrect [ 65 ] = 0.18
        apexCorrect [ 66 ] = 0.172
        apexCorrect [ 67 ] = 0.164
        apexCorrect [ 68 ] = 0.156
        apexCorrect [ 69 ] = 0.148
        apexCorrect [ 70 ] = 0.14
        apexCorrect [ 71 ] = 0.132
        apexCorrect [ 72 ] = 0.124
        apexCorrect [ 73 ] = 0.116
        apexCorrect [ 74 ] = 0.108
        apexCorrect [ 75 ] = 0.1
        apexCorrect [ 76 ] = 0.092
    endif

    m = magnitude * 100.0 
    i = integer ( m )
    m = m - float ( i )
    magnitude = m * magCorrect   [ i + 1 ] + ( 1.0 - m ) * magCorrect   [ i + 1 ]
    apex      = m * apexCorrect  [ i + 1 ] + ( 1.0 - m ) * apexCorrect  [ i + 1 ]
    
endbody
--------------------------------------------------------------------------------
procedure Inventory_dig
-----------------------
local
           boolean:  present    =  false
       string[256]:  iu         =  ""
    word list[256]:  iu_boards  =  <::>
          set[256]:  chans      =  []
          set[256]:  all_chans  =  []
              word:  handle     =  0
              word:  pn         =  0
              word:  var        =  0
       string[256]:  rev        =  ""
       string[256]:  sn         =  ""
       string[256]:  name       =  ""
           integer:  num        =  0
              word:  b          =  0  
 
endlocal

body

    iu = "dighsb"

    all_chans = inventory_all_chans (iu)

    present = iu_present (iu, all_chans)

    iu_boards = restricted_get_boards (iu, all_chans)

    num = len (iu_boards)

    if present and (num >= 2) then

        for b = 2 to word (num) do

            handle = iu_boards[b]  -- note: [1] is the driver
            chans  = restricted_board_chans  (iu, handle)
            pn     = restricted_board_part   (handle)
            var    = restricted_board_var    (handle)    
            rev    = restricted_board_rev    (handle)
            sn     = restricted_board_serial (handle)
            name   = restricted_board_name   (handle)

            print (stdout, "dighsb", chans, " board: var ", var!z!d:2)
            print (stdout, ", rev ", rev, ", sn", sn, "@n")

        endfor

    endif

endbody

procedure Test_dig_firmware (dig_chan)
--------------------------------------
in word:  dig_chan

const
    FPGA_FW         = 16#01  -- FPGA firmware version
    CPLD1_FW        = 16#8f  -- CPLD1 firmware version
    CPLD2_FW        = 16#9f  -- CPLD2 firmware version
endconst

local

     word:  temp_data    = 0
     word:  dig_fpga_fw  = 0
     word:  dig_cpld1_fw = 0
     word:  dig_cpld2_fw = 0
 
endlocal

body

    if dig_chan == 0 then
        return
    endif

    --
    -- Check FPGA and CPLDs firmware versions:
    --
    read dighsb dig_chan ltx_internal_use_only reg FPGA_FW into temp_data
    dig_fpga_fw = (temp_data >> 8)
    read dighsb dig_chan ltx_internal_use_only reg CPLD1_FW into dig_cpld1_fw
    read dighsb dig_chan ltx_internal_use_only reg CPLD2_FW into dig_cpld2_fw

    -- ag fw; a dig_fpga_fw; a dig_cpld1_fw; a dig_cpld2_fw

    print (stdout, "dighsb [", dig_chan!d:1, "] firmware: ", dig_fpga_fw!d:2, ", ")
    print (stdout, dig_cpld1_fw!d:2, ", ", dig_cpld2_fw!d:2, "@n")

endbody

procedure LoadAWG520  ( JitPatName , JitterCosPattern , JitterSinPattern , inFrequency )
--------------------------------------------------------------------------------
in string[32]           : JitPatName  
in_out float            : JitterCosPattern [ ? ]
in_out float            : JitterSinPattern [ ? ]
in double               : inFrequency

local word              : inAry [ 65536 ]
local word              : outAry [ 65536 ]
local string  [ 256 ]   : str
local integer           : i , j , k
local integer           : file1
local float             : x
local float             : waveformData [ 2048 ]
const PI                = rad ( 180.0 )

body

    open ( file1 , "/opt/ltx_nic/tp/b.wfm" , "r" )
        read ( file1 , inAry )
    close ( file1 )

    waveformData = 0.0
for k = 18  to 400 by 5 do    
    open ( file1 , "/opt/ltx_nic/tp/b.wfm" , "r" )
        read ( file1 , inAry )
    close ( file1 )
        
    j = 0
    for i = 4 downto 1 do 
        j = j +  ( asc ( getByte ( i + k , inAry ) )  & 255 ) 
        if i > 1 then
            j = j * 256
        endif
    endfor
--    j = bitReverse ( j )
    copy_data ( j , x , 4 )
    println ( stdout , k:12 , j:12!h , j:34!b , x:18:6 )
--    x = sin ( PI * float ( k- 18) / 500.0 )
    waveformData [ 1 + ( k - 18 ) / 5 ] = x
    copy_data ( x , j , 4 )
    println ( stdout , k:12 , j:12!h , j:34!b , x:18:6 )
endfor
--     println ( stdout )
--     x = 25.0
--     x = sin ( PI * x / 500.0 )
--     copy_data ( x , j , 4 )
--     println ( stdout , k:12 , j:12!h , j:34!b , x:18:6 )
--     
--     getByte ( 3 , inAry )
--     talk cx to gpib address AWG520_ADDR with "MMEM:MSIS 'MAIN'"
-- 
--     talk cx to gpib address AWG520_ADDR with "MMEM:CAT?"
--     listen cx to gpib address AWG520_ADDR into str for 255 bytes
--     println (stdout , str )
--     str = "MMEM:DATA'sine1.wfm',"
-- --     j = len ( str )
-- --     for i = 1 to j do 
-- --         inAry [ i ] = word ( asc ( str [ i ] ) )
-- --     endfor
-- 
--     for i = 1 to 5 do
--        str= str + sprint ( "#4" , i!z:4 )
--     endfor
-- --    str = str + 
-- 
--      talk cx to gpib address AWG520_ADDR with "MMEM:OPEN 'sine1.wfm' "
-- 
--     talk cx to gpib address AWG520_ADDR with str
--     talk cx to gpib address AWG520_ADDR with "MMEM:CLOSE'sine1.wfm'"
--     talk cx to gpib address AWG520_ADDR with "MMEM:CAT?"
--     listen cx to gpib address AWG520_ADDR into str for 255 bytes
--     println (stdout , str )
--     for i = 1 to 5 do
--        str= sprint ( "#4" , i!z:4 )
--        for k = 1 to 6 do
--             j = j + 1
--             inAry [ j ] = word ( asc ( str [ k ] ) )
--        endfor
--     endfor
--     inAry [ j + 1 ] =  word ( asc ( "'" ) )
--     
-- --    talk cx to gpib address AWG520_ADDR with "MMEM:OPEN 'sine1.wfm'"
--     talk cx to gpib address AWG520_ADDR with bin inAry
-- 
--     talk cx to gpib address AWG520_ADDR with "MMEM:CAT?"
--     listen cx to gpib address AWG520_ADDR into str for 255 bytes
--     
--     for i = 1 to 24 do
--         print ( stdout , chr ( outAry [ i ] ) )
--     endfor
--     println ( stdout )

    str = "wfm"
    x = 100000000.0
    WriteAwg520WaveformFile ( str , waveformData [ 1 : 256 ] , inFrequency , i , awg520waveFileAry )
    
    
endbody
--------------------------------------------------------------------------------
function getByte ( byteNum , inAry ) : string [ 1 ]
--------------------------------------------------------------------------------
in integer              : byteNum
in word                 : inAry [ ? ]

local integer            : wordNum
local string  [ 4 ]      : s
body

    wordNum = byteNum + 1 >> 1
    
    s [ 1 ] = chr ( inAry [ wordNum ] >> word ( 8 * ( byteNum & 1 ) & 255 ) )
     
    return ( s [ 1 ] )

endbody
--------------------------------------------------------------------------------
function bitReverse ( inInt ) : integer
----------------------------------------------------------------------
in_out integer      : inInt

local integer       : i , j

body

    j = i & 1
    for i = 1 to 31 do
        j = ( j << 1 ) + ( ( inInt >> i ) & 1 )
    endfor
    
    return ( j )

endbody
----------------------------------------------------------------------
procedure WriteAwg520WaveformFile ( wfmName , inAry , clockRate , byteCount , outAry)
--------------------------------------------------------------------------------
in string [ 255 ]           : wfmName
in_out float                : inAry [ ? ]
in double                   : clockRate
in_out integer              : byteCount
in_out word                 : outAry [ ? ]

const HEADER                = "MAGIC" + chr ( 16#20 ) + "1000" + chr ( 16#0d ) + chr ( 16#0a ) + chr ( 16#23 ) + "4"

local integer               : file1
local integer               : length
local integer               : i , j , k , byteNum
local string [ 255 ]        : s
local word                  : wFloat [ 2 ]
local integer               : iFloat
local integer               : byteOrder [ 4 ]

body

    byteOrder [ 1 ] = 2
    byteOrder [ 2 ] = 1
    byteOrder [ 4 ] = 3
    byteOrder [ 3 ] = 4

    outAry = 0
    s = HEADER
    for  i = 1 to len ( s ) do
        writeByte ( i , s [ i ] , outAry )
    endfor
    byteNum = i

    length = dimsize ( inAry , 1 )
    s = sprint ( 5 * length:1 )
    k = len ( s )   
    for i = byteNum to byteNum + k - 1 do
        writeByte ( i , s [ i - byteNum + 1 ] , outAry )
    endfor
    byteNum = i 
    s [ 1 ] = chr ( 16#3 )
    for k = 1 to length do
        copy_data ( inAry [ k ] , wFloat [ 1 ] , 4 )
        for i = 1 to 4 do
             writeByte ( byteNum + i - 1 , getByte ( byteOrder [ i ] , wFloat )  , outAry )
          --   writeByte ( byteNum + i - 1 , chr ( 16#0 ) , outAry )
        endfor
        byteNum = byteNum + 4
        writeByte ( byteNum , s [ 1 ] , outAry )
        s = chr ( 16#0 )
        byteNum = byteNum + 1
    endfor
    s = sprint ( clockRate:8:9 )
    i = len ( s )
    for j = 1 to i do
        writeByte ( byteNum , s [ j ] , outAry )
        byteNum = byteNum + 1
    endfor
    writeByte ( byteNum , chr ( 16#0d ) , outAry )
    byteNum = byteNum + 1
    writeByte ( byteNum , chr ( 16#0a ) , outAry )
    
    open ( file1 , "/opt/ltx_nic/tp/" + wfmName + ".wfm" , "w" )
        write ( file1 , outAry [ 1 : byteNum ] )
    close ( file1 )
    
endbody
--------------------------------------------------------------------------------
procedure writeByte ( byteNum , s , wAry )
--------------------------------------------------------------------------------
in integer              : byteNum
in string [ 1 ]         : s
in_out word             : wAry [ ? ]

local integer           : wordNum
local string  [ 4 ]     : str
local word              : l , m , n
body

    wordNum = ( byteNum + 1 ) >> 1
    l = ( wAry [ wordNum ] & ( 255 << ( 8 * word ( 1 - ( byteNum & 1 ) ) ) ) ) 
    m = ( word ( asc ( s ) ) & 255 ) * 2 ^ ( 8 * ( word ( byteNum & 1 ) ) ) 
    n = l | m
    wAry [ wordNum ] = n
    
endbody
--------------------------------------------------------------------------------
procedure SetGtoDataOutputLevel(GTO_S_Chans,TxOutLevel,TxConnection,forceHighRange)
------------------------------------------------------------------------------------------------
in pin list[MAX_GTOS] : GTO_S_Chans     -- Selected VXGTO-S Channels           
in float               : TxOutLevel     -- Programmed VXGTO-S TX output level
in integer             : TxConnection   --  GTO Front End TX output connection mode  -- Enter BALANCED for Differential,SE_PLUS for non-inverting output, or SE_MINUS for the inverting output
in boolean             : forceHighRange
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- This procedure starts the VXGTO TX output to transmit the specified pattern at the specified
-- output level and mode.
------------------------------------------------------------------------------------------------
local
  word list[MAX_DIGHS] : GtoPins
end_local
body

    GtoPins = vxgto_ptc(GTO_S_Chans)

    GTB_SetSourceLevel (GtoPins ,TxConnection ,TxOutLevel, forceHighRange )
    
    if TxOutLevel >= 1.0 then
        GTB_SelectSourceMUXPath ( <: 1 :> , <: 1 :> ) -- ****CJH 05/11/06 TEMPORARY FIX!!!
    end_if
    
   wait(1.0ms)   


end_body
------------------------------------------------------------------------------------------------
procedure CharacterizeJitterTolLoop(GTO_S_Chans,SampDighsPins,DataRate,DifInputLevel,DifInputScale,SourceClock,ModulateClock, DutClockFreq,SamplerConnection,GTO_SrcPath,BertTime,BerTest,Vcc,Minor_id,CommentData)
--------------------------------------------------------------------------------
 in pin list[MAX_GTOS]  : GTO_S_Chans                  -- Selected VXGTO-S Channels           
 in pin list[MAX_DIGHS] : SampDighsPins                -- Selected DIGHS Channels                
 in double              : DataRate                     -- Data Rate of Transmitted data
 in float               : DifInputLevel                -- Start amplitude for DifInput
 in float               : DifInputScale                -- VCGTO-S output to DUT input ratio
 in integer             : SourceClock                  -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
 in integer             : ModulateClock                -- Selected Clock to Apply Jitter Enter JIT_CLK for Jitter Clock, AUX_CLK for reference (Aux) Clock, or SAMP_CLK for Sampler Clock
 in double              : DutClockFreq                 -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock
 in multisite integer   : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in integer              : GTO_SrcPath                  -- Select GTB_SRC if not using custom user source path, otherwise
                                                       -- select 1 of 3 custom user paths with GTB_SRC_USER1,GTB_SRC_USER2 or GTB_SRC_USER3
in float                : BertTime                     -- Time interval for Bit Error Rate Testend_local
in float                : BerTest  
in float                : Vcc                                                    
in integer              : Minor_id                     --  Minor test ID Number
in string[32]           : CommentData
local
    string[32]          : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
    float               : DiffLevel                    -- Differential VXGTO-S output level used during injected jitter testing
    float               : JitTone[1]                   -- Array of Injected Jitter Tone Frequencies  -- Maximum size set to 3 Tones
    float               : JitToneAmpStart              -- Array of Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
    float               : JitToneAmpStop               -- Array of Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
    float               : StepSize[1]                  -- Step size in characterization
    float               : JitToneScale                               -- Scaled injected jitter tone amplitudes for calibration
    multisite  float    : JitToneMeas[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Measured jitter tone amplitudes
    string[32]          : JitPatName                                 -- A string identifier for selected Injected Sinusoidal Jitter Tones
    string[32]          : CalPatName 
    float               : FreqBinSize                                -- Frequency Bin Size in jitter injection spectrum 
    float               : AWG_FiltFreq                               -- Reconstruction Filter Selection also used for sampling rate selection.
    float               : MeasLevelMax = 249mV                       -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
    float               : MeasurementScale = 2.0 
    integer             : CalBPW                    
    integer             : i,j,k
    float               : MaxFreq                                    -- Highest frequency injected jitter tone
    float               : JitAmp[1]
    float               : JitAmpScaled[1]
    integer             : TxConnection = BALANCED
    multisite double    : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysisend_local 
   multisite boolean    : SyncFail[MAX_GTOS]
   integer              : ChanPtr
   integer              : PortCount
   multisite double     : TotalCount[MAX_GTOS]
   double               : BerAry[800]
   double               : BerMax 
    multisite double    : BitErrorRate [MAX_GTOS]    -- Measured Bit Error Rate
   integer              : GtoRxClockMode = JIT_CLK   -- Select JIT_CLK for JitGtoRxClockModeter Clock (Bit Clock, TX_ODD_WORD, TX_EVEN_WORD
   double               : BERvsJit[400]
   double               : hi_lim
   double               : low_lim
   integer              : p,m,n
   integer              : mu
   boolean              : has_failed
   float                : JitTol[P,M,N]
   string[40]           : JitTolDispStr[P,M,N]
end_local
const
  P=3   -- Number of frequencies
  M=3   -- Number of patterns
  N=1   -- Number of levels
end_const
body

DataviewerCharText = true

SetJitterClkLevel( 3.0 )
JitToneAmpStop = 8.0

for p = 1 to P do
    if p = 1 then 
        JitTone = 0.4MHz
        JitToneAmpStart = 2.0
        StepSize = 0.02
    elseif p = 2 then
        JitTone = 4.0MHz
        JitToneAmpStart = 0.34
        StepSize = 0.01
    else
        JitTone = 52.0MHz
        JitToneAmpStart = 0.34
        StepSize = 0.01
    endif
for m = M to M do

    if m = 1 then 
        DataPatName = "prbs7"
    elseif m = 2 then 
        DataPatName = "prbs23"
    else
        DataPatName = "prbs31"
    endif
for n = 1 to 1 do
has_failed = false
    JitAmp = JitToneAmpStart 

    DiffLevel = DifInputLevel + float(n-1)*100mV
--     if n = 1 then
--         DiffLevel = 100mv
--     else_if n = 2 then
--         DiffLevel = 200mv
--     else_if n = 3 then
--         DiffLevel = 300mv
--     else_if n = 4 then
--         DiffLevel = 399.9mv
--     else_if n = 5 then
--         DiffLevel = 500mv
--     else_if n = 6 then
--         DiffLevel = 600mv
--     else_if n = 7 then
--         DiffLevel = 700mv
--     else_if n = 8 then
--         DiffLevel = 800mv
--     else_if n = 9 then
--         DiffLevel = 900mv
--     else
--         DiffLevel = 1000mv
--     endif
    
    hi_lim  =  double(BerTest)
    low_lim =  0.0
    if Minor_id > 1000000 then
        Minor_id = 0
    end_if
    BerMax = double(BerTest)
    FullSpectrum = true
    JitPatName = "Characterization"
    if JitToneAmpStart < 0.7 then
        CalPatName = "HalfRate"
        CalBPW = 2
    else_if JitToneAmpStart < 1.4 then
        CalPatName = "QuarterRate"
        CalBPW = 4
    else_if JitToneAmpStart < 2.8 then
        CalPatName = "EighthRate"
        CalBPW = 8
    else
        CalPatName = "SixteenthRate"
        CalBPW = 16
    end_if
    
    SelectGtoSrcClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq) 
    
    GenerateJitterTones(JitPatName,JitTone,JitAmp,AWG_FiltFreq) 
    StartJitterModulation(JitPatName,ModulateClock,AWG_FiltFreq)

    if (GTO_SrcPath < GTB_SRC_USER1) or (GTO_SrcPath > GTB_SRC_USER3) then
        StartGtoDataOutput(GTO_S_Chans,CalPatName,DiffLevel*DifInputScale,TxConnection,GTB_NORMAL_SOURCE_RANGING)
    else
        StartUserSrcOutput(GTO_S_Chans,CalPatName,DiffLevel*DifInputScale,TxConnection,GTO_SrcPath)
    end_if
    
    MaxFreq = 0.0
    if MaxFreq < JitTone[1] then 
        MaxFreq = JitTone[1]
    endif

    SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,CalBPW,MeasLevelMax,MaxFreq * 2.0)
    wait(100.0ms)
    JitterToneMeasurements(SampDighsPins,CalBPW,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)

    --***** Adjust Tone Gain **********
    if JitTone[1] < 50.0MHz then  -- Can't cal above 50MHz
        JitToneScale = JitAmp[1]/(JitToneMeas[1,1] * float(DataRate)) 
    else
        JitToneScale = 1.0
    endif

    j = 0 
    k = 0
    BitErrorRate = 0.0

    if DataviewerCharText then
        println(stdout,"VCC                    ",Vcc:4:3!u=V)
        println(stdout,"Data Rate              ",DataRate:10:8!u=GHz)
        println(stdout,"Diff Input Level       ",DiffLevel:5:3!U=V)
        println(stdout,"Data Pattern           ",DataPatName)
        if JitTone[1] < 1.0e6 then
            println(stdout,"Jitter Tone Frequency  ",JitTone[1]:4:2!u=KHz)
        else
            println(stdout,"Jitter Tone Frequency  ",JitTone[1]:4:2!u=MHz)
        end_if
        println(stdout,"Test Bit Error Rate   ",BerTest) 
        if GTO_SrcPath = GTB_SRC_USER1 then
            println(stdout,"GTO Source path        GTB_SRC_USER1 (3inch FR4)")
        else_if GTO_SrcPath = GTB_SRC_USER2 then
            println(stdout,"GTO Source path        GTB_SRC_USER2 (10inch FR4)")
        else_if GTO_SrcPath = GTB_SRC_USER3 then
            println(stdout,"GTO Source path        GTB_SRC_USER3 (15inch FR4)")
        end_if
        println(stdout," ")
        println (stdout,"JItter Magnitude      Bit Error Rate " )
    endif
    
    mu = 8
    k = 0
    while (JitAmp < JitToneAmpStop) and (k< 3) do  
        j = j + 1 * mu
        JitAmp = (JitToneAmpStart + StepSize[1] * float(j-mu))
        JitAmpScaled = JitAmp * JitToneScale
        GenerateJitterTones(JitPatName,JitTone,JitAmpScaled,AWG_FiltFreq)  
        set vx_gto GTO_S_Chans output bit rate frequency to DataRate   
        set vx_gto GTO_S_Chans output clock mode to jitter_clk
        EnableJitterClk("on",DataRate)      
        StartJitterModulation(JitPatName,JIT_CLK,AWG_FiltFreq)
        SetJitterClkModulation("iq")
    
        if (GTO_SrcPath < GTB_SRC_USER1) or (GTO_SrcPath > GTB_SRC_USER3) then
            StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel*DifInputScale,TxConnection,GTB_NORMAL_SOURCE_RANGING)
        else
            StartUserSrcOutput(GTO_S_Chans,DataPatName,DiffLevel*DifInputScale,TxConnection,GTO_SrcPath)
        end_if

        PortCount  = len(GTO_S_Chans)
        i = 0
        BitErrorRate = 1.0
        while (i < 1) and (BitErrorRate > BerMax) do
            i = i + 1 
            stop vx_gto GTO_S_Chans input 
            set vx_gto GTO_S_Chans input bit rate frequency to DataRate
            if GtoRxClockMode = JIT_CLK then
                set vx_gto GTO_S_Chans input clock mode to jitter_clk
            else_if GtoRxClockMode = TX_ODD_WORD then
             set vx_gto GTO_S_Chans input clock mode to word_clk from tx1
            else_if GtoRxClockMode = TX_EVEN_WORD then
                set vx_gto GTO_S_Chans input clock mode to word_clk from tx2
            end_if

            wait(100mS)

            if DataPatName = "prbs7" then
                start vx_gto GTO_S_Chans input pattern prbs7 
            else_if DataPatName = "prbs15" then
                start vx_gto GTO_S_Chans input pattern prbs15 
            else_if DataPatName = "prbs23" then
                start vx_gto GTO_S_Chans input pattern prbs23 
            else_if DataPatName = "prbs31" then
                start vx_gto GTO_S_Chans input pattern prbs31 
            endif
            TotalCount = TotalCount * 32.0
     
            for ChanPtr = 1 to PortCount do  
                TotalCount[1,ChanPtr] = TotalCount[1,ChanPtr]
                BitErrorRate[1,ChanPtr] = BitErrorRate[1,ChanPtr]/TotalCount[1,ChanPtr]
            end_for
        end_while
         
        if BitErrorRate[1,1] > double(BerTest) then -- 0.25 then
            k = k + 1
        else_if BitErrorRate[1,1] <= double(BerTest) then -- 0.125 then
            k = 0
        end_if
        BERvsJit[j] = BitErrorRate[1,1]

        if DataviewerCharText then
            print (stdout,"      ",JitAmp:5:4,"@tUI P-P     @t",BitErrorRate[1,1])
        end_if

        if mu = 1 and BitErrorRate[1,1] > double(BerTest) and not(has_failed) then 
            if DataviewerCharText then
                println (stdout,"@t@t<------ first failure : test# ",100000000+((p-1)*6)+((m-1)*2)+n)
            end_if
            JitTol[p,m,n] = JitAmp[1]
            JitTolDispStr[p,m,n] = sprint(JitTone:10:2,DataPatName:10,DiffLevel:10:4,JitTol[p,m,n]:10:4)
            has_failed = true
            test_value JitAmp lo 0.0 hi 10.0 units "BER" pins GTO_S_Chans  test 100000000+((p-1)*30)+((m-1)*10)+n  comment  sprint(JitTone[1]:4:2!u=KHz)+" "+sprint(DiffLevel:5:1!U=mV)+ " at "+sprint(DataRate/1.0e9:5)+"GB/s First Failure"
        else
            if DataviewerCharText then
                println (stdout,"")
            end_if
        end_if

        if mu = 8 and   BERvsJit[j]  > 0.0 then
            j = j - 2 * mu
            if j < 0 then
                j = 0
            endif
            mu = 1
        else 

            Minor_id = Minor_id + 1
            if JitTone[1] < 1.0e6 then
                test_value BitErrorRate[1,1] lo low_lim hi hi_lim units "BER" pins GTO_S_Chans  test Minor_id  comment  sprint(JitTone[1]:4:2!u=KHz)+" "+sprint(JitAmp[1]:4:2)+"UI SJ "+sprint(DiffLevel:5:1!U=mV)+ " at "+sprint(DataRate/1.0e9:5)+"GB/s "+CommentData
            else
                test_value BitErrorRate[1,1] lo low_lim hi hi_lim units "BER" pins GTO_S_Chans  test Minor_id  comment  sprint(JitTone[1]:4:2!u=MHz)+" "+sprint(JitAmp[1]:4:2)+"UI SJ "+sprint(DiffLevel:5:1!U=mV)+ " at "+sprint(DataRate/1.0e9:5)+"GB/s "+CommentData
            end_if
            if j mod 10 = 0 then
                wait(1ms) 
            end_if
        endif
    end_while
    if DataviewerCharText then
        println (stdout," ")
        println (stdout," ")
    end_if
endfor
endfor
endfor

if DataviewerCharText then
    for p = 1 to P do           -- freq
        for m = 1 to M do       -- pat
            for n = 1 to N do   -- level
                println(stdout,JitTolDispStr[p,m,n])
            endfor
        endfor
    endfor
end_if
  
endbody
--------------------------------------------------------------------------------

function amp_dB(amplitude) : float
--------------------------------------------------------------------------------
--  
 
in float : amplitude
 
local float : dB

body
 
    if( amplitude > 0.0 ) then
        dB = 20.0 * log( amplitude )
    else
        dB = -99999.99
    end_if

    return(dB)
    
end_body
procedure GenerateSpreadSpectrum(SpreadSpecName,ClkFreq,ModulateClock,ModFreq,SpreadPercent,FreqOffset)
----------------------------------------------------------------------------- 
in string[32] : SpreadSpecName  -- Module name for modulation patterns
in double     : ClkFreq         -- Nominal frequency of clock being generated.
in integer    : ModulateClock   -- Enter JIT_CLK for Jitter Clock or AUX_CLK for Auxiliary Clock
in double     : ModFreq         -- Sawtooth Modulation Frequency. Typically 30KHz or in 20KHz to 40KHz range 
in float      : SpreadPercent   -- Percentage of Spectrum to spread (100 X (MaxFreq -MinFreq)/ClkFreq)
out double    : FreqOffset      -- Full Spectrum Clock Frequency Offset

----------------------------------------------------------------------------- 
----------------------------------------------------------------------------- 
-- This procecdure creates the waveforms needed for the AWGHS or AWGHSB
-- The waveforms are identified by the input string identifier, 
-- which can later be used to modulate the selected 
-- clock with the specified Spread Spectrum.  For Downspreading use the
-- the MaxFreq for the ClkFreq. 
----------------------------------------------------------------------------- 
local
    integer    : i,j
    float      : PhaseAry[AWGHSB_SS_SAMPLES]
    float      : ToneAry[AWGHSB_SS_SAMPLES]
    float      : InitPolarSpreadSpecCos[AWGHSB_SS_SAMPLES*2]
    float      : InitPolarSpreadSpecSin[AWGHSB_SS_SAMPLES*2]
    float      : CartesianArray[AWGHSB_SS_SAMPLES*2]
    float      : SinInitWave[AWGHSB_SS_SAMPLES]
    float      : CosInitWave[AWGHSB_SS_SAMPLES]
    float      : CorrectionAry[AWGHSB_SS_SAMPLES]
    float      : XtrmAry[4]
    float      : phase
    float      : dt
    float      : PhaseShift
    float      : CorrectionSinx_x 
    float      : maxVolts = 1.0V
    double     : Tone
    double     : DeltaT
    double     : AwgClkFreq
    double     : Harmonic
    double     : samples
    double     : RampTone
    double     : RampIntervals
    double     : SpreadClkFreq
    double     : DeltaScale 
end_local
static  float  : Sinx_xAry[AWGHSB_SS_SAMPLES]

const     Pi   = 3.14159265359

body

DeltaScale    = double(SpreadPercent)*0.01 
SpreadClkFreq = ClkFreq * DeltaScale
samples       = double(AWGHSB_SS_SAMPLES)
if use_awghsb then 
   AwgClkFreq = AWGHSB_SS_SAMPLING_FREQ
else
   AwgClkFreq = AWGHSB_SS_SAMPLING_FREQ/2.0
end_if
RampIntervals = double(integer(ModFreq/(AwgClkFreq/samples)+ 0.984))
AwgClkFreq    = ModFreq/RampIntervals*samples
Harmonic      = double(integer(SpreadClkFreq/(AwgClkFreq/samples)))
 dt           = float(1.0/AwgClkFreq) 
 Tone         = AwgClkFreq/samples*Harmonic
 DeltaT       = 2.0*Tone*RampIntervals/samples
 phase        = 0.0
FreqOffset    = Tone/2.0

for i = 1 to AWGHSB_SS_SAMPLES do
     RampTone = DeltaT * double(i) 
     while RampTone > (2.0*Tone) do
         RampTone = RampTone - (2.0* Tone)
     end_While
     if RampTone > Tone then
         RampTone = (2.0* Tone) - RampTone
     end_if
     ToneAry[i] =  float(Tone/2.0 - RampTone)
     phase = phase + 2.0*Pi*ToneAry[i] * dt 
     PhaseShift  = Pi/4.0 
     PhaseAry[i] = phase + PhaseShift 
end_for


for i = 1 to AWGHSB_SS_SAMPLES do
   PhaseAry[i] = PhaseAry[i] * 180.0/Pi
   InitPolarSpreadSpecCos[2*i] = PhaseAry[i]
   InitPolarSpreadSpecCos[2*i-1] = 1.0
end_for


    CartesianArray = polar_to_cartesian(InitPolarSpreadSpecCos)
    
    for i = 1 to AWGHSB_SS_SAMPLES do
        CosInitWave[i] =   CartesianArray[2*i-1]
        SinInitWave[i] =   CartesianArray[2*i]
    end_for



    if Sinx_xAry[1] <> 1.0 then
        Sinx_xAry = 0.0
        for i = 1 to AWGHSB_SS_SAMPLES/2 - 1 do
            CorrectionSinx_x  = Pi*float(i)/float(AWGHSB_SS_SAMPLES)/sin(Pi*float(i)/float(AWGHSB_SS_SAMPLES))
            Sinx_xAry[2*i]    = CorrectionSinx_x
            Sinx_xAry[2*i+ 1] = CorrectionSinx_x
        end_for
        Sinx_xAry[1] = 1.0
    end_if

    CorrectionAry = fft(CosInitWave)
    CorrectionAry = CorrectionAry * Sinx_xAry
    CosInitWave   = inverse_fft(CorrectionAry)
    XtrmAry       = xtrm(CosInitWave)    
    CorrectionAry = fft(SinInitWave)
    CorrectionAry = CorrectionAry * Sinx_xAry
    SinInitWave   = inverse_fft(CorrectionAry)
    if abs(XtrmAry[3]) > XtrmAry[1] then
	XtrmAry[1] = abs(XtrmAry[3])
    end_if
    if XtrmAry[1] > maxVolts then
        CosInitWave = (maxVolts/XtrmAry[1]) * CosInitWave * 0.9999
        SinInitWave = (maxVolts/XtrmAry[1]) * SinInitWave * 0.9999
    end_if  
    i = 1
    while  (JitterName[i] <> SpreadSpecName) and (i <= MAX_NO_OF_JITTER_NAMES) do
        if JitterName[i] = "" then  
            JitterName[i] = SpreadSpecName          
        else
            i = i + 1
       end_if
    end_while

    if use_awghsb then   
        load  awghsb AWGHSB_I_CHAN pattern SpreadSpecName  with CosInitWave 
        load  awghsb AWGHSB_Q_CHAN pattern SpreadSpecName  with SinInitWave
        set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> sample rate to AwgClkFreq 
        set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> clock to internal 
    else
        set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> sample rate to AwgClkFreq 
        if ModulateClock <> JIT_CLK then
           CosInitWave = CosInitWave/2.0
           SinInitWave = SinInitWave/2.0
        end_if
        load  awghs chan AWGHS_I_CHAN pattern SpreadSpecName  with CosInitWave
        load  awghs chan AWGHS_Q_CHAN pattern SpreadSpecName  with SinInitWave
    end_if       

    if SpreadSpecGenPass1 then
        set_expr(SpreadSpecName + "_Offset.Meas",FreqOffset)
        if ClkFreq < 1.0GHz then 
            println(stdout,"Generating ",SpreadPercent:8:4," Percent Spread Spectrum at Clock Frequency  ",ClkFreq:10:4!u=MHz," Modulation Frequency ",ModFreq:8:4!u=KHz)
        else
            println(stdout,"Generating ",SpreadPercent:8:4," Percent Spread Spectrum at Clock Frequency  ",ClkFreq:9:4!u=GHz," Modulation Frequency ",ModFreq:8:4!u=KHz)
        end_if
    
        if FreqOffset < 1.0MHz then 
            println(stdout,"Spread Spectrum Clock Frequency Offset = ",FreqOffset:8:4!u=KHz)
        else
            println(stdout," Spread Spectrum Clock Frequency Offset = ",FreqOffset:8:4!u=MHz)
        end_if
    end_if
      
end_body

procedure Make4BitPrbs7InvPattern
----------------------------------------------------------------------------------------------
--  This procedure loads an lword array named prbs_7_4bit_pattern with 508 lwords of data, 
--  which is 16256 bits.  The intent of this array is to provide a PRBS2^7-1 inverted pattern at with
--  4 X data rate clocking. 
----------------------------------------------------------------------------------------------
body
awrite(prbs_7Inv_4bit_pattern[1:4],16#000f000f,16#f00ff0f0,16#f0f00000,16#00ffffff)
awrite(prbs_7Inv_4bit_pattern[5:8],16#0fffff00,16#ffff0f0f,16#ff0000ff,16#0fff0f00)
awrite(prbs_7Inv_4bit_pattern[9:12],16#ff000f0f,16#0ff00000,16#f0ffff00,16#0fff0ff0)
awrite(prbs_7Inv_4bit_pattern[13:16],16#ff00f00f,16#0f00f000,16#0f00fff0,16#0f0ff0f0)
awrite(prbs_7Inv_4bit_pattern[17:21],16#00f000ff,16#00ff0f0f,16#0f000000,16#0ffffff0)
awrite(prbs_7Inv_4bit_pattern[21:24],16#fffff00f,16#fff0f0ff,16#f0000ff0,16#fff0f00f)
awrite(prbs_7Inv_4bit_pattern[25:28],16#f000f0f0,16#ff00000f,16#0ffff000,16#fff0ff0f)
awrite(prbs_7Inv_4bit_pattern[29:32],16#f00f00f0,16#f00f0000,16#f00fff00,16#f0ff0f00)
awrite(prbs_7Inv_4bit_pattern[33:36],16#0f000ff0,16#0ff0f0f0,16#f0000000,16#ffffff0f)
awrite(prbs_7Inv_4bit_pattern[37:40],16#ffff00ff,16#ff0f0fff,16#0000ff0f,16#ff0f00ff)
awrite(prbs_7Inv_4bit_pattern[41:44],16#000f0f0f,16#f00000f0,16#ffff000f,16#ff0ff0ff)
awrite(prbs_7Inv_4bit_pattern[45:48],16#00f00f0f,16#00f0000f,16#00fff00f,16#0ff0f000)
awrite(prbs_7Inv_4bit_pattern[49:52],16#f000ff00,16#ff0f0f0f,16#0000000f,16#fffff0ff)
awrite(prbs_7Inv_4bit_pattern[53:56],16#fff00fff,16#f0f0fff0,16#000ff0ff,16#f0f00ff0)
awrite(prbs_7Inv_4bit_pattern[57:61],16#00f0f0ff,16#00000f0f,16#fff000ff,16#f0ff0ff0)
awrite(prbs_7Inv_4bit_pattern[61:64],16#0f00f0f0,16#0f0000f0,16#0fff00f0,16#ff0f000f)
awrite(prbs_7Inv_4bit_pattern[65:68],16#000ff00f,16#f0f0f0f0,16#000000ff,16#ffff0fff)
awrite(prbs_7Inv_4bit_pattern[69:72],16#ff00ffff,16#0f0fff00,16#00ff0fff,16#0f00ff00)
awrite(prbs_7Inv_4bit_pattern[73:76],16#0f0f0ff0,16#0000f0ff,16#ff000fff,16#0ff0ff00)
awrite(prbs_7Inv_4bit_pattern[77:81],16#f00f0f00,16#f0000f00,16#fff00f0f,16#f0f000f0)
awrite(prbs_7Inv_4bit_pattern[81:84],16#00ff00ff,16#0f0f0f00,16#00000fff,16#fff0ffff)
awrite(prbs_7Inv_4bit_pattern[85:88],16#f00ffff0,16#f0fff000,16#0ff0fff0,16#f00ff000)
awrite(prbs_7Inv_4bit_pattern[89:92],16#f0f0ff00,16#000f0fff,16#f000fff0,16#ff0ff00f)
awrite(prbs_7Inv_4bit_pattern[93:96],16#00f0f00f,16#0000f00f,16#ff00f0ff,16#0f000f00)
awrite(prbs_7Inv_4bit_pattern[97:100],16#0ff00ff0,16#f0f0f000,16#0000ffff,16#ff0fffff)
awrite(prbs_7Inv_4bit_pattern[101:104],16#00ffff0f,16#0fff0000,16#ff0fff0f,16#00ff000f)
awrite(prbs_7Inv_4bit_pattern[105:108],16#0f0ff000,16#00f0ffff,16#000fff0f,16#f0ff00f0)
awrite(prbs_7Inv_4bit_pattern[109:112],16#0f0f00f0,16#000f00ff,16#f00f0ff0,16#f000f000)
awrite(prbs_7Inv_4bit_pattern[113:116],16#ff00ff0f,16#0f0f0000,16#000fffff,16#f0fffff0)
awrite(prbs_7Inv_4bit_pattern[117:120],16#0ffff0f0,16#fff0000f,16#f0fff0f0,16#0ff000f0)
awrite(prbs_7Inv_4bit_pattern[121:124],16#f0ff0000,16#0f0ffff0,16#00fff0ff,16#0ff00f00)
awrite(prbs_7Inv_4bit_pattern[125:127],16#f0f00f00,16#00f00fff,16#00f0ff0f)
prbs_7Inv_4bit_pattern[128:254] = prbs_7Inv_4bit_pattern[1:127]
prbs_7Inv_4bit_pattern[255:508] = prbs_7Inv_4bit_pattern[1:254]
end_body

procedure Make2BitPrbs7InvPattern
----------------------------------------------------------------------------------------------
--  This procedure loads an lword array named prbs_7Inv_2bit_pattern with 508 lwords of data, 
--  which is 16256 bits.  The intent of this array is to provide a PRBS2^7-1 inverted pattern at with
--  double data rate clocking. 
----------------------------------------------------------------------------------------------
body

awrite(prbs_7Inv_2bit_pattern[1:8],16#0303c3cc,16#cc000fff,16#3ff0ff33,16#f00f3f30,16#f0333c00,16#cff03f3c,16#f0c330c0,16#30fc33cc)
awrite(prbs_7Inv_2bit_pattern[9:16],16#0c0f0f33,16#30003ffc,16#ffc3fccf,16#c03cfcc3,16#c0ccf003,16#3fc0fcf3,16#c30cc300,16#c3f0cf30)
awrite(prbs_7Inv_2bit_pattern[17:24],16#303c3ccc,16#c000fff3,16#ff0ff33f,16#00f3f30f,16#0333c00c,16#ff03f3cf,16#0c330c03,16#0fc33cc0)
awrite(prbs_7Inv_2bit_pattern[25:32],16#c0f0f333,16#0003ffcf,16#fc3fccfc,16#03cfcc3c,16#0ccf0033,16#fc0fcf3c,16#30cc300c,16#3f0cf303)
awrite(prbs_7Inv_2bit_pattern[33:40],16#03c3cccc,16#000fff3f,16#f0ff33f0,16#0f3f30f0,16#333c00cf,16#f03f3cf0,16#c330c030,16#fc33cc0c)
awrite(prbs_7Inv_2bit_pattern[41:48],16#0f0f3330,16#003ffcff,16#c3fccfc0,16#3cfcc3c0,16#ccf0033f,16#c0fcf3c3,16#0cc300c3,16#f0cf3030)
awrite(prbs_7Inv_2bit_pattern[49:56],16#3c3cccc0,16#00fff3ff,16#0ff33f00,16#f3f30f03,16#33c00cff,16#03f3cf0c,16#330c030f,16#c33cc0c0)
awrite(prbs_7Inv_2bit_pattern[57:64],16#f0f33300,16#03ffcffc,16#3fccfc03,16#cfcc3c0c,16#cf0033fc,16#0fcf3c30,16#cc300c3f,16#0cf30303)
awrite(prbs_7Inv_2bit_pattern[65:72],16#c3cccc00,16#0fff3ff0,16#ff33f00f,16#3f30f033,16#3c00cff0,16#3f3cf0c3,16#30c030fc,16#33cc0c0f)
awrite(prbs_7Inv_2bit_pattern[73:80],16#0f333000,16#3ffcffc3,16#fccfc03c,16#fcc3c0cc,16#f0033fc0,16#fcf3c30c,16#c300c3f0,16#cf30303c)
awrite(prbs_7Inv_2bit_pattern[81:88],16#3cccc000,16#fff3ff0f,16#f33f00f3,16#f30f0333,16#c00cff03,16#f3cf0c33,16#0c030fc3,16#3cc0c0f0)
awrite(prbs_7Inv_2bit_pattern[89:96],16#f3330003,16#ffcffc3f,16#ccfc03cf,16#cc3c0ccf,16#0033fc0f,16#cf3c30cc,16#300c3f0c,16#f30303c3)
awrite(prbs_7Inv_2bit_pattern[97:104],16#cccc000f,16#ff3ff0ff,16#33f00f3f,16#30f0333c,16#00cff03f,16#3cf0c330,16#c030fc33,16#cc0c0f0f)
awrite(prbs_7Inv_2bit_pattern[105:112],16#3330003f,16#fcffc3fc,16#cfc03cfc,16#c3c0ccf0,16#033fc0fc,16#f3c30cc3,16#00c3f0cf,16#30303c3c)
awrite(prbs_7Inv_2bit_pattern[113:120],16#ccc000ff,16#f3ff0ff3,16#3f00f3f3,16#0f0333c0,16#0cff03f3,16#cf0c330c,16#030fc33c,16#c0c0f0f3)
awrite(prbs_7Inv_2bit_pattern[121: 128],16#330003ff,16#cffc3fcc,16#fc03cfcc,16#3c0ccf00,16#33fc0fcf,16#3c30cc30,16#0c3f0cf3,16#0303c3cc)
awrite(prbs_7Inv_2bit_pattern[129:136],16#cc000fff,16#3ff0ff33,16#f00f3f30,16#f0333c00,16#cff03f3c,16#f0c330c0,16#30fc33cc,16#0c0f0f33)
awrite(prbs_7Inv_2bit_pattern[137:144],16#30003ffc,16#ffc3fccf,16#c03cfcc3,16#c0ccf003,16#3fc0fcf3,16#c30cc300,16#c3f0cf30,16#303c3ccc)
awrite(prbs_7Inv_2bit_pattern[145:152],16#c000fff3,16#ff0ff33f,16#00f3f30f,16#0333c00c,16#ff03f3cf,16#0c330c03,16#0fc33cc0,16#c0f0f333)
awrite(prbs_7Inv_2bit_pattern[153:160],16#0003ffcf,16#fc3fccfc,16#03cfcc3c,16#0ccf0033,16#fc0fcf3c,16#30cc300c,16#3f0cf303,16#03c3cccc)
awrite(prbs_7Inv_2bit_pattern[161:168],16#000fff3f,16#f0ff33f0,16#0f3f30f0,16#333c00cf,16#f03f3cf0,16#c330c030,16#fc33cc0c,16#0f0f3330)
awrite(prbs_7Inv_2bit_pattern[169:176],16#003ffcff,16#c3fccfc0,16#3cfcc3c0,16#ccf0033f,16#c0fcf3c3,16#0cc300c3,16#f0cf3030,16#3c3cccc0)
awrite(prbs_7Inv_2bit_pattern[177:184],16#00fff3ff,16#0ff33f00,16#f3f30f03,16#33c00cff,16#03f3cf0c,16#330c030f,16#c33cc0c0,16#f0f33300)
awrite(prbs_7Inv_2bit_pattern[185:192],16#03ffcffc,16#3fccfc03,16#cfcc3c0c,16#cf0033fc,16#0fcf3c30,16#cc300c3f,16#0cf30303,16#c3cccc00)
awrite(prbs_7Inv_2bit_pattern[193:200],16#0fff3ff0,16#ff33f00f,16#3f30f033,16#3c00cff0,16#3f3cf0c3,16#30c030fc,16#33cc0c0f,16#0f333000)
awrite(prbs_7Inv_2bit_pattern[201:208],16#3ffcffc3,16#fccfc03c,16#fcc3c0cc,16#f0033fc0,16#fcf3c30c,16#c300c3f0,16#cf30303c,16#3cccc000)
awrite(prbs_7Inv_2bit_pattern[209:216],16#fff3ff0f,16#f33f00f3,16#f30f0333,16#c00cff03,16#f3cf0c33,16#0c030fc3,16#3cc0c0f0,16#f3330003)
awrite(prbs_7Inv_2bit_pattern[217:224],16#ffcffc3f,16#ccfc03cf,16#cc3c0ccf,16#0033fc0f,16#cf3c30cc,16#300c3f0c,16#f30303c3,16#cccc000f)
awrite(prbs_7Inv_2bit_pattern[225:232],16#ff3ff0ff,16#33f00f3f,16#30f0333c,16#00cff03f,16#3cf0c330,16#c030fc33,16#cc0c0f0f,16#3330003f)
awrite(prbs_7Inv_2bit_pattern[233:240],16#fcffc3fc,16#cfc03cfc,16#c3c0ccf0,16#033fc0fc,16#f3c30cc3,16#00c3f0cf,16#30303c3c,16#ccc000ff)
awrite(prbs_7Inv_2bit_pattern[241:248],16#f3ff0ff3,16#3f00f3f3,16#0f0333c0,16#0cff03f3,16#cf0c330c,16#030fc33c,16#c0c0f0f3,16#330003ff)
awrite(prbs_7Inv_2bit_pattern[249:254],16#cffc3fcc,16#fc03cfcc,16#3c0ccf00,16#33fc0fcf,16#3c30cc30,16#0c3f0cf3)

prbs_7Inv_2bit_pattern[255:508] = prbs_7Inv_2bit_pattern[1:254]

end_body

procedure Make2BitPrbs7Pattern
----------------------------------------------------------------------------------------------
--  This procedure loads an lword array named prbs_7_2bit_pattern with 508 lwords of data, 
--  which is 16256 bits.  The intent of this array is to provide a PRBS2^7-1 pattern at with
--  double data rate clocking. 
----------------------------------------------------------------------------------------------
body

awrite(prbs_7_2bit_pattern[1:8],16#fcfc3c33,16#33fff000,16#c00f00cc,16#0ff0c0cf,16#0fccc3ff,16#300fc0c3,16#0f3ccf3f,16#cf03cc33)
awrite(prbs_7_2bit_pattern[9:16],16#f3f0f0cc,16#cfffc003,16#003c0330,16#3fc3033c,16#3f330ffc,16#c03f030c,16#3cf33cff,16#3c0f30cf)
awrite(prbs_7_2bit_pattern[17:24],16#cfc3c333,16#3fff000c,16#00f00cc0,16#ff0c0cf0,16#fccc3ff3,16#00fc0c30,16#f3ccf3fc,16#f03cc33f)
awrite(prbs_7_2bit_pattern[25:32],16#3f0f0ccc,16#fffc0030,16#03c03303,16#fc3033c3,16#f330ffcc,16#03f030c3,16#cf33cff3,16#c0f30cfc)
awrite(prbs_7_2bit_pattern[33:40],16#fc3c3333,16#fff000c0,16#0f00cc0f,16#f0c0cf0f,16#ccc3ff30,16#0fc0c30f,16#3ccf3fcf,16#03cc33f3)
awrite(prbs_7_2bit_pattern[41:48],16#f0f0cccf,16#ffc00300,16#3c03303f,16#c3033c3f,16#330ffcc0,16#3f030c3c,16#f33cff3c,16#0f30cfcf)
awrite(prbs_7_2bit_pattern[49:56],16#c3c3333f,16#ff000c00,16#f00cc0ff,16#0c0cf0fc,16#cc3ff300,16#fc0c30f3,16#ccf3fcf0,16#3cc33f3f)
awrite(prbs_7_2bit_pattern[57:64],16#0f0cccff,16#fc003003,16#c03303fc,16#3033c3f3,16#30ffcc03,16#f030c3cf,16#33cff3c0,16#f30cfcfc)
awrite(prbs_7_2bit_pattern[65:72],16#3c3333ff,16#f000c00f,16#00cc0ff0,16#c0cf0fcc,16#c3ff300f,16#c0c30f3c,16#cf3fcf03,16#cc33f3f0)
awrite(prbs_7_2bit_pattern[73:80],16#f0cccfff,16#c003003c,16#03303fc3,16#033c3f33,16#0ffcc03f,16#030c3cf3,16#3cff3c0f,16#30cfcfc3)
awrite(prbs_7_2bit_pattern[81:88],16#c3333fff,16#000c00f0,16#0cc0ff0c,16#0cf0fccc,16#3ff300fc,16#0c30f3cc,16#f3fcf03c,16#c33f3f0f)
awrite(prbs_7_2bit_pattern[89:96],16#0cccfffc,16#003003c0,16#3303fc30,16#33c3f330,16#ffcc03f0,16#30c3cf33,16#cff3c0f3,16#0cfcfc3c)
awrite(prbs_7_2bit_pattern[97:104],16#3333fff0,16#00c00f00,16#cc0ff0c0,16#cf0fccc3,16#ff300fc0,16#c30f3ccf,16#3fcf03cc,16#33f3f0f0)
awrite(prbs_7_2bit_pattern[105:112],16#cccfffc0,16#03003c03,16#303fc303,16#3c3f330f,16#fcc03f03,16#0c3cf33c,16#ff3c0f30,16#cfcfc3c3)
awrite(prbs_7_2bit_pattern[113:120],16#333fff00,16#0c00f00c,16#c0ff0c0c,16#f0fccc3f,16#f300fc0c,16#30f3ccf3,16#fcf03cc3,16#3f3f0f0c)
awrite(prbs_7_2bit_pattern[121:128],16#ccfffc00,16#3003c033,16#03fc3033,16#c3f330ff,16#cc03f030,16#c3cf33cf,16#f3c0f30c,16#fcfc3c33)
awrite(prbs_7_2bit_pattern[129:136],16#33fff000,16#c00f00cc,16#0ff0c0cf,16#0fccc3ff,16#300fc0c3,16#0f3ccf3f,16#cf03cc33,16#f3f0f0cc)
awrite(prbs_7_2bit_pattern[137:144],16#cfffc003,16#003c0330,16#3fc3033c,16#3f330ffc,16#c03f030c,16#3cf33cff,16#3c0f30cf,16#cfc3c333)
awrite(prbs_7_2bit_pattern[145:152],16#3fff000c,16#00f00cc0,16#ff0c0cf0,16#fccc3ff3,16#00fc0c30,16#f3ccf3fc,16#f03cc33f,16#3f0f0ccc)
awrite(prbs_7_2bit_pattern[153:160],16#fffc0030,16#03c03303,16#fc3033c3,16#f330ffcc,16#03f030c3,16#cf33cff3,16#c0f30cfc,16#fc3c3333)
awrite(prbs_7_2bit_pattern[161:168],16#fff000c0,16#0f00cc0f,16#f0c0cf0f,16#ccc3ff30,16#0fc0c30f,16#3ccf3fcf,16#03cc33f3,16#f0f0cccf)
awrite(prbs_7_2bit_pattern[169:176],16#ffc00300,16#3c03303f,16#c3033c3f,16#330ffcc0,16#3f030c3c,16#f33cff3c,16#0f30cfcf,16#c3c3333f)
awrite(prbs_7_2bit_pattern[177:184],16#ff000c00,16#f00cc0ff,16#0c0cf0fc,16#cc3ff300,16#fc0c30f3,16#ccf3fcf0,16#3cc33f3f,16#0f0cccff)
awrite(prbs_7_2bit_pattern[185:192],16#fc003003,16#c03303fc,16#3033c3f3,16#30ffcc03,16#f030c3cf,16#33cff3c0,16#f30cfcfc,16#3c3333ff)
awrite(prbs_7_2bit_pattern[193:200],16#f000c00f,16#00cc0ff0,16#c0cf0fcc,16#c3ff300f,16#c0c30f3c,16#cf3fcf03,16#cc33f3f0,16#f0cccfff)
awrite(prbs_7_2bit_pattern[201:208],16#c003003c,16#03303fc3,16#033c3f33,16#0ffcc03f,16#030c3cf3,16#3cff3c0f,16#30cfcfc3,16#c3333fff)
awrite(prbs_7_2bit_pattern[209:216],16#000c00f0,16#0cc0ff0c,16#0cf0fccc,16#3ff300fc,16#0c30f3cc,16#f3fcf03c,16#c33f3f0f,16#0cccfffc)
awrite(prbs_7_2bit_pattern[217:224],16#003003c0,16#3303fc30,16#33c3f330,16#ffcc03f0,16#30c3cf33,16#cff3c0f3,16#0cfcfc3c,16#3333fff0)
awrite(prbs_7_2bit_pattern[225:232],16#00c00f00,16#cc0ff0c0,16#cf0fccc3,16#ff300fc0,16#c30f3ccf,16#3fcf03cc,16#33f3f0f0,16#cccfffc0)
awrite(prbs_7_2bit_pattern[233:240],16#03003c03,16#303fc303,16#3c3f330f,16#fcc03f03,16#0c3cf33c,16#ff3c0f30,16#cfcfc3c3,16#333fff00)
awrite(prbs_7_2bit_pattern[241:248],16#0c00f00c,16#c0ff0c0c,16#f0fccc3f,16#f300fc0c,16#30f3ccf3,16#fcf03cc3,16#3f3f0f0c,16#ccfffc00)
awrite(prbs_7_2bit_pattern[249:254],16#3003c033,16#03fc3033,16#c3f330ff,16#cc03f030,16#c3cf33cf,16#f3c0f30c)

prbs_7_2bit_pattern[255:508] = prbs_7_2bit_pattern[1:254]

end_body

procedure Make4BitPrbs7Pattern
----------------------------------------------------------------------------------------------
--  This procedure loads an lword array named prbs_7_4bit_pattern with 508 lwords of data, 
--  which is 16256 bits.  The intent of this array is to provide a PRBS2^7-1 pattern at with
--  4 X data rate clocking. 
----------------------------------------------------------------------------------------------
body
awrite(prbs_7_4bit_pattern[1:4],16#fff0fff0,16#0ff00f0f,16#0f0fffff,16#ff000000)
awrite(prbs_7_4bit_pattern[5:8],16#f00000ff,16#0000f0f0,16#00ffff00,16#f000f0ff)
awrite(prbs_7_4bit_pattern[9:12],16#00fff0f0,16#f00fffff,16#0f0000ff,16#f000f00f)
awrite(prbs_7_4bit_pattern[13:16],16#00ff0ff0,16#f0ff0fff,16#f0ff000f,16#f0f00f0f)
awrite(prbs_7_4bit_pattern[17:20],16#ff0fff00,16#ff00f0f0,16#f0ffffff,16#f000000f)
awrite(prbs_7_4bit_pattern[21:24],16#00000ff0,16#000f0f00,16#0ffff00f,16#000f0ff0)
awrite(prbs_7_4bit_pattern[25:28],16#0fff0f0f,16#00fffff0,16#f0000fff,16#000f00f0)
awrite(prbs_7_4bit_pattern[29:32],16#0ff0ff0f,16#0ff0ffff,16#0ff000ff,16#0f00f0ff)
awrite(prbs_7_4bit_pattern[33:36],16#f0fff00f,16#f00f0f0f,16#0fffffff,16#000000f0)
awrite(prbs_7_4bit_pattern[37:40],16#0000ff00,16#00f0f000,16#ffff00f0,16#00f0ff00)
awrite(prbs_7_4bit_pattern[41:44],16#fff0f0f0,16#0fffff0f,16#0000fff0,16#00f00f00)
awrite(prbs_7_4bit_pattern[45:48],16#ff0ff0f0,16#ff0ffff0,16#ff000ff0,16#f00f0fff)
awrite(prbs_7_4bit_pattern[49:52],16#0fff00ff,16#00f0f0f0,16#fffffff0,16#00000f00)
awrite(prbs_7_4bit_pattern[53:56],16#000ff000,16#0f0f000f,16#fff00f00,16#0f0ff00f)
awrite(prbs_7_4bit_pattern[57:60],16#ff0f0f00,16#fffff0f0,16#000fff00,16#0f00f00f)
awrite(prbs_7_4bit_pattern[61:64],16#f0ff0f0f,16#f0ffff0f,16#f000ff0f,16#00f0fff0)
awrite(prbs_7_4bit_pattern[65:68],16#fff00ff0,16#0f0f0f0f,16#ffffff00,16#0000f000)
awrite(prbs_7_4bit_pattern[69:72],16#00ff0000,16#f0f000ff,16#ff00f000,16#f0ff00ff)
awrite(prbs_7_4bit_pattern[73:76],16#f0f0f00f,16#ffff0f00,16#00fff000,16#f00f00ff)
awrite(prbs_7_4bit_pattern[77:80],16#0ff0f0ff,16#0ffff0ff,16#000ff0f0,16#0f0fff0f)
awrite(prbs_7_4bit_pattern[81:84],16#ff00ff00,16#f0f0f0ff,16#fffff000,16#000f0000)
awrite(prbs_7_4bit_pattern[85:88],16#0ff0000f,16#0f000fff,16#f00f000f,16#0ff00fff)
awrite(prbs_7_4bit_pattern[89:92],16#0f0f00ff,16#fff0f000,16#0fff000f,16#00f00ff0)
awrite(prbs_7_4bit_pattern[93:96],16#ff0f0ff0,16#ffff0ff0,16#00ff0f00,16#f0fff0ff)
awrite(prbs_7_4bit_pattern[97:100],16#f00ff00f,16#0f0f0fff,16#ffff0000,16#00f00000)
awrite(prbs_7_4bit_pattern[101:104],16#ff0000f0,16#f000ffff,16#00f000f0,16#ff00fff0)
awrite(prbs_7_4bit_pattern[105:108],16#f0f00fff,16#ff0f0000,16#fff000f0,16#0f00ff0f)
awrite(prbs_7_4bit_pattern[109:112],16#f0f0ff0f,16#fff0ff00,16#0ff0f00f,16#0fff0fff)
awrite(prbs_7_4bit_pattern[113:116],16#00ff00f0,16#f0f0ffff,16#fff00000,16#0f00000f)
awrite(prbs_7_4bit_pattern[117:120],16#f0000f0f,16#000ffff0,16#0f000f0f,16#f00fff0f)
awrite(prbs_7_4bit_pattern[121:124],16#0f00ffff,16#f0f0000f,16#ff000f00,16#f00ff0ff)
awrite(prbs_7_4bit_pattern[125:127],16#0f0ff0ff,16#ff0ff000,16#ff0f00f0)
prbs_7_4bit_pattern[128:254] = prbs_7_4bit_pattern[1:127]
prbs_7_4bit_pattern[255:508] = prbs_7_4bit_pattern[1:254]
end_body

procedure MakeComma_K28_5_pattern
body
awrite(Comma_K28_5_pattern[1:5],16#3eb053eb,16#053eb053,16#eb053eb0,16#53eb053e,16#b053eb05) 
awrite(Comma_K28_5_pattern[6:10],16#3eb053eb,16#053eb053,16#eb053eb0,16#53eb053e,16#b053eb05)
awrite(Comma_K28_5_pattern[11:15],16#3eb053eb,16#053eb053,16#eb053eb0,16#53eb053e,16#b053eb05)
awrite(Comma_K28_5_pattern[16:20],16#3eb053eb,16#053eb053,16#eb053eb0,16#53eb053e,16#b053eb05)
end_body
procedure StartSpreadSpectrum(SpreadSpecName,ModulateClock,FreqOffset) 
in string[32] : SpreadSpecName  --  Module name for SMS patterns
in integer    : ModulateClock   -- Enter JIT_CLK for Jitter Clock or AUX_CLK for Auxiliary Clock
in double     : FreqOffset      -- Full Spectrum Clock Frequency Offset
body 
    if use_awghsb then   
         if  ModulateClock = JIT_CLK then
             connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to output b single ended pos -- Needed before R14.4
             connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to system coax
             SetJitterClkModulation("iq")
         else_if ModulateClock  = AUX_CLK then
             connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to user coax
             SetAuxiliaryClkIQ ( "on" )
         end_if
         stop awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> 
         set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> offset to ground 
         if  ModulateClock = JIT_CLK then
             set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to max 1.0V lpf FreqOffset * 1.15 
         else_if ModulateClock  = AUX_CLK then
             set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to max 0.5V lpf FreqOffset * 1.15 
         end_if
         set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> sample rate to AWGHSB_SS_SAMPLING_FREQ 
         initialize cx sync 
         set awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> clock to internal 
         connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> trigger to sync3 
         connect awghsb <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> start to sync3 
         start awghsb   <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> pattern SpreadSpecName triggered 
     else
         if  ModulateClock = JIT_CLK then
             connect awghs chan <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to system coax
             SetJitterClkModulation("iq")
         else_if ModulateClock  = AUX_CLK then
             connect awghs chan <:AWGHSB_I_CHAN,AWGHSB_Q_CHAN:> to user coax
             SetAuxiliaryClkIQ ( "on" )
         end_if
        set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> filter to float(FreqOffset * 1.15)         
        set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> common offset to gnd 
        initialize cx sync        
        set awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> to arm with sync3 trigger 
        start awghs chan <:AWGHS_I_CHAN,AWGHS_Q_CHAN:> pattern SpreadSpecName trigger on sync3 
     end_if     
     generate cx sync3 trigger        
end_body 

procedure SpreadSpectrumGtoTxSetup(GTO_S_Chans,SpreadSpecName,DataPatName,MaxDataRate,DiffLevel,TxConnection,FreqOffset,GTO_SrcPath)
in pin list[MAX_GTOS]  : GTO_S_Chans                  -- Selected VXGTO-S Channels           
in string[32]          : SpreadSpecName               --  Module name for SMS patterns
in string[32]          : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
in double              : MaxDataRate                     -- Maximum Data Rate of Transmitted data
in float               : DiffLevel                    -- Differential VXGTO-S output level used during Spread Spectrum testing
in integer             : TxConnection                 -- Select BALANCED, SE_PLUS or SE_MINUS  for VXGTO Source Output Connection
in double              : FreqOffset                   -- Half the Spread in Data Rates 
in integer             : GTO_SrcPath                  -- Select GTB_SRC if not using custom user source path, otherwise
                                                      -- select 1 of 3 custome user paths with GTB_SRC_USER1,GTB_SRC_USER2 or GTB_SRC_USER3
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure sets up the VXGTO transmitted output with programmed Spread Spectrum on a specified data
--  pattern. Spread Spectrum is provided by IQ modulation of the jitter clock. 
------------------------------------------------------------------------------------------------------------
local
    float              : AWG_FiltFreq                               -- Used for sampling rate selection.
    float              : MaxFreq                                    -- Highest frequency injected jitter tone
    integer            : NoOfInjectedTones                          -- Number of periodic jitter tones frequencies to be processed
    integer            : i
end_local
body

 
    set vx_gto GTO_S_Chans output bit rate frequency to MaxDataRate - FreqOffset 
    set vx_gto GTO_S_Chans output clock mode to jitter_clk
    EnableJitterClk("on",MaxDataRate - FreqOffset)      

    StartSpreadSpectrum(SpreadSpecName,JIT_CLK,FreqOffset) 
    
    SetJitterClkModulation("iq")
    
    if (GTO_SrcPath < GTB_SRC_USER1) or (GTO_SrcPath > GTB_SRC_USER3) then
        StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)
    else
        StartUserSrcOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTO_SrcPath)
    end_if

    wait(1ms)
end_body

procedure SpreadSpectrumSrcClkSetup(SpreadSpecName,ModulateClock,MaxClockFreq,ClockLevel,FreqOffset)
in string[32]          : SpreadSpecName               --  Module name for SMS patterns
in integer             : ModulateClock                -- Enter JIT_CLK for Jitter Clock or AUX_CLK for Auxiliary Clock
in double              : MaxClockFreq                 -- Maximum Clock Frequency
in float               : ClockLevel                   -- P-P Clock output level used during injected Spread Spectrum testing
in double              : FreqOffset                   -- Half the Spread in frequencies
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure sets up the Selected Clock output with Spread Spectrum modulation at the Specified P-P level.
--  Spread Spectrum is provided by IQ modulation of the jitter clock. 
------------------------------------------------------------------------------------------------------------
local
    double             : Level_dBm
end_local
body
    Level_dBm = 20.0 * log(double(ClockLevel)/0.6325)
    if ModulateClock = AUX_CLK  then
        SetAuxiliaryClkFrequency(MaxClockFreq - FreqOffset)
        SetAuxiliaryClkLevel (Level_dBm)
        SetAuxiliaryClkIQ ("on")
    else_if ModulateClock = JIT_CLK  then
        SetJitterClkFrequency(MaxClockFreq - FreqOffset)
        SetJitterClkLevel(Level_dBm)
        SetJitterClkModulation("iq")
    end_if

    StartSpreadSpectrum(SpreadSpecName,ModulateClock,FreqOffset) 

    wait(1ms)
end_body

procedure MakeTenthRatePattern

body
     awrite(GtoTenthRate_pattern[1:5],16#f83e0f83,16#e0f83e0f,16#83e0f83e,16#0f83e0f8,16#3e0f83e0) 
     awrite(GtoTenthRate_pattern[6:10],16#f83e0f83,16#e0f83e0f,16#83e0f83e,16#0f83e0f8,16#3e0f83e0)
     awrite(GtoTenthRate_pattern[11:15],16#f83e0f83,16#e0f83e0f,16#83e0f83e,16#0f83e0f8,16#3e0f83e0)
     awrite(GtoTenthRate_pattern[16:20],16#f83e0f83,16#e0f83e0f,16#83e0f83e,16#0f83e0f8,16#3e0f83e0)
end_body

procedure Make4BitTenthRatePattern
body
     awrite(GtoTenthRate_4bit_pattern[1:5],16#fffff000,16#00fffff0,16#0000ffff,16#f00000ff,16#fff00000)           
     awrite(GtoTenthRate_4bit_pattern[6:10] ,16#fffff000,16#00fffff0,16#0000ffff,16#f00000ff,16#fff00000)    
     awrite(GtoTenthRate_4bit_pattern[11:15],16#fffff000,16#00fffff0,16#0000ffff,16#f00000ff,16#fff00000)     
     awrite(GtoTenthRate_4bit_pattern[16:20],16#fffff000,16#00fffff0,16#0000ffff,16#f00000ff,16#fff00000)
end_body

procedure Make8BitPrbs7Pattern
----------------------------------------------------------------------------------------------
--  This procedure loads an lword array named prbs_7_8bit_pattern with 508 lwords of data, 
--  which is 16256 bits.  The intent of this array is to provide a PRBS2^7-1 pattern at with
--  8 X data rate clocking. 
----------------------------------------------------------------------------------------------
body
awrite(prbs_7_8bit_pattern[1:8],16#ffffff00,16#ffffff00,16#00ffff00,16#00ff00ff,16#00ff00ff,16#ffffffff,16#ffff0000,16#00000000)
awrite(prbs_7_8bit_pattern[9:16],16#ff000000,16#0000ffff,16#00000000,16#ff00ff00,16#0000ffff,16#ffff0000,16#ff000000,16#ff00ffff)
awrite(prbs_7_8bit_pattern[17:24],16#0000ffff,16#ff00ff00,16#ff0000ff,16#ffffffff,16#00ff0000,16#0000ffff,16#ff000000,16#ff0000ff)
awrite(prbs_7_8bit_pattern[25:32],16#0000ffff,16#00ffff00,16#ff00ffff,16#00ffffff,16#ff00ffff,16#000000ff,16#ff00ff00,16#00ff00ff)
awrite(prbs_7_8bit_pattern[33:40],16#ffff00ff,16#ffff0000,16#ffff0000,16#ff00ff00,16#ff00ffff,16#ffffffff,16#ff000000,16#000000ff)
awrite(prbs_7_8bit_pattern[41:48],16#00000000,16#00ffff00,16#000000ff,16#00ff0000,16#00ffffff,16#ff0000ff,16#000000ff,16#00ffff00)
awrite(prbs_7_8bit_pattern[49:56],16#00ffffff,16#00ff00ff,16#0000ffff,16#ffffff00,16#ff000000,16#00ffffff,16#000000ff,16#0000ff00)
awrite(prbs_7_8bit_pattern[57:64],16#00ffff00,16#ffff00ff,16#00ffff00,16#ffffffff,16#00ffff00,16#0000ffff,16#00ff0000,16#ff00ffff)
awrite(prbs_7_8bit_pattern[65:72],16#ff00ffff,16#ff0000ff,16#ff0000ff,16#00ff00ff,16#00ffffff,16#ffffffff,16#00000000,16#0000ff00)
awrite(prbs_7_8bit_pattern[73:80],16#00000000,16#ffff0000,16#0000ff00,16#ff000000,16#ffffffff,16#0000ff00,16#0000ff00,16#ffff0000)
awrite(prbs_7_8bit_pattern[81:88],16#ffffff00,16#ff00ff00,16#00ffffff,16#ffff00ff,16#00000000,16#ffffff00,16#0000ff00,16#00ff0000)
awrite(prbs_7_8bit_pattern[89:96],16#ffff00ff,16#ff00ff00,16#ffff00ff,16#ffffff00,16#ffff0000,16#00ffff00,16#ff0000ff,16#00ffffff)
awrite(prbs_7_8bit_pattern[97:104],16#00ffffff,16#0000ffff,16#0000ff00,16#ff00ff00,16#ffffffff,16#ffffff00,16#00000000,16#00ff0000)
awrite(prbs_7_8bit_pattern[105:112],16#000000ff,16#ff000000,16#00ff00ff,16#000000ff,16#ffffff00,16#00ff0000,16#00ff00ff,16#ff0000ff)
awrite(prbs_7_8bit_pattern[113:120],16#ffff00ff,16#00ff0000,16#ffffffff,16#ff00ff00,16#000000ff,16#ffff0000,16#00ff0000,16#ff0000ff)
awrite(prbs_7_8bit_pattern[121:127],16#ff00ffff,16#00ff00ff,16#ff00ffff,16#ffff00ff,16#ff000000,16#ffff00ff,16#0000ff00)
prbs_7_8bit_pattern[128:254] = prbs_7_8bit_pattern[1:127]
prbs_7_8bit_pattern[255:508] = prbs_7_8bit_pattern[1:254]
end_body

procedure Make8BitPrbs7InvPattern
----------------------------------------------------------------------------------------------
--  This procedure loads an lword array named prbs_7_8bit_pattern with 508 lwords of data, 
--  which is 16256 bits.  The intent of this array is to provide a PRBS2^7-1 inverted pattern at with
--  8 X data rate clocking. 
----------------------------------------------------------------------------------------------
body
awrite(prbs_7Inv_8bit_pattern[1:8],16#000000ff,16#000000ff,16#ff0000ff,16#ff00ff00,16#ff00ff00,16#00000000,16#0000ffff,16#ffffffff)
awrite(prbs_7Inv_8bit_pattern[9:16],16#00ffffff,16#ffff0000,16#ffffffff,16#00ff00ff,16#ffff0000,16#0000ffff,16#00ffffff,16#00ff0000)
awrite(prbs_7Inv_8bit_pattern[17:24],16#ffff0000,16#00ff00ff,16#00ffff00,16#00000000,16#ff00ffff,16#ffff0000,16#00ffffff,16#00ffff00)
awrite(prbs_7Inv_8bit_pattern[25:32],16#ffff0000,16#ff0000ff,16#00ff0000,16#ff000000,16#00ff0000,16#ffffff00,16#00ff00ff,16#ff00ff00)
awrite(prbs_7Inv_8bit_pattern[33:40],16#0000ff00,16#0000ffff,16#0000ffff,16#00ff00ff,16#00ff0000,16#00000000,16#00ffffff,16#ffffff00)
awrite(prbs_7Inv_8bit_pattern[41:48],16#ffffffff,16#ff0000ff,16#ffffff00,16#ff00ffff,16#ff000000,16#00ffff00,16#ffffff00,16#ff0000ff)
awrite(prbs_7Inv_8bit_pattern[49:56],16#ff000000,16#ff00ff00,16#ffff0000,16#000000ff,16#00ffffff,16#ff000000,16#ffffff00,16#ffff00ff)
awrite(prbs_7Inv_8bit_pattern[57:64],16#ff0000ff,16#0000ff00,16#ff0000ff,16#00000000,16#ff0000ff,16#ffff0000,16#ff00ffff,16#00ff0000)
awrite(prbs_7Inv_8bit_pattern[65:72],16#00ff0000,16#00ffff00,16#00ffff00,16#ff00ff00,16#ff000000,16#00000000,16#ffffffff,16#ffff00ff)
awrite(prbs_7Inv_8bit_pattern[73:80],16#ffffffff,16#0000ffff,16#ffff00ff,16#00ffffff,16#00000000,16#ffff00ff,16#ffff00ff,16#0000ffff)
awrite(prbs_7Inv_8bit_pattern[81:88],16#000000ff,16#00ff00ff,16#ff000000,16#0000ff00,16#ffffffff,16#000000ff,16#ffff00ff,16#ff00ffff)
awrite(prbs_7Inv_8bit_pattern[89:96],16#0000ff00,16#00ff00ff,16#0000ff00,16#000000ff,16#0000ffff,16#ff0000ff,16#00ffff00,16#ff000000)
awrite(prbs_7Inv_8bit_pattern[97:104],16#ff000000,16#ffff0000,16#ffff00ff,16#00ff00ff,16#00000000,16#000000ff,16#ffffffff,16#ff00ffff)
awrite(prbs_7Inv_8bit_pattern[105:112],16#ffffff00,16#00ffffff,16#ff00ff00,16#ffffff00,16#000000ff,16#ff00ffff,16#ff00ff00,16#00ffff00)
awrite(prbs_7Inv_8bit_pattern[113:120],16#0000ff00,16#ff00ffff,16#00000000,16#00ff00ff,16#ffffff00,16#0000ffff,16#ff00ffff,16#00ffff00)
awrite(prbs_7Inv_8bit_pattern[121:127],16#00ff0000,16#ff00ff00,16#00ff0000,16#0000ff00,16#00ffffff,16#0000ff00,16#ffff00ff)
prbs_7Inv_8bit_pattern[128:254] = prbs_7Inv_8bit_pattern[1:127]
prbs_7Inv_8bit_pattern[255:508] = prbs_7Inv_8bit_pattern[1:254]
end_body

procedure GenerateAndCalSpreadSpectrum( GTO_S_Chans,SampDighsPins,DataPatName,SpreadSpecName,ClkFreq,SourceClock,ModulateClock,BitsPerWaveform,NomDataRate,DownSpreading,ModFreq,SpreadPercent,SamplerConnection,MeasurementScale,ResBandwidth,FreqOffset)
 in pin list[MAX_GTOS]  : GTO_S_Chans     -- Selected VXGTO-S Channels           
 in pin list[MAX_DIGHS] : SampDighsPins   -- Selected DIGHS Channels                
 in string[32]          : DataPatName     -- A string identifier for selected VXGTO TX Data pattern
 in string[32]          : SpreadSpecName  -- Module name for modulation patterns
 in double              : ClkFreq         -- Nominal frequency of clock being generated.
 in integer             : SourceClock     -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
 in integer             : ModulateClock   -- Enter JIT_CLK for Jitter Clock, AUX_CLK for Auxiliary Clock or SAMP_CLK for Sampler Clock
 in integer             : BitsPerWaveform -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
 in double              : NomDataRate     -- Nominal Data Rate of Transmitted data  -- Enter nominal clock frequency if not transmitting VXGTO data.
 in boolean             : DownSpreading   -- Set true if Nominal Data Rate is Maximum Data rate otherwise set false
 in double              : ModFreq         -- Sawtooth Modulation Frequency. Typically 30KHz or in 20KHz to 40KHz range 
 in float               : SpreadPercent   -- Percentage of Spectrum to spread (100 X (MaxFreq -MinFreq)/ClkFreq)
 in multisite integer   : SamplerConnection[MAX_DIGHS]   -- AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
 in  float              : MeasurementScale-- Scale factor to correct for attenuation in measurement path  
 in float               : ResBandwidth    -- Resolution Bandwidth, Enter value between 6.25KHz and 500KHz, 100KHz default value.
 out double             : FreqOffset      -- Full Spectrum Clock Frequency Offset
local
    float               : DiffLevel = 0.9999  
    float               : SpreadScale
    float               : MeasSpreadPct
    double              : DataRate
    double              : HighDataRate
    double              : DutClockFreq  
    double              : FreqShift             
    integer             : TxConnection = BALANCED
    double              : SpectrumReferenceFreq      -- Spectrum Reference Frequency -- Local Oscillator
    double              : FreqBinSize       -- Size of frequency bins -- Capture Resolution Bandwidth
    double              : DownSpreadingRef  -- Spectrum Reference for Top of Down Spreading Range
    boolean             : StartOnTrigger
    word list[16]       : SiteList
    multisite  float    : peak_reduction[MAX_DIGHS]        -- Measure peak reduction
    multisite  float    : spreading_range[MAX_DIGHS]       -- Measured  Spreading Range
    multisite  float    : LowFrequency[MAX_DIGHS]          -- Measured  Low frequency
    multisite  float    : HighFrequency[MAX_DIGHS]         -- Measured  High Frequency
end_local
body
    SiteList  = get_active_sites
    SpreadSpecGenPass1 = true
    GenerateSpreadSpectrum(SpreadSpecName,ClkFreq,ModulateClock,ModFreq,SpreadPercent,FreqOffset)
    FreqShift = FreqOffset * NomDataRate/ClkFreq
    if DownSpreading then
        DataRate = NomDataRate -  FreqShift
        HighDataRate = NomDataRate
    else
        DataRate = NomDataRate
        HighDataRate = NomDataRate + FreqShift    
    end_if
    if GTO_S_Chans <> <::> then
        SelectGtoSrcClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq) 
    end_if
    StartJitterModulation(SpreadSpecName,ModulateClock,99MHz)
    if GTO_S_Chans <> <::> then
        StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)
    end_if
    SetupSpreadSpectrumMeas(SampDighsPins,SpreadPercent,HighDataRate,BitsPerWaveform,DiffLevel/MeasurementScale,SamplerConnection,SpectrumReferenceFreq,FreqBinSize,DownSpreadingRef)
    wait(300mS)
    SpreadSpectrumMeasurement(SampDighsPins,StartOnTrigger,SpectrumReferenceFreq,DownSpreadingRef,ResBandwidth,DownSpreading,peak_reduction,spreading_range,LowFrequency,HighFrequency)
    MeasSpreadPct = spreading_range[SiteList[1],1]/float(NomDataRate)* float(BitsPerWaveform)
    SpreadScale = SpreadPercent/MeasSpreadPct/100.0
    SpreadSpecGenPass1 = false
    GenerateSpreadSpectrum(SpreadSpecName,ClkFreq,ModulateClock,ModFreq,SpreadPercent*SpreadScale,FreqOffset)
    SpreadSpecGenPass1 = true
end_body

procedure Make_2XK28_5_pattern
body
awrite(Comma_2XK28_5_pattern[1:5],16#0ffccf00,16#330ffccf,16#00330ffc,16#cf00330f,16#fccf0033) 
awrite(Comma_2XK28_5_pattern[6:10],16#0ffccf00,16#330ffccf,16#00330ffc,16#cf00330f,16#fccf0033)
awrite(Comma_2XK28_5_pattern[11:15],16#0ffccf00,16#330ffccf,16#00330ffc,16#cf00330f,16#fccf0033)
awrite(Comma_2XK28_5_pattern[16:20],16#0ffccf00,16#330ffccf,16#00330ffc,16#cf00330f,16#fccf0033)
end_body
procedure Make_4XK28_5_pattern
body
awrite(Comma_4XK28_5_pattern[1:5],16#00fffff0,16#f0ff0000,16#0f0f00ff,16#fff0f0ff,16#00000f0f) 
awrite(Comma_4XK28_5_pattern[6:10],16#00fffff0,16#f0ff0000,16#0f0f00ff,16#fff0f0ff,16#00000f0f)
awrite(Comma_4XK28_5_pattern[11:15],16#00fffff0,16#f0ff0000,16#0f0f00ff,16#fff0f0ff,16#00000f0f)
awrite(Comma_4XK28_5_pattern[16:20],16#00fffff0,16#f0ff0000,16#0f0f00ff,16#fff0f0ff,16#00000f0f)
end_body
procedure Make_8XK28_5_pattern
body
awrite(Comma_8XK28_5_pattern[1:5],16#0000ffff,16#ffffff00,16#ff00ffff,16#00000000,16#00ff00ff) 
awrite(Comma_8XK28_5_pattern[6:10],16#0000ffff,16#ffffff00,16#ff00ffff,16#00000000,16#00ff00ff)
awrite(Comma_8XK28_5_pattern[11:15],16#0000ffff,16#ffffff00,16#ff00ffff,16#00000000,16#00ff00ff)
awrite(Comma_8XK28_5_pattern[16:20],16#0000ffff,16#ffffff00,16#ff00ffff,16#00000000,16#00ff00ff)
end_body
procedure MakePrbs7_20CidPattern
----------------------------------------------------------------------------------------------
--  This procedure loads an lword array named prbs7_20cid_pattern with 588 lwords of data, 
--  which is 18816 bits.  The intent of this array is to provide a PRBS2^7-1 + 20CID (ones)
-- + inverted PRBS2^7-1 + 20CID (zeros) pattern. 
----------------------------------------------------------------------------------------------
body

awrite(prbs7_20cid_pattern[1:8],16#020c28f2,16#2cea7d0e,16#24dadec6,16#97732aff,16#ffffffbe,16#7ae1ba62,16#b05e3b64,16#a4272d11)
awrite(prbs7_20cid_pattern[9:16],16#9aa00000,16#000830a3,16#c8b3a9f4,16#38936b7b,16#1a5dccab,16#fffffffe,16#f9eb86e9,16#8ac178ed)
awrite(prbs7_20cid_pattern[17:24],16#92909cb4,16#466a8000,16#000020c2,16#8f22cea7,16#d0e24dad,16#ec697732,16#afffffff,16#fbe7ae1b)
awrite(prbs7_20cid_pattern[25:32],16#a62b05e3,16#b64a4272,16#d119aa00,16#00000083,16#0a3c8b3a,16#9f438936,16#b7b1a5dc,16#cabfffff)
awrite(prbs7_20cid_pattern[33:40],16#ffef9eb8,16#6e98ac17,16#8ed92909,16#cb4466a8,16#00000002,16#0c28f22c,16#ea7d0e24,16#dadec697)
awrite(prbs7_20cid_pattern[41:48],16#732affff,16#ffffbe7a,16#e1ba62b0,16#5e3b64a4,16#272d119a,16#a0000000,16#0830a3c8,16#b3a9f438)
awrite(prbs7_20cid_pattern[49:56],16#936b7b1a,16#5dccabff,16#fffffef9,16#eb86e98a,16#c178ed92,16#909cb446,16#6a800000,16#0020c28f)
awrite(prbs7_20cid_pattern[57:64],16#22cea7d0,16#e24dadec,16#697732af,16#fffffffb,16#e7ae1ba6,16#2b05e3b6,16#4a4272d1,16#19aa0000)
awrite(prbs7_20cid_pattern[65:72],16#0000830a,16#3c8b3a9f,16#438936b7,16#b1a5dcca,16#bfffffff,16#ef9eb86e,16#98ac178e,16#d92909cb)
awrite(prbs7_20cid_pattern[73:80],16#4466a800,16#0000020c,16#28f22cea,16#7d0e24da,16#dec69773,16#2affffff,16#ffbe7ae1,16#ba62b05e)
awrite(prbs7_20cid_pattern[81:88],16#3b64a427,16#2d119aa0,16#00000008,16#30a3c8b3,16#a9f43893,16#6b7b1a5d,16#ccabffff,16#fffef9eb)
awrite(prbs7_20cid_pattern[89:96],16#86e98ac1,16#78ed9290,16#9cb4466a,16#80000000,16#20c28f22,16#cea7d0e2,16#4dadec69,16#7732afff)
awrite(prbs7_20cid_pattern[97:104],16#fffffbe7,16#ae1ba62b,16#05e3b64a,16#4272d119,16#aa000000,16#00830a3c,16#8b3a9f43,16#8936b7b1)
awrite(prbs7_20cid_pattern[105:112],16#a5dccabf,16#ffffffef,16#9eb86e98,16#ac178ed9,16#2909cb44,16#66a80000,16#00020c28,16#f22cea7d)
awrite(prbs7_20cid_pattern[113:120],16#0e24dade,16#c697732a,16#ffffffff,16#be7ae1ba,16#62b05e3b,16#64a4272d,16#119aa000,16#00000830)
awrite(prbs7_20cid_pattern[121:128],16#a3c8b3a9,16#f438936b,16#7b1a5dcc,16#abffffff,16#fef9eb86,16#e98ac178,16#ed92909c,16#b4466a80)
awrite(prbs7_20cid_pattern[129:136],16#00000020,16#c28f22ce,16#a7d0e24d,16#adec6977,16#32afffff,16#fffbe7ae,16#1ba62b05,16#e3b64a42)
awrite(prbs7_20cid_pattern[137:144],16#72d119aa,16#00000000,16#830a3c8b,16#3a9f4389,16#36b7b1a5,16#dccabfff,16#ffffef9e,16#b86e98ac)
awrite(prbs7_20cid_pattern[145:147],16#178ed929,16#09cb4466,16#a8000000)
prbs7_20cid_pattern[148:294] = prbs7_20cid_pattern[1:147]
prbs7_20cid_pattern[295:588] = prbs7_20cid_pattern[1:294]

end_body


procedure MakePrbs7_96CidPattern
----------------------------------------------------------------------------------------------
--  This procedure loads an lword array named prbs7_96cid_pattern with 892 lwords of data,16# 
--  which is 28544 bits.  The intent of this array is to provide a PRBS2^7-1 + 96CID (ones)
-- + inverted PRBS2^7-1 + 96CID (zeros) pattern. 
----------------------------------------------------------------------------------------------
body
awrite(prbs7_96cid_pattern[1:8],16#0020c28f,16#22cea7d0,16#e24dadec,16#697732af,16#ffffffff,16#ffffffff,16#ffffffff,16#ffbe7ae1)
awrite(prbs7_96cid_pattern[9:16],16#ba62b05e,16#3b64a427,16#2d119aa0,16#00000000,16#00000000,16#00000000,16#00830a3c,16#8b3a9f43)
awrite(prbs7_96cid_pattern[17:24],16#8936b7b1,16#a5dccabf,16#ffffffff,16#ffffffff,16#ffffffff,16#fef9eb86,16#e98ac178,16#ed92909c)
awrite(prbs7_96cid_pattern[25:32],16#b4466a80,16#00000000,16#00000000,16#00000000,16#020c28f2,16#2cea7d0e,16#24dadec6,16#97732aff)
awrite(prbs7_96cid_pattern[33:40],16#ffffffff,16#ffffffff,16#ffffffff,16#fbe7ae1b,16#a62b05e3,16#b64a4272,16#d119aa00,16#00000000)
awrite(prbs7_96cid_pattern[41:48],16#00000000,16#00000000,16#0830a3c8,16#b3a9f438,16#936b7b1a,16#5dccabff,16#ffffffff,16#ffffffff)
awrite(prbs7_96cid_pattern[49:56],16#ffffffff,16#ef9eb86e,16#98ac178e,16#d92909cb,16#4466a800,16#00000000,16#00000000,16#00000000)
awrite(prbs7_96cid_pattern[57:64],16#20c28f22,16#cea7d0e2,16#4dadec69,16#7732afff,16#ffffffff,16#ffffffff,16#ffffffff,16#be7ae1ba)
awrite(prbs7_96cid_pattern[65:72],16#62b05e3b,16#64a4272d,16#119aa000,16#00000000,16#00000000,16#00000000,16#830a3c8b,16#3a9f4389)
awrite(prbs7_96cid_pattern[73:80],16#36b7b1a5,16#dccabfff,16#ffffffff,16#ffffffff,16#fffffffe,16#f9eb86e9,16#8ac178ed,16#92909cb4)
awrite(prbs7_96cid_pattern[81:88],16#466a8000,16#00000000,16#00000000,16#00000002,16#0c28f22c,16#ea7d0e24,16#dadec697,16#732affff)
awrite(prbs7_96cid_pattern[89:96],16#ffffffff,16#ffffffff,16#fffffffb,16#e7ae1ba6,16#2b05e3b6,16#4a4272d1,16#19aa0000,16#00000000)
awrite(prbs7_96cid_pattern[97:104],16#00000000,16#00000008,16#30a3c8b3,16#a9f43893,16#6b7b1a5d,16#ccabffff,16#ffffffff,16#ffffffff)
awrite(prbs7_96cid_pattern[105:112],16#ffffffef,16#9eb86e98,16#ac178ed9,16#2909cb44,16#66a80000,16#00000000,16#00000000,16#00000020)
awrite(prbs7_96cid_pattern[113:120],16#c28f22ce,16#a7d0e24d,16#adec6977,16#32afffff,16#ffffffff,16#ffffffff,16#ffffffbe,16#7ae1ba62)
awrite(prbs7_96cid_pattern[121:128],16#b05e3b64,16#a4272d11,16#9aa00000,16#00000000,16#00000000,16#00000083,16#0a3c8b3a,16#9f438936)
awrite(prbs7_96cid_pattern[129:136],16#b7b1a5dc,16#cabfffff,16#ffffffff,16#ffffffff,16#fffffef9,16#eb86e98a,16#c178ed92,16#909cb446)
awrite(prbs7_96cid_pattern[137:144],16#6a800000,16#00000000,16#00000000,16#0000020c,16#28f22cea,16#7d0e24da,16#dec69773,16#2affffff)
awrite(prbs7_96cid_pattern[145:152],16#ffffffff,16#ffffffff,16#fffffbe7,16#ae1ba62b,16#05e3b64a,16#4272d119,16#aa000000,16#00000000)
awrite(prbs7_96cid_pattern[153:160],16#00000000,16#00000830,16#a3c8b3a9,16#f438936b,16#7b1a5dcc,16#abffffff,16#ffffffff,16#ffffffff)
awrite(prbs7_96cid_pattern[161:168],16#ffffef9e,16#b86e98ac,16#178ed929,16#09cb4466,16#a8000000,16#00000000,16#00000000,16#000020c2)
awrite(prbs7_96cid_pattern[169:176],16#8f22cea7,16#d0e24dad,16#ec697732,16#afffffff,16#ffffffff,16#ffffffff,16#ffffbe7a,16#e1ba62b0)
awrite(prbs7_96cid_pattern[177:184],16#5e3b64a4,16#272d119a,16#a0000000,16#00000000,16#00000000,16#0000830a,16#3c8b3a9f,16#438936b7)
awrite(prbs7_96cid_pattern[185:192],16#b1a5dcca,16#bfffffff,16#ffffffff,16#ffffffff,16#fffef9eb,16#86e98ac1,16#78ed9290,16#9cb4466a)
awrite(prbs7_96cid_pattern[193:200],16#80000000,16#00000000,16#00000000,16#00020c28,16#f22cea7d,16#0e24dade,16#c697732a,16#ffffffff)
awrite(prbs7_96cid_pattern[201:208],16#ffffffff,16#ffffffff,16#fffbe7ae,16#1ba62b05,16#e3b64a42,16#72d119aa,16#00000000,16#00000000)
awrite(prbs7_96cid_pattern[209:216],16#00000000,16#000830a3,16#c8b3a9f4,16#38936b7b,16#1a5dccab,16#ffffffff,16#ffffffff,16#ffffffff)
awrite(prbs7_96cid_pattern[217:223],16#ffef9eb8,16#6e98ac17,16#8ed92909,16#cb4466a8,16#00000000,16#00000000,16#00000000)

prbs7_96cid_pattern[224:446] = prbs7_96cid_pattern[1:223]
prbs7_96cid_pattern[447:892] = prbs7_96cid_pattern[1:446]

end_body

procedure GenerateSinisoidalJitter_NOCAL(GTO_S_Chans,SampDighsPins,JitPatName,DataPatName,BitsPerWaveform,DataRate,MeasLevelMax,MeasurementScale,SourceClock,ModulateClock, DutClockFreq,SamplerConnection,JitTone,JitToneAmp,jitter_measured)
 in pin list[MAX_GTOS]  : GTO_S_Chans                  -- Selected VXGTO-S Channels           
 in pin list[MAX_DIGHS] : SampDighsPins                -- Selected DIGHS Channels                
 in string[32]          : JitPatName                   -- A string identifier for selected Injected Sinusoidal Jitter Tones
 in string[32]          : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
 in integer             : BitsPerWaveform              -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
 in double              : DataRate                     -- Data Rate of Transmitted data
 in  float              : MeasLevelMax                 -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
 in  float              : MeasurementScale                -- Scale factor to correct for attenuation in measurement path  
 in integer             : SourceClock                  -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
 in integer             : ModulateClock                -- Selected Clock to Apply Jitter Enter JIT_CLK for Jitter Clock, AUX_CLK for reference (Aux) Clock, or SAMP_CLK for Sampler Clock
 in double              : DutClockFreq                 -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock
 in multisite integer   : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float                : JitTone[?]                   -- Array of Injected Jitter Tone Frequencies  -- Maximum size set to 3 Tones
in float                : JitToneAmp[?]                -- Array of Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
out float               : jitter_measured              -- measured jitter in calibration
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure is intended to calibrate injected sinusoidal jitter generated by the VXGTO transmitter output and
-- should be used as a focused calibration executed once during program load for each required injected jitter waveform. 
-- Up to 3 Jitter tones may be included in a single waveform.  Maximum frequency of injected Jitter is limited by the
-- maximum sampling rate of the AWGHS to below 60MHz.  Each individual jitter waveform is identified by a unique string name
-- passed into this procedure.  The string identifier can later be used by other procedures within this module to inject the 
-- specified jitter waveform. 
------------------------------------------------------------------------------------------------------------
local
    float              : JitToneScale[MAX_NO_JITTER_TONES]          -- Scaled injected jitter tone amplitudes for calibration
    multisite  float   : JitToneMeas[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Measured jitter tone amplitudes
    multisite  float   : JitToneAvg[MAX_DIGHS*MAX_NO_JITTER_TONES]  -- Measured jitter tone amplitudes
    float              : FreqBinSize                                -- Frequency Bin Size in jitter injection spectrum 
    float              : AWG_FiltFreq                               -- Reconstruction Filter Selection also used for sampling rate selection.
    float              : DiffLevel = 0.9999                         -- Differential VXGTO-S output level used during injected jitter calibration
    float              : MaxFreq
    float              : JitMeasUI
    float              : JitAmpRef
    double             : ScopeSyncFreq
    integer            : NoOfInjectedTones                          -- Number of periodic jitter tones frequencies to be processed
    integer            : i
    integer            : TxConnection = BALANCED
    multisite double   : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysisend_local 
    boolean            : ScopeView 
end_local
body

    if tester_simulated then
        return
    end_if

    JitAmpRef = JitToneAmp[1]
    SelectGtoSrcClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq) 
    GenerateJitterTones(JitPatName,JitTone,JitToneAmp,AWG_FiltFreq) 
    StartJitterModulation(JitPatName,ModulateClock,AWG_FiltFreq)
    StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)

    -----------------------------------------
    -- Following for debug
    -----------------------------------------
    if True then
        NoOfInjectedTones = dimsize(JitTone,1)
        MaxFreq = 0.0
        for i = 1 to NoOfInjectedTones do
            if MaxFreq < JitTone[i] then 
                MaxFreq = JitTone[i]
            end_if
        end_for

        FullSpectrum = true

        SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,MaxFreq * 2.0)
        wait(100.0ms)
        JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)
    end_if
    
    jitter_measured = JitToneMeas[1,1]
    wait(0s)
        
end_body
procedure GenerateSinisoidalJitter_Segment(GTO_S_Chans,SampDighsPins,JitPatName,DataPatName,BitsPerWaveform,DataRate,MeasLevelMax,MeasurementScale,SourceClock,ModulateClock, DutClockFreq,SamplerConnection,JitTone,JitToneAmp,jitter_measured)
 in pin list[MAX_GTOS]  : GTO_S_Chans                  -- Selected VXGTO-S Channels           
 in pin list[MAX_DIGHS] : SampDighsPins                -- Selected DIGHS Channels                
 in string[32]          : JitPatName                   -- A string identifier for selected Injected Sinusoidal Jitter Tones
 in string[32]          : DataPatName                  -- A string identifier for selected VXGTO TX Data pattern
 in integer             : BitsPerWaveform              -- Length in bits in the waveform (e.g. 2 for repeating 10 data pattern)
 in double              : DataRate                     -- Data Rate of Transmitted data
 in  float              : MeasLevelMax                 -- Maximum differential voltage expected in measured waveform (Sets up DIGHS measurement range)
 in  float              : MeasurementScale                -- Scale factor to correct for attenuation in measurement path  
 in integer             : SourceClock                  -- VXGTO-S TX Clock Source JIT_CLK for Jitter Clock, SYS_CLK for System Clock,DUT_CLK for Clockfrom DUT Board
 in integer             : ModulateClock                -- Selected Clock to Apply Jitter Enter JIT_CLK for Jitter Clock, AUX_CLK for reference (Aux) Clock, or SAMP_CLK for Sampler Clock
 in double              : DutClockFreq                 -- Frequency of DUT Clock input if DUT_CLK selected for SourceClock
 in multisite integer   : SamplerConnection[MAX_DIGHS] --  AUX_IN_ODD_CHAN, DATA_IN_ODD_CHAN, AUX_IN_EVEN_CHAN or DATA_IN_EVEN_CHAN
in float                : JitTone[?]                   -- Array of Injected Jitter Tone Frequencies  -- Maximum size set to 3 Tones
in float                : JitToneAmp[?]                -- Array of Jitter Tone Amplitudes in UI -- Size must match size of "Jit Tone" 
out float               : jitter_measured              -- measured jitter in calibration
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
-- This procedure is intended to calibrate injected sinusoidal jitter generated by the VXGTO transmitter output and
-- should be used as a focused calibration executed once during program load for each required injected jitter waveform. 
-- Up to 3 Jitter tones may be included in a single waveform.  Maximum frequency of injected Jitter is limited by the
-- maximum sampling rate of the AWGHS to below 60MHz.  Each individual jitter waveform is identified by a unique string name
-- passed into this procedure.  The string identifier can later be used by other procedures within this module to inject the 
-- specified jitter waveform. 
------------------------------------------------------------------------------------------------------------
local
    float              : JitToneScale[MAX_NO_JITTER_TONES]          -- Scaled injected jitter tone amplitudes for calibration
    multisite  float   : JitToneMeas[MAX_DIGHS*MAX_NO_JITTER_TONES] -- Measured jitter tone amplitudes
    multisite  float   : JitToneAvg[MAX_DIGHS*MAX_NO_JITTER_TONES]  -- Measured jitter tone amplitudes
    float              : FreqBinSize                                -- Frequency Bin Size in jitter injection spectrum 
    float              : AWG_FiltFreq                               -- Reconstruction Filter Selection also used for sampling rate selection.
    float              : DiffLevel = 0.9999                         -- Differential VXGTO-S output level used during injected jitter calibration
    float              : MaxFreq
    float              : JitMeasUI
    float              : JitAmpRef
    double             : ScopeSyncFreq
    integer            : NoOfInjectedTones                          -- Number of periodic jitter tones frequencies to be processed
    integer            : i
    integer            : TxConnection = BALANCED
    multisite double   : RandomJitter[MAX_DIGHS]                    -- Random Jitter measurement Output Parameter from procedure SpectrumAnalysisend_local 
    boolean            : ScopeView 
end_local
body

    if tester_simulated then
        return
    end_if

    JitAmpRef = JitToneAmp[1]
    SelectGtoSrcClk(GTO_S_Chans,DataRate,SourceClock,DutClockFreq) 
    GenerateJitterTones(JitPatName,JitTone,JitToneAmp,AWG_FiltFreq) 

    wait(100ms)  --need this time..
    
     --StartJitterModulation(JitPatName,ModulateClock,AWG_FiltFreq)
     --StartGtoDataOutput(GTO_S_Chans,DataPatName,DiffLevel,TxConnection,GTB_NORMAL_SOURCE_RANGING)

    -----------------------------------------
    -- Following for debug
    -----------------------------------------
    if False then
        NoOfInjectedTones = dimsize(JitTone,1)
        MaxFreq = 0.0
        for i = 1 to NoOfInjectedTones do
            if MaxFreq < JitTone[i] then 
                MaxFreq = JitTone[i]
            end_if
        end_for

        FullSpectrum = true

        SetupSpectrumAnalysis(SamplerConnection,SampDighsPins,DataRate,BitsPerWaveform,MeasLevelMax/MeasurementScale,MaxFreq * 2.0)
        wait(100.0ms)
        JitterToneMeasurements(SampDighsPins,BitsPerWaveform,DataRate,MeasLevelMax,JitTone,JitToneMeas,RandomJitter)
    end_if
    
    jitter_measured = JitToneMeas[1,1]
    wait(0s)
        
end_body
